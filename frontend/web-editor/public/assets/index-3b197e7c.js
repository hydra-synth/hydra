(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link2) {
    const fetchOpts = {};
    if (link2.integrity)
      fetchOpts.integrity = link2.integrity;
    if (link2.referrerPolicy)
      fetchOpts.referrerPolicy = link2.referrerPolicy;
    if (link2.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link2.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f, args);
        return new Ctor();
      }
      return f.apply(this, arguments);
    };
    a2.prototype = f.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d2 = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var events$2 = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter$3() {
  EventEmitter$3.init.call(this);
}
events$2.exports = EventEmitter$3;
events$2.exports.once = once$2;
EventEmitter$3.EventEmitter = EventEmitter$3;
EventEmitter$3.prototype._events = void 0;
EventEmitter$3.prototype._eventsCount = 0;
EventEmitter$3.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$3, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg2) {
    if (typeof arg2 !== "number" || arg2 < 0 || NumberIsNaN(arg2)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg2 + ".");
    }
    defaultMaxListeners = arg2;
  }
});
EventEmitter$3.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$3.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$3.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$3.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$3.prototype.emit = function emit(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i2 = 0; i2 < len2; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter$3.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$3.prototype.on = EventEmitter$3.prototype.addListener;
EventEmitter$3.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$3.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$3.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$3.prototype.removeListener = function removeListener(type, listener) {
  var list2, events2, position, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list2 = events2[type];
  if (list2 === void 0)
    return this;
  if (list2 === listener || list2.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list2.listener || listener);
    }
  } else if (typeof list2 !== "function") {
    position = -1;
    for (i2 = list2.length - 1; i2 >= 0; i2--) {
      if (list2[i2] === listener || list2[i2].listener === listener) {
        originalListener = list2[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list2.shift();
    else {
      spliceOne(list2, position);
    }
    if (list2.length === 1)
      events2[type] = list2[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$3.prototype.off = EventEmitter$3.prototype.removeListener;
EventEmitter$3.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys3 = Object.keys(events2);
    var key;
    for (i2 = 0; i2 < keys3.length; ++i2) {
      key = keys3[i2];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter$3.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter$3.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter$3.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter$3.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$3.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr2, n) {
  var copy2 = new Array(n);
  for (var i2 = 0; i2 < n; ++i2)
    copy2[i2] = arr2[i2];
  return copy2;
}
function spliceOne(list2, index2) {
  for (; index2 + 1 < list2.length; index2++)
    list2[index2] = list2[index2 + 1];
  list2.pop();
}
function unwrapListeners(arr2) {
  var ret = new Array(arr2.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr2[i2].listener || arr2[i2];
  }
  return ret;
}
function once$2(emitter, name) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg2) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg2);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events$2.exports;
var prettierBytes_1 = prettierBytes;
function prettierBytes(num) {
  if (typeof num !== "number" || isNaN(num)) {
    throw new TypeError("Expected a number, got " + typeof num);
  }
  var neg = num < 0;
  var units = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  if (neg) {
    num = -num;
  }
  if (num < 1) {
    return (neg ? "-" : "") + num + " B";
  }
  var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1e3)), units.length - 1);
  num = Number(num / Math.pow(1e3, exponent));
  var unit = units[exponent];
  if (num >= 10 || num % 1 === 0) {
    return (neg ? "-" : "") + num.toFixed(0) + " " + unit;
  } else {
    return (neg ? "-" : "") + num.toFixed(1) + " " + unit;
  }
}
var pretty = prettierBytes_1;
var storage_1 = storage$1;
function storage$1() {
  Object.defineProperty(window.choo, "storage", {
    get: get2,
    set: noop$8
  });
  function get2() {
    if (navigator.storage) {
      navigator.storage.estimate().then(function(estimate) {
        var value = (estimate.usage / estimate.quota).toFixed();
        clr("Max storage:", fmt(estimate.quota));
        clr("Storage used:", fmt(estimate.usage) + " (" + value + "%)");
        navigator.storage.persisted().then(function(bool) {
          var val = bool ? "enabled" : "disabled";
          clr("Persistent storage:", val);
        });
      });
      return "Calculating storage quota‚Ä¶";
    } else {
      var protocol2 = window.location.protocol;
      return /https/.test(protocol2) ? "The Storage API is unavailable in this browser. We're sorry!" : "The Storage API is unavailable. Serving this site over HTTPS might help enable it!";
    }
  }
}
function clr(msg, arg2) {
  var color2 = "#cc99cc";
  console.log("%c" + msg, "color: " + color2, arg2);
}
function fmt(num) {
  return pretty(num).replace(" ", "");
}
function noop$8() {
}
assert$m.notEqual = notEqual;
assert$m.notOk = notOk;
assert$m.equal = equal;
assert$m.ok = assert$m;
var nanoassert$1 = assert$m;
function equal(a2, b, m2) {
  assert$m(a2 == b, m2);
}
function notEqual(a2, b, m2) {
  assert$m(a2 != b, m2);
}
function notOk(t, m2) {
  assert$m(!t, m2);
}
function assert$m(t, m2) {
  if (!t)
    throw new Error(m2 || "AssertionError");
}
var assert$l = nanoassert$1;
var hasWindow = typeof window !== "undefined";
function createScheduler() {
  var scheduler2;
  if (hasWindow) {
    if (!window._nanoScheduler)
      window._nanoScheduler = new NanoScheduler(true);
    scheduler2 = window._nanoScheduler;
  } else {
    scheduler2 = new NanoScheduler();
  }
  return scheduler2;
}
function NanoScheduler(hasWindow2) {
  this.hasWindow = hasWindow2;
  this.hasIdle = this.hasWindow && window.requestIdleCallback;
  this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout;
  this.scheduled = false;
  this.queue = [];
}
NanoScheduler.prototype.push = function(cb) {
  assert$l.equal(typeof cb, "function", "nanoscheduler.push: cb should be type function");
  this.queue.push(cb);
  this.schedule();
};
NanoScheduler.prototype.schedule = function() {
  if (this.scheduled)
    return;
  this.scheduled = true;
  var self2 = this;
  this.method(function(idleDeadline) {
    var cb;
    while (self2.queue.length && idleDeadline.timeRemaining() > 0) {
      cb = self2.queue.shift();
      cb(idleDeadline);
    }
    self2.scheduled = false;
    if (self2.queue.length)
      self2.schedule();
  });
};
NanoScheduler.prototype.setTimeout = function(cb) {
  setTimeout(cb, 0, {
    timeRemaining: function() {
      return 1;
    }
  });
};
var nanoscheduler = createScheduler;
var assert$k = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i2 = 0; i2 < 10; i2++) {
      test2["_" + String.fromCharCode(i2)] = i2;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign$1 = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty$1.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i2 = 0; i2 < symbols.length; i2++) {
        if (propIsEnumerable.call(from, symbols[i2])) {
          to[symbols[i2]] = from[symbols[i2]];
        }
      }
    }
  }
  return to;
};
var util$1 = {};
var isBufferBrowser = function isBuffer2(arg2) {
  return arg2 && typeof arg2 === "object" && typeof arg2.copy === "function" && typeof arg2.fill === "function" && typeof arg2.readUInt8 === "function";
};
var inherits_browser$1 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits_browserExports$1 = inherits_browser$1.exports;
(function(exports2) {
  var formatRegExp = /%[sdj%]/g;
  exports2.format = function(f) {
    if (!isString2(f)) {
      var objects = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        objects.push(inspect2(arguments[i2]));
      }
      return objects.join(" ");
    }
    var i2 = 1;
    var args = arguments;
    var len2 = args.length;
    var str = String(f).replace(formatRegExp, function(x3) {
      if (x3 === "%%")
        return "%";
      if (i2 >= len2)
        return x3;
      switch (x3) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_23) {
            return "[Circular]";
          }
        default:
          return x3;
      }
    });
    for (var x2 = args[i2]; i2 < len2; x2 = args[++i2]) {
      if (isNull(x2) || !isObject2(x2)) {
        str += " " + x2;
      } else {
        str += " " + inspect2(x2);
      }
    }
    return str;
  };
  exports2.deprecate = function(fn, msg) {
    if (isUndefined2(commonjsGlobal.process)) {
      return function() {
        return exports2.deprecate(fn, msg).apply(this, arguments);
      };
    }
    if (process.noDeprecation === true) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  };
  var debugs = {};
  var debugEnviron;
  exports2.debuglog = function(set) {
    if (isUndefined2(debugEnviron))
      debugEnviron = {}.NODE_DEBUG || "";
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
        var pid = process.pid;
        debugs[set] = function() {
          var msg = exports2.format.apply(exports2, arguments);
          console.error("%s %d: %s", set, pid, msg);
        };
      } else {
        debugs[set] = function() {
        };
      }
    }
    return debugs[set];
  };
  function inspect2(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean2(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      exports2._extend(ctx, opts);
    }
    if (isUndefined2(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined2(ctx.depth))
      ctx.depth = 2;
    if (isUndefined2(ctx.colors))
      ctx.colors = false;
    if (isUndefined2(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports2.inspect = inspect2;
  inspect2.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect2.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
  };
  function stylizeWithColor(str, styleType) {
    var style2 = inspect2.styles[styleType];
    if (style2) {
      return "\x1B[" + inspect2.colors[style2][0] + "m" + str + "\x1B[" + inspect2.colors[style2][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString2(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys3 = Object.keys(value);
    var visibleKeys = arrayToHash(keys3);
    if (ctx.showHidden) {
      keys3 = Object.getOwnPropertyNames(value);
    }
    if (isError2(value) && (keys3.indexOf("message") >= 0 || keys3.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys3.length === 0) {
      if (isFunction2(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp3(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate2(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError2(value)) {
        return formatError(value);
      }
    }
    var base = "", array = false, braces = ["{", "}"];
    if (isArray2(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction2(value)) {
      var n = value.name ? ": " + value.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp3(value)) {
      base = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate2(value)) {
      base = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError2(value)) {
      base = " " + formatError(value);
    }
    if (keys3.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp3(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output3;
    if (array) {
      output3 = formatArray(ctx, value, recurseTimes, visibleKeys, keys3);
    } else {
      output3 = keys3.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output3, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined2(value))
      return ctx.stylize("undefined", "undefined");
    if (isString2(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber2(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean2(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys3) {
    var output3 = [];
    for (var i2 = 0, l = value.length; i2 < l; ++i2) {
      if (hasOwnProperty2(value, String(i2))) {
        output3.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i2),
          true
        ));
      } else {
        output3.push("");
      }
    }
    keys3.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output3.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          true
        ));
      }
    });
    return output3;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty2(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined2(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str;
  }
  function reduceToSingleString(output3, base, braces) {
    var length2 = output3.reduce(function(prev2, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev2 + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length2 > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output3.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output3.join(", ") + " " + braces[1];
  }
  function isArray2(ar) {
    return Array.isArray(ar);
  }
  exports2.isArray = isArray2;
  function isBoolean2(arg2) {
    return typeof arg2 === "boolean";
  }
  exports2.isBoolean = isBoolean2;
  function isNull(arg2) {
    return arg2 === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg2) {
    return arg2 == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg2) {
    return typeof arg2 === "number";
  }
  exports2.isNumber = isNumber2;
  function isString2(arg2) {
    return typeof arg2 === "string";
  }
  exports2.isString = isString2;
  function isSymbol2(arg2) {
    return typeof arg2 === "symbol";
  }
  exports2.isSymbol = isSymbol2;
  function isUndefined2(arg2) {
    return arg2 === void 0;
  }
  exports2.isUndefined = isUndefined2;
  function isRegExp3(re2) {
    return isObject2(re2) && objectToString2(re2) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp3;
  function isObject2(arg2) {
    return typeof arg2 === "object" && arg2 !== null;
  }
  exports2.isObject = isObject2;
  function isDate2(d2) {
    return isObject2(d2) && objectToString2(d2) === "[object Date]";
  }
  exports2.isDate = isDate2;
  function isError2(e) {
    return isObject2(e) && (objectToString2(e) === "[object Error]" || e instanceof Error);
  }
  exports2.isError = isError2;
  function isFunction2(arg2) {
    return typeof arg2 === "function";
  }
  exports2.isFunction = isFunction2;
  function isPrimitive(arg2) {
    return arg2 === null || typeof arg2 === "boolean" || typeof arg2 === "number" || typeof arg2 === "string" || typeof arg2 === "symbol" || // ES6 symbol
    typeof arg2 === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = isBufferBrowser;
  function objectToString2(o) {
    return Object.prototype.toString.call(o);
  }
  function pad2(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  }
  var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function timestamp() {
    var d2 = /* @__PURE__ */ new Date();
    var time = [
      pad2(d2.getHours()),
      pad2(d2.getMinutes()),
      pad2(d2.getSeconds())
    ].join(":");
    return [d2.getDate(), months[d2.getMonth()], time].join(" ");
  }
  exports2.log = function() {
    console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
  };
  exports2.inherits = inherits_browserExports$1;
  exports2._extend = function(origin, add) {
    if (!add || !isObject2(add))
      return origin;
    var keys3 = Object.keys(add);
    var i2 = keys3.length;
    while (i2--) {
      origin[keys3[i2]] = add[keys3[i2]];
    }
    return origin;
  };
  function hasOwnProperty2(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
})(util$1);
var objectAssign = objectAssign$1;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a2, b) {
  if (a2 === b) {
    return 0;
  }
  var x2 = a2.length;
  var y2 = b.length;
  for (var i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
    if (a2[i2] !== b[i2]) {
      x2 = a2[i2];
      y2 = b[i2];
      break;
    }
  }
  if (x2 < y2) {
    return -1;
  }
  if (y2 < x2) {
    return 1;
  }
  return 0;
}
function isBuffer$2(b) {
  if (commonjsGlobal.Buffer && typeof commonjsGlobal.Buffer.isBuffer === "function") {
    return commonjsGlobal.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}
var util = util$1;
var hasOwn$4 = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = function() {
  return function foo() {
  }.name === "foo";
}();
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView$1(arrbuf) {
  if (isBuffer$2(arrbuf)) {
    return false;
  }
  if (typeof commonjsGlobal.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
var assert$j = assert$k.exports = ok;
var regex = /\s*function\s+([^\(\s]*)\s*/;
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert$j.AssertionError = function AssertionError2(options2) {
  this.name = "AssertionError";
  this.actual = options2.actual;
  this.expected = options2.expected;
  this.operator = options2.operator;
  if (options2.message) {
    this.message = options2.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options2.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err = new Error();
    if (err.stack) {
      var out = err.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
};
util.inherits(assert$j.AssertionError, Error);
function truncate(s2, n) {
  if (typeof s2 === "string") {
    return s2.length < n ? s2 : s2.slice(0, n);
  } else {
    return s2;
  }
}
function inspect$1(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage(self2) {
  return truncate(inspect$1(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect$1(self2.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert$j.AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
assert$j.fail = fail;
function ok(value, message) {
  if (!value)
    fail(value, true, message, "==", assert$j.ok);
}
assert$j.ok = ok;
assert$j.equal = function equal2(actual, expected, message) {
  if (actual != expected)
    fail(actual, expected, message, "==", assert$j.equal);
};
assert$j.notEqual = function notEqual2(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", assert$j.notEqual);
  }
};
assert$j.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", assert$j.deepEqual);
  }
};
assert$j.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", assert$j.deepStrictEqual);
  }
};
function _deepEqual(actual, expected, strict2, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$2(actual) && isBuffer$2(expected)) {
    return compare(actual, expected) === 0;
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict2 ? actual === expected : actual == expected;
  } else if (isView$1(actual) && isView$1(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$2(actual) !== isBuffer$2(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict2, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a2, b, strict2, actualVisitedObjects) {
  if (a2 === null || a2 === void 0 || b === null || b === void 0)
    return false;
  if (util.isPrimitive(a2) || util.isPrimitive(b))
    return a2 === b;
  if (strict2 && Object.getPrototypeOf(a2) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a2);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a2 = pSlice.call(a2);
    b = pSlice.call(b);
    return _deepEqual(a2, b, strict2);
  }
  var ka = objectKeys(a2);
  var kb = objectKeys(b);
  var key, i2;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    if (ka[i2] !== kb[i2])
      return false;
  }
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    key = ka[i2];
    if (!_deepEqual(a2[key], b[key], strict2, actualVisitedObjects))
      return false;
  }
  return true;
}
assert$j.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", assert$j.notDeepEqual);
  }
};
assert$j.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
assert$j.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", assert$j.strictEqual);
  }
};
assert$j.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", assert$j.notStrictEqual);
  }
};
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error2;
  try {
    block();
  } catch (e) {
    error2 = e;
  }
  return error2;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
assert$j.throws = function(block, error2, message) {
  _throws(true, block, error2, message);
};
assert$j.doesNotThrow = function(block, error2, message) {
  _throws(false, block, error2, message);
};
assert$j.ifError = function(err) {
  if (err)
    throw err;
};
function strict(value, message) {
  if (!value)
    fail(value, true, message, "==", strict);
}
assert$j.strict = objectAssign(strict, assert$j, {
  equal: assert$j.strictEqual,
  deepEqual: assert$j.deepStrictEqual,
  notEqual: assert$j.notStrictEqual,
  notDeepEqual: assert$j.notDeepStrictEqual
});
assert$j.strict.strict = assert$j.strict;
var objectKeys = Object.keys || function(obj) {
  var keys3 = [];
  for (var key in obj) {
    if (hasOwn$4.call(obj, key))
      keys3.push(key);
  }
  return keys3;
};
var assertExports = assert$k.exports;
var assert$i = assertExports;
var emojis = {
  trace: "üîç",
  debug: "üêõ",
  info: "‚ú®",
  warn: "‚ö†Ô∏è",
  error: "üö®",
  fatal: "üíÄ"
};
var levels = {
  trace: 10,
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  fatal: 60
};
var defaultColors = {
  foreground: "#d3c0c8",
  background: "#2d2d2d",
  black: "#2d2d2d",
  red: "#f2777a",
  green: "#99cc99",
  yellow: "#ffcc66",
  blue: "#6699cc",
  magenta: "#cc99cc",
  cyan: "#66cccc",
  white: "#d3d0c8",
  brightBlack: "#747369"
};
var nanologger$3 = Nanologger;
function Nanologger(name, opts) {
  opts = opts || {};
  if (!(this instanceof Nanologger))
    return new Nanologger(name, opts);
  assert$i.equal(typeof opts, "object", "nanologger: opts should be type object");
  this._name = name || "";
  this._colors = Object.assign({}, defaultColors, opts.colors || {});
  try {
    this.logLevel = window.localStorage.getItem("logLevel") || "info";
  } catch (e) {
    this.logLevel = "info";
  }
  this._logLevel = levels[this.logLevel];
}
Nanologger.prototype.trace = function() {
  var args = ["trace"];
  for (var i2 = 0, len2 = arguments.length; i2 < len2; i2++)
    args.push(arguments[i2]);
  this._print.apply(this, args);
};
Nanologger.prototype.debug = function() {
  var args = ["debug"];
  for (var i2 = 0, len2 = arguments.length; i2 < len2; i2++)
    args.push(arguments[i2]);
  this._print.apply(this, args);
};
Nanologger.prototype.info = function() {
  var args = ["info"];
  for (var i2 = 0, len2 = arguments.length; i2 < len2; i2++)
    args.push(arguments[i2]);
  this._print.apply(this, args);
};
Nanologger.prototype.warn = function() {
  var args = ["warn"];
  for (var i2 = 0, len2 = arguments.length; i2 < len2; i2++)
    args.push(arguments[i2]);
  this._print.apply(this, args);
};
Nanologger.prototype.error = function() {
  var args = ["error"];
  for (var i2 = 0, len2 = arguments.length; i2 < len2; i2++)
    args.push(arguments[i2]);
  this._print.apply(this, args);
};
Nanologger.prototype.fatal = function() {
  var args = ["fatal"];
  for (var i2 = 0, len2 = arguments.length; i2 < len2; i2++)
    args.push(arguments[i2]);
  this._print.apply(this, args);
};
Nanologger.prototype._print = function(level) {
  if (levels[level] < this._logLevel)
    return;
  var time = getTimeStamp();
  var emoji = emojis[level];
  var name = this._name || "unknown";
  var msgColor = level === "error" || level.fatal ? this._colors.red : level === "warn" ? this._colors.yellow : this._colors.green;
  var objs = [];
  var args = [null];
  var msg = "%c%s " + emoji + " %c%s";
  args.push(color(this._colors.brightBlack), time);
  args.push(color(this._colors.magenta), name);
  for (var i2 = 1, len2 = arguments.length; i2 < len2; i2++) {
    var arg2 = arguments[i2];
    if (typeof arg2 === "string") {
      if (i2 === 1) {
        msg += " %c%s";
        args.push(color(msgColor));
        args.push(arg2);
      } else if (/ms$/.test(arg2)) {
        msg += " %c%s";
        args.push(color(this._colors.brightBlack));
        args.push(arg2);
      } else {
        msg += " %c%s";
        args.push(color(this._colors.white));
        args.push(arg2);
      }
    } else if (typeof arg2 === "number") {
      msg += " %c%d";
      args.push(color(this._colors.magenta));
      args.push(arg2);
    } else {
      objs.push(arg2);
    }
  }
  args[0] = msg;
  objs.forEach(function(obj) {
    args.push(obj);
  });
  Function.prototype.apply.apply(console.log, [console, args]);
};
function color(color2) {
  return "color: " + color2 + ";";
}
function getTimeStamp() {
  var date = /* @__PURE__ */ new Date();
  var hours = pad(date.getHours().toString());
  var minutes = pad(date.getMinutes().toString());
  var seconds = pad(date.getSeconds().toString());
  return hours + ":" + minutes + ":" + seconds;
}
function pad(str) {
  return str.length !== 2 ? 0 + str : str;
}
var scheduler$4 = nanoscheduler();
var assert$h = nanoassert$1;
var entryTypes = [
  "frame",
  "measure",
  "navigation",
  "resource",
  "longtask"
];
var browser$a = onPerformance$2;
function onPerformance$2(cb) {
  assert$h.equal(typeof cb, "function", "on-performance: cb should be type function");
  var PerformanceObserver = typeof window !== "undefined" && window.PerformanceObserver;
  if (!PerformanceObserver)
    return;
  if (window._onperformance) {
    window._onperformance.push(cb);
    return stop;
  }
  window._onperformance = [cb];
  var observer2 = new PerformanceObserver(parseEntries);
  setTimeout(function() {
    parseEntries(window.performance);
    observer2.observe({ entryTypes });
  }, 0);
  return stop;
  function stop() {
    window._onperformance.splice(window._onperformance.indexOf(cb), 1);
  }
  function parseEntries(list2) {
    list2.getEntries().forEach(function(entry) {
      scheduler$4.push(function() {
        clear(entry);
        window._onperformance.forEach(function(cb2) {
          cb2(entry);
        });
      });
    });
  }
  function clear(entry) {
    var type = entry.entryType;
    if (type === "measure")
      window.performance.clearMeasures(entry.name);
    else if (type === "resource")
      window.performance.clearResourceTimings();
  }
}
var onPerformance$1 = browser$a;
var scheduler$3 = nanoscheduler();
var assert$g = assertExports;
var chooHooks = ChooHooks;
function ChooHooks(emitter) {
  if (!(this instanceof ChooHooks))
    return new ChooHooks(emitter);
  assert$g.equal(typeof emitter, "object");
  this.hasWindow = typeof window !== "undefined";
  this.hasIdleCallback = this.hasWindow && window.requestIdleCallback;
  this.hasPerformance = this.hasWindow && window.performance && window.performance.getEntriesByName;
  this.emitter = emitter;
  this.listeners = {};
  this.buffer = {
    render: {},
    events: {}
  };
}
ChooHooks.prototype.on = function(name, handler) {
  this.listeners[name] = handler;
};
ChooHooks.prototype.start = function() {
  var self2 = this;
  if (this.hasPerformance) {
    window.performance.onresourcetimingbufferfull = function() {
      var listener = self2.listeners["resource-timing-buffer-full"];
      if (listener)
        listener();
    };
  }
  onPerformance$1(function(timing) {
    if (!timing)
      return;
    if (timing.entryType !== "measure")
      return;
    var eventName = timing.name;
    if (/choo\.morph/.test(eventName)) {
      self2.buffer.render.morph = timing;
    } else if (/choo\.route/.test(eventName)) {
      self2.buffer.render.route = timing;
    } else if (/choo\.render/.test(eventName)) {
      self2.buffer.render.render = timing;
    } else if (/choo\.emit/.test(eventName) && !/log:/.test(eventName)) {
      var eventListener = self2.listeners["event"];
      if (eventListener) {
        var timingName = eventName.match(/choo\.emit\('(.*)'\)/)[1];
        if (timingName === "render" || timingName === "DOMContentLoaded")
          return;
        var traceId = eventName.match(/\[(\d+)\]/)[1];
        var data2 = self2.buffer.events[traceId];
        self2.buffer.events[traceId] = null;
        eventListener(timingName, data2, timing);
      }
    }
    var rBuf = self2.buffer.render;
    if (rBuf.render && rBuf.route && rBuf.morph) {
      var renderListener = self2.listeners["render"];
      if (!renderListener)
        return;
      var timings = {};
      while (self2.buffer.render.length) {
        var _timing = self2.buffer.render.pop();
        var name = _timing.name;
        if (/choo\.render/.test(name))
          timings.render = _timing;
        else if (/choo\.morph/.test(name))
          timings.morph = _timing;
        else
          timings.route = _timing;
      }
      rBuf.render = rBuf.route = rBuf.morph = void 0;
      renderListener(timings);
    }
  });
  this.emitter.on("*", function(eventName, data2, uuid) {
    var logLevel = /^log:(\w{4,5})/.exec(eventName);
    if (!self2.hasPerformance && eventName === "render") {
      var renderListener = self2.listeners["render"];
      if (renderListener)
        renderListener();
    } else if (eventName === "DOMContentLoaded") {
      self2._emitLoaded();
    } else if (logLevel) {
      logLevel = logLevel[1];
      var logListener = self2.listeners["log:" + logLevel];
      if (logListener) {
        logListener.apply(null, Array.prototype.slice.call(arguments, 0, arguments.length - 1));
      }
    } else if (!self2.emitter.listeners(eventName).length) {
      var unhandledListener = self2.listeners["unhandled"];
      if (unhandledListener)
        unhandledListener(eventName, data2);
    } else if (eventName !== "render") {
      if (self2.hasPerformance)
        self2.buffer.events[uuid] = data2;
    }
  });
};
ChooHooks.prototype._emitLoaded = function() {
  var self2 = this;
  scheduler$3.push(function clear() {
    var listener = self2.listeners["DOMContentLoaded"];
    var timing = self2.hasWindow && window.performance && window.performance.timing;
    if (listener && timing) {
      listener({
        interactive: timing.domInteractive - timing.navigationStart,
        loaded: timing.domContentLoadedEventEnd - timing.navigationStart
      });
    }
  });
};
var scheduler$2 = nanoscheduler();
var nanologger$2 = nanologger$3;
var Hooks = chooHooks;
var logger_1 = logger$1;
function logger$1(state2, emitter, opts) {
  var initialRender = true;
  var hooks = Hooks(emitter);
  var log3 = nanologger$2("choo");
  hooks.on("log:debug", logger2("debug"));
  hooks.on("log:info", logger2("info"));
  hooks.on("log:warn", logger2("warn"));
  hooks.on("log:error", logger2("error"));
  hooks.on("log:fatal", logger2("fatal"));
  hooks.on("event", function(eventName, data2, timing) {
    if (opts.filter && !opts.filter(eventName, data2, timing))
      return;
    if (timing) {
      var duration = timing.duration.toFixed();
      var level = duration < 50 ? "info" : "warn";
      if (data2 !== void 0)
        logger2(level)(eventName, data2, duration + "ms");
      else
        logger2(level)(eventName, duration + "ms");
    } else {
      if (data2 !== void 0)
        logger2("info")(eventName, data2);
      else
        logger2("info")(eventName);
    }
  });
  hooks.on("unhandled", function(eventName, data2) {
    logger2("error")("No listeners for " + eventName);
  });
  hooks.on("DOMContentLoaded", function(timing) {
    if (!timing)
      return logger2("info")("DOMContentLoaded");
    var level = timing.interactive < 1e3 ? "info" : "warn";
    logger2(level)("DOMContentLoaded", timing.interactive + "ms to interactive");
  });
  hooks.on("render", function(timings) {
    if (!timings || !timings.render)
      return logger2("info")("render");
    var duration = timings.render.duration.toFixed();
    var msg = "render";
    if (initialRender) {
      initialRender = false;
      msg = "initial " + msg;
    }
    var fps = Math.min((600 / duration).toFixed(), 60);
    if (fps === 60) {
      logger2("info")(msg, fps + "fps", duration + "ms");
    } else {
      var times = {
        render: timings.render.duration.toFixed() + "ms"
      };
      if (timings.morph)
        times.morph = timings.morph.duration.toFixed() + "ms";
      logger2("warn")(msg, fps + "fps", duration + "ms", times);
    }
  });
  hooks.on("resource-timing-buffer-full", function() {
    logger2("error")("The browser's Resource Resource timing buffer is full. Cannot store any more timing information");
  });
  hooks.start();
  function logger2(level) {
    return function() {
      var args = [];
      for (var i2 = 0, len2 = arguments.length; i2 < len2; i2++) {
        args.push(arguments[i2]);
      }
      scheduler$2.push(function() {
        log3[level].apply(log3, args);
      });
    };
  }
}
var assert$f = assertExports;
var objectChangeCallsite_1 = objectChangeCallsite;
function objectChangeCallsite(target, callback2) {
  assert$f.equal(typeof target, "object", "object-change-callsite: target should be type object");
  assert$f.equal(typeof callback2, "function", "object-change-callsite: callback should be type function");
  return new Proxy(target, {
    set: function(obj, prop, value) {
      var err = new Error();
      var trace = strip(err.stack);
      callback2(prop, value, trace);
      obj[prop] = value;
      return true;
    },
    deleteProperty: function(target2, prop) {
      var err = new Error();
      var trace = strip(err.stack);
      callback2(prop, void 0, trace);
      if (prop in target2) {
        delete target2[prop];
        return true;
      }
      return false;
    }
  });
}
function strip(str) {
  var arr2 = str.split("\n");
  arr2 = arr2.length > 2 ? arr2.slice(2) : arr2;
  arr2[0] = arr2[0].replace(/^ {4}at /, "");
  return "\n" + arr2.join("\n");
}
var onChange = objectChangeCallsite_1;
var nanologger$1 = nanologger$3;
var assert$e = assertExports;
var enabledMessage = "Debugging enabled. To disable run: `choo.debug = false`";
var disabledMessage = "Debugging disabled. We hope it was helpful! üôå";
var debug_1 = debug$b;
function debug$b(state2, emitter, app2, localEmitter) {
  var log3 = nanologger$1("choo-devtools");
  var enabled = window.localStorage.logLevel === "debug";
  if (enabled)
    log3.info(enabledMessage);
  state2 = onChange(state2, function(attr, value, callsite) {
    if (!enabled)
      return;
    callsite = callsite.split("\n")[1].replace(/^ +/, "");
    log3.info("state." + attr, value, "\n" + callsite);
  });
  app2.state = state2;
  Object.defineProperty(window.choo, "debug", {
    get: function() {
      window.localStorage.logLevel = "debug";
      localEmitter.emit("debug", true);
      enabled = true;
      return enabledMessage;
    },
    set: function(bool) {
      assert$e.equal(typeof bool, "boolean", "choo-devtools.debug: bool should be type boolean");
      window.localStorage.logLevel = bool ? "debug" : "info";
      enabled = bool;
      localEmitter.emit("debug", enabled);
      if (enabled)
        log3.info(enabledMessage);
      else
        log3.info(disabledMessage);
    }
  });
}
var fastSafeStringify$1 = stringify$3;
stringify$3.default = stringify$3;
stringify$3.stable = deterministicStringify;
stringify$3.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = "[Circular]";
var arr$1 = [];
var replacerStack = [];
function defaultOptions$1() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function stringify$3(obj, replacer, spacer, options2) {
  if (typeof options2 === "undefined") {
    options2 = defaultOptions$1();
  }
  decirc(obj, "", 0, [], void 0, 0, options2);
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer);
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
    }
  } catch (_23) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr$1.length !== 0) {
      var part = arr$1.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function setReplace(replace2, val, k, parent2) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent2, k);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent2, k, { value: replace2 });
      arr$1.push([parent2, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace2]);
    }
  } else {
    parent2[k] = replace2;
    arr$1.push([parent2, k, val]);
  }
}
function decirc(val, k, edgeIndex, stack, parent2, depth, options2) {
  depth += 1;
  var i2;
  if (typeof val === "object" && val !== null) {
    for (i2 = 0; i2 < stack.length; i2++) {
      if (stack[i2] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent2);
        return;
      }
    }
    if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent2);
      return;
    }
    if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent2);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i2 = 0; i2 < val.length; i2++) {
        decirc(val[i2], i2, i2, stack, val, depth, options2);
      }
    } else {
      var keys3 = Object.keys(val);
      for (i2 = 0; i2 < keys3.length; i2++) {
        var key = keys3[i2];
        decirc(val[key], key, i2, stack, val, depth, options2);
      }
    }
    stack.pop();
  }
}
function compareFunction(a2, b) {
  if (a2 < b) {
    return -1;
  }
  if (a2 > b) {
    return 1;
  }
  return 0;
}
function deterministicStringify(obj, replacer, spacer, options2) {
  if (typeof options2 === "undefined") {
    options2 = defaultOptions$1();
  }
  var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options2) || obj;
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
    }
  } catch (_23) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr$1.length !== 0) {
      var part = arr$1.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function deterministicDecirc(val, k, edgeIndex, stack, parent2, depth, options2) {
  depth += 1;
  var i2;
  if (typeof val === "object" && val !== null) {
    for (i2 = 0; i2 < stack.length; i2++) {
      if (stack[i2] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent2);
        return;
      }
    }
    try {
      if (typeof val.toJSON === "function") {
        return;
      }
    } catch (_23) {
      return;
    }
    if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent2);
      return;
    }
    if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent2);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i2 = 0; i2 < val.length; i2++) {
        deterministicDecirc(val[i2], i2, i2, stack, val, depth, options2);
      }
    } else {
      var tmp = {};
      var keys3 = Object.keys(val).sort(compareFunction);
      for (i2 = 0; i2 < keys3.length; i2++) {
        var key = keys3[i2];
        deterministicDecirc(val[key], key, i2, stack, val, depth, options2);
        tmp[key] = val[key];
      }
      if (typeof parent2 !== "undefined") {
        arr$1.push([parent2, k, val]);
        parent2[k] = tmp;
      } else {
        return tmp;
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
    return v;
  };
  return function(key, val) {
    if (replacerStack.length > 0) {
      for (var i2 = 0; i2 < replacerStack.length; i2++) {
        var part = replacerStack[i2];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i2, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}
/*! clipboard-copy. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var clipboardCopy_1 = clipboardCopy;
function clipboardCopy(text) {
  if (navigator.clipboard) {
    return navigator.clipboard.writeText(text).catch(function(err) {
      throw err !== void 0 ? err : new DOMException("The request is not allowed", "NotAllowedError");
    });
  }
  var span = document.createElement("span");
  span.textContent = text;
  span.style.whiteSpace = "pre";
  span.style.webkitUserSelect = "auto";
  span.style.userSelect = "all";
  document.body.appendChild(span);
  var selection = window.getSelection();
  var range = window.document.createRange();
  selection.removeAllRanges();
  range.selectNode(span);
  selection.addRange(range);
  var success = false;
  try {
    success = window.document.execCommand("copy");
  } catch (err) {
    console.log("error", err);
  }
  selection.removeAllRanges();
  window.document.body.removeChild(span);
  return success ? Promise.resolve() : Promise.reject(new DOMException("The request is not allowed", "NotAllowedError"));
}
var fastSafeStringify = fastSafeStringify$1;
var copy$3 = clipboardCopy_1;
function tryStringify(obj) {
  try {
    return JSON.stringify(obj);
  } catch (e) {
  }
}
function stateCopy$1(obj) {
  var str = tryStringify(obj) || fastSafeStringify(obj);
  copy$3(str);
}
var stateCopy_1 = stateCopy$1;
var plucker_1 = plucker;
function plucker(path2, object) {
  return arguments.length >= 2 ? pluck$1(path2)(object) : pluck$1(path2);
}
function pluck$1(path2) {
  path2 = typeof path2 === "string" ? String(path2).trim().split(".") : path2;
  if (path2.length < 2) {
    path2 = path2[0];
    return pluckSingle;
  } else {
    var l = path2.length;
    return pluckPath;
  }
  function pluckSingle(object) {
    return object[path2];
  }
  function pluckPath(object) {
    for (var i2 = 0; i2 < l; i2++) {
      if (typeof object === "undefined")
        break;
      object = object[path2[i2]];
    }
    return object;
  }
}
var stateCopy = stateCopy_1;
var pluck = plucker_1;
var copy_1 = copy$2;
function copy$2(state2) {
  var isStateString = state2 && typeof state2 === "string";
  var isChooPath = isStateString && arguments.length === 1 && state2.indexOf("state.") === 0;
  if (!state2 || typeof state2 === "function")
    state2 = window.choo.state;
  if (isChooPath)
    [].push.call(arguments, { state: window.choo.state });
  stateCopy(isStateString ? pluck.apply(this, arguments) : state2);
}
var help_1 = help$1;
function help$1() {
  Object.defineProperty(window.choo, "help", {
    get: get2,
    set: noop$7
  });
  function get2() {
    setTimeout(function() {
      print("copy", "Serialize the current state to the clipboard.");
      print("debug", "Enable Choo debug mode.");
      print("emit", "Emit an event in the Choo emitter.");
      print("help", "Print usage information.");
      print("log", "Print the last 150 events emitted.");
      print("on", "Listen for an event in the Choo emitter.");
      print("once", "Listen for an event once in the Choo emitter.");
      print("perf", "Print out performance metrics");
      print("state", "Print the Choo state object.");
      print("storage", "Print browser storage information.");
    }, 0);
    return "Choo command overview";
  }
}
function print(cmd, desc) {
  var color2 = "#cc99cc";
  console.log("  %cchoo." + cmd, "color: " + color2, "‚Äî " + desc);
}
function noop$7() {
}
var onPerformance = browser$a;
var BAR = "‚ñà";
var perf_1 = perf$2;
function perf$2(state2, emitter, app2, localEmitter) {
  var stats = {};
  window.choo.perf = {};
  var all = new Perf(stats, "all");
  Object.defineProperty(window.choo.perf, "all", {
    get: all.get.bind(all),
    set: noop$6
  });
  var core = new Perf(stats, "core", function(name) {
    return /^choo/.test(name);
  });
  Object.defineProperty(window.choo.perf, "core", {
    get: core.get.bind(core),
    set: noop$6
  });
  var components = new Perf(stats, "components", function(name) {
    return !/^choo/.test(name) && !/^bankai/.test(name);
  });
  Object.defineProperty(window.choo.perf, "components", {
    get: components.get.bind(components),
    set: noop$6
  });
  var events2 = new Perf(stats, "events", function(name) {
    return /^choo\.emit/.test(name);
  }, function(name) {
    return name.replace(/^choo\.emit\('/, "").replace(/'\)$/, "");
  });
  Object.defineProperty(window.choo.perf, "events", {
    get: events2.get.bind(events2),
    set: noop$6
  });
  onPerformance(function(entry) {
    if (entry.entryType !== "measure")
      return;
    var name = entry.name.replace(/ .*$/, "");
    if (!stats[name]) {
      stats[name] = {
        name,
        count: 0,
        entries: []
      };
    }
    var stat = stats[name];
    stat.count += 1;
    stat.entries.push(entry.duration);
  });
}
function Perf(stats, name, filter, rename) {
  this.stats = stats;
  this.name = name;
  this.filter = filter || function() {
    return true;
  };
  this.rename = rename || function(name2) {
    return name2;
  };
}
Perf.prototype.get = function() {
  var filtered = Object.keys(this.stats).filter(this.filter);
  var self2 = this;
  var maxTime = 0;
  var maxMedian = 0;
  var fmt2 = filtered.map(function(key) {
    var stat = self2.stats[key];
    var totalTime = Number(stat.entries.reduce(function(time, entry) {
      return time + entry;
    }, 0).toFixed(2));
    if (totalTime > maxTime)
      maxTime = totalTime;
    var median = getMedian(stat.entries);
    if (median > maxMedian)
      maxMedian = median;
    var name = self2.rename(stat.name);
    return new PerfEntry(name, totalTime, median, stat.count);
  });
  var barLength = 10;
  fmt2.forEach(function(entry) {
    var totalTime = entry["Total Time (ms)"];
    var median = entry["Median (ms)"];
    entry[" "] = createBar(totalTime / maxTime * 100 / barLength);
    entry["  "] = createBar(median / maxMedian * 100 / barLength);
  });
  function createBar(len2) {
    var str = "";
    for (var i2 = 0, max = Math.round(len2); i2 < max; i2++) {
      str += BAR;
    }
    return str;
  }
  var res = fmt2.sort(function(a2, b) {
    return b["Total Time (ms)"] - a2["Total Time (ms)"];
  });
  console.table(res);
  return "Showing performance events for '" + this.name + "'";
};
function PerfEntry(name, totalTime, median, count) {
  this.Name = name;
  this["Total Time (ms)"] = totalTime;
  this[" "] = 0;
  this["Median (ms)"] = median;
  this["  "] = 0;
  this["Total Count"] = count;
}
function getMedian(args) {
  if (!args.length)
    return 0;
  var numbers = args.slice(0).sort(function(a2, b) {
    return a2 - b;
  });
  var middle = Math.floor(numbers.length / 2);
  var isEven = numbers.length % 2 === 0;
  var res = isEven ? (numbers[middle] + numbers[middle - 1]) / 2 : numbers[middle];
  return Number(res.toFixed(2));
}
function noop$6() {
}
function removeItems$1(arr2, startIdx, removeCount) {
  var i2, length2 = arr2.length;
  if (startIdx >= length2 || removeCount <= 0 || startIdx < 0) {
    return;
  }
  removeCount = startIdx + removeCount > length2 ? length2 - startIdx : removeCount;
  var len2 = length2 - removeCount;
  for (i2 = startIdx; i2 < len2; ++i2) {
    arr2[i2] = arr2[i2 + removeCount];
  }
  arr2.length = len2;
}
const removeArrayItems_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: removeItems$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(removeArrayItems_esm);
var clone$2 = { exports: {} };
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone)
    return clone$2.exports;
  hasRequiredClone = 1;
  (function(module2) {
    var clone2 = function() {
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_23) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_23) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_23) {
        nativePromise = function() {
        };
      }
      function clone3(parent2, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent3, depth2) {
          if (parent3 === null)
            return null;
          if (depth2 === 0)
            return parent3;
          var child;
          var proto;
          if (typeof parent3 != "object") {
            return parent3;
          }
          if (_instanceof(parent3, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent3, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent3, nativePromise)) {
            child = new nativePromise(function(resolve, reject) {
              parent3.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone3.__isArray(parent3)) {
            child = [];
          } else if (clone3.__isRegExp(parent3)) {
            child = new RegExp(parent3.source, __getRegExpFlags(parent3));
            if (parent3.lastIndex)
              child.lastIndex = parent3.lastIndex;
          } else if (clone3.__isDate(parent3)) {
            child = new Date(parent3.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent3)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent3.length);
            } else {
              child = new Buffer(parent3.length);
            }
            parent3.copy(child);
            return child;
          } else if (_instanceof(parent3, Error)) {
            child = Object.create(parent3);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent3);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index2 = allParents.indexOf(parent3);
            if (index2 != -1) {
              return allChildren[index2];
            }
            allParents.push(parent3);
            allChildren.push(child);
          }
          if (_instanceof(parent3, nativeMap)) {
            parent3.forEach(function(value, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent3, nativeSet)) {
            parent3.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i2 in parent3) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i2);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i2] = _clone(parent3[i2], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent3);
            for (var i2 = 0; i2 < symbols.length; i2++) {
              var symbol = symbols[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent3, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent3[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent3);
            for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
              var propertyName = allPropertyNames[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent3, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent3[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent2, depth);
      }
      clone3.clonePrototype = function clonePrototype(parent2) {
        if (parent2 === null)
          return null;
        var c = function() {
        };
        c.prototype = parent2;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone3.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone3.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone3.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone3.__isRegExp = __isRegExp;
      function __getRegExpFlags(re2) {
        var flags = "";
        if (re2.global)
          flags += "g";
        if (re2.ignoreCase)
          flags += "i";
        if (re2.multiline)
          flags += "m";
        return flags;
      }
      clone3.__getRegExpFlags = __getRegExpFlags;
      return clone3;
    }();
    if (module2.exports) {
      module2.exports = clone2;
    }
  })(clone$2);
  return clone$2.exports;
}
var removeItems = require$$0;
var scheduler$1 = nanoscheduler();
var nanologger = nanologger$3;
var _log = nanologger("choo");
var clone$1 = requireClone();
var MAX_HISTORY_LENGTH = 150;
var log_1 = log$3;
function log$3(state2, emitter, app2, localEmitter) {
  var shouldDebug = window.localStorage.logLevel === "debug";
  var history = [];
  var i2 = 0;
  var shouldWarn = true;
  localEmitter.on("debug", function(bool) {
    shouldDebug = bool;
  });
  window.choo._history = history;
  window.choo.history = showHistory;
  Object.defineProperty(window.choo, "log", { get: showHistory, set: noop$5 });
  Object.defineProperty(window.choo, "history", { get: showHistory, set: noop$5 });
  emitter.on("*", function(name, data2) {
    i2 += 1;
    var entry = new Event2(name, data2, state2);
    history.push(entry);
    scheduler$1.push(function() {
      var length2 = history.length;
      if (length2 > MAX_HISTORY_LENGTH) {
        removeItems(history, 0, length2 - MAX_HISTORY_LENGTH);
      }
    });
  });
  function showHistory() {
    setTimeout(function() {
      console.table(history);
    }, 0);
    var events2 = i2 === 1 ? "event" : "events";
    var msg = i2 + " " + events2 + " recorded, showing the last " + MAX_HISTORY_LENGTH + ".";
    if (shouldDebug === false) {
      msg += " Enable state capture by calling `choo.debug`.";
    } else {
      msg += " Disable state capture by calling `choo.debug = false`.";
    }
    return msg;
  }
  function Event2(name, data2, state3) {
    this.name = name;
    this.data = data2 === void 0 ? "<no data>" : data2;
    this.state = shouldDebug ? tryClone(state3) : "<disabled>";
  }
  function tryClone(state3) {
    try {
      var _state = clone$1(state3);
      if (!shouldWarn)
        shouldWarn = true;
      return _state;
    } catch (ex) {
      if (shouldWarn) {
        _log.warn("Could not clone your app state. Make sure to have a serializable state so it can be cloned");
        shouldWarn = false;
      }
      return "<unserializable>";
    }
  }
}
function noop$5() {
}
var assert$d = nanoassert$1;
var getAllRoutes_1 = getAllRoutes$1;
var transform$1 = function(trie2, previous) {
  var prev2 = previous || "/";
  var routes = {};
  var nodes = trie2.nodes;
  Object.keys(nodes).forEach(function(key) {
    var path2 = (prev2 === "/" ? prev2 : prev2 + "/") + (key === "$$" ? ":" + trie2.name : key);
    var cb = nodes[key].cb;
    if (cb !== void 0) {
      routes[path2] = cb;
    }
    if (Object.keys(nodes[key].nodes).length !== 0) {
      var obj = transform$1(nodes[key], path2);
      Object.keys(obj).forEach(function(r) {
        routes[r] = obj[r];
      });
    }
  });
  return routes;
};
function getAllRoutes$1(router) {
  assert$d.equal(typeof router, "function", "wayfarer.getAllRoutes: router should be an function");
  var trie2 = router._trie;
  assert$d.equal(typeof trie2, "object", "wayfarer.getAllRoutes: trie should be an object");
  var tree = trie2.trie;
  return transform$1(tree);
}
var EventEmitter$2 = eventsExports.EventEmitter;
var storage = storage_1;
var logger = logger_1;
var debug$a = debug_1;
var copy$1 = copy_1;
var help = help_1;
var perf$1 = perf_1;
var log$2 = log_1;
var getAllRoutes = getAllRoutes_1;
var chooDevtools = expose;
function expose(opts) {
  opts = opts || {};
  store2.storeName = "choo-devtools";
  return store2;
  function store2(state2, emitter, app2) {
    var localEmitter = new EventEmitter$2();
    if (typeof window !== "undefined") {
      logger(state2, emitter, opts);
    }
    emitter.on("DOMContentLoaded", function() {
      if (typeof window === "undefined")
        return;
      window.choo = {};
      window.choo.state = state2;
      window.choo.emit = function() {
        emitter.emit.apply(emitter, arguments);
      };
      window.choo.on = function(eventName, listener) {
        emitter.on(eventName, listener);
      };
      debug$a(state2, emitter, app2, localEmitter);
      log$2(state2, emitter, app2, localEmitter);
      perf$1();
      window.choo.copy = copy$1;
      if (app2.router && app2.router.router) {
        window.choo.routes = Object.keys(getAllRoutes(app2.router.router));
      }
      storage();
      help();
    });
  }
}
const devtools = /* @__PURE__ */ getDefaultExportFromCjs(chooDevtools);
var scrollToAnchor_1 = scrollToAnchor$1;
function scrollToAnchor$1(anchor, options2) {
  if (anchor) {
    try {
      var el = document.querySelector(anchor);
      if (el)
        el.scrollIntoView(options2);
    } catch (e) {
    }
  }
}
var documentReady$1 = ready;
function ready(callback2) {
  if (typeof document === "undefined") {
    throw new Error("document-ready only runs in the browser");
  }
  var state2 = document.readyState;
  if (state2 === "complete" || state2 === "interactive") {
    return setTimeout(callback2, 0);
  }
  document.addEventListener("DOMContentLoaded", function onLoad2() {
    callback2();
  });
}
var scheduler = nanoscheduler();
var assert$c = nanoassert$1;
var perf;
nanotiming$3.disabled = true;
try {
  perf = window.performance;
  nanotiming$3.disabled = window.localStorage.DISABLE_NANOTIMING === "true" || !perf.mark;
} catch (e) {
}
var browser$9 = nanotiming$3;
function nanotiming$3(name) {
  assert$c.equal(typeof name, "string", "nanotiming: name should be type string");
  if (nanotiming$3.disabled)
    return noop$4;
  var uuid = (perf.now() * 1e4).toFixed() % Number.MAX_SAFE_INTEGER;
  var startName = "start-" + uuid + "-" + name;
  perf.mark(startName);
  function end(cb) {
    var endName = "end-" + uuid + "-" + name;
    perf.mark(endName);
    scheduler.push(function() {
      var err = null;
      try {
        var measureName = name + " [" + uuid + "]";
        perf.measure(measureName, startName, endName);
        perf.clearMarks(startName);
        perf.clearMarks(endName);
      } catch (e) {
        err = e;
      }
      if (cb)
        cb(err, name);
    });
  }
  end.uuid = uuid;
  return end;
}
function noop$4(cb) {
  if (cb) {
    scheduler.push(function() {
      cb(new Error("nanotiming: performance API unavailable"));
    });
  }
}
var assert$b = nanoassert$1;
var trie$1 = Trie;
function Trie() {
  if (!(this instanceof Trie))
    return new Trie();
  this.trie = { nodes: {} };
}
Trie.prototype.create = function(route) {
  assert$b.equal(typeof route, "string", "route should be a string");
  var routes = route.replace(/^\//, "").split("/");
  function createNode(index2, trie2) {
    var thisRoute = has$5(routes, index2) && routes[index2];
    if (thisRoute === false)
      return trie2;
    var node = null;
    if (/^:|^\*/.test(thisRoute)) {
      if (!has$5(trie2.nodes, "$$")) {
        node = { nodes: {} };
        trie2.nodes.$$ = node;
      } else {
        node = trie2.nodes.$$;
      }
      if (thisRoute[0] === "*") {
        trie2.wildcard = true;
      }
      trie2.name = thisRoute.replace(/^:|^\*/, "");
    } else if (!has$5(trie2.nodes, thisRoute)) {
      node = { nodes: {} };
      trie2.nodes[thisRoute] = node;
    } else {
      node = trie2.nodes[thisRoute];
    }
    return createNode(index2 + 1, node);
  }
  return createNode(0, this.trie);
};
Trie.prototype.match = function(route) {
  assert$b.equal(typeof route, "string", "route should be a string");
  var routes = route.replace(/^\//, "").split("/");
  var params = {};
  function search(index2, trie2) {
    if (trie2 === void 0)
      return void 0;
    var thisRoute = routes[index2];
    if (thisRoute === void 0)
      return trie2;
    if (has$5(trie2.nodes, thisRoute)) {
      return search(index2 + 1, trie2.nodes[thisRoute]);
    } else if (trie2.name) {
      try {
        params[trie2.name] = decodeURIComponent(thisRoute);
      } catch (e) {
        return search(index2, void 0);
      }
      return search(index2 + 1, trie2.nodes.$$);
    } else if (trie2.wildcard) {
      try {
        params.wildcard = decodeURIComponent(routes.slice(index2).join("/"));
      } catch (e) {
        return search(index2, void 0);
      }
      return trie2.nodes.$$;
    } else {
      return search(index2 + 1);
    }
  }
  var node = search(0, this.trie);
  if (!node)
    return void 0;
  node = Object.assign({}, node);
  node.params = params;
  return node;
};
Trie.prototype.mount = function(route, trie2) {
  assert$b.equal(typeof route, "string", "route should be a string");
  assert$b.equal(typeof trie2, "object", "trie should be a object");
  var split = route.replace(/^\//, "").split("/");
  var node = null;
  var key = null;
  if (split.length === 1) {
    key = split[0];
    node = this.create(key);
  } else {
    var head = split.join("/");
    key = split[0];
    node = this.create(head);
  }
  Object.assign(node.nodes, trie2.nodes);
  if (trie2.name)
    node.name = trie2.name;
  if (node.nodes[""]) {
    Object.keys(node.nodes[""]).forEach(function(key2) {
      if (key2 === "nodes")
        return;
      node[key2] = node.nodes[""][key2];
    });
    Object.assign(node.nodes, node.nodes[""].nodes);
    delete node.nodes[""].nodes;
  }
};
function has$5(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}
var assert$a = nanoassert$1;
var trie = trie$1;
var wayfarer$1 = Wayfarer;
function Wayfarer(dft) {
  if (!(this instanceof Wayfarer))
    return new Wayfarer(dft);
  var _default = (dft || "").replace(/^\//, "");
  var _trie = trie();
  emit2._trie = _trie;
  emit2.on = on2;
  emit2.emit = emit2;
  emit2.match = match;
  emit2._wayfarer = true;
  return emit2;
  function on2(route, cb) {
    assert$a.equal(typeof route, "string");
    assert$a.equal(typeof cb, "function");
    route = route || "/";
    if (cb._wayfarer && cb._trie) {
      _trie.mount(route, cb._trie.trie);
    } else {
      var node = _trie.create(route);
      node.cb = cb;
      node.route = route;
    }
    return emit2;
  }
  function emit2(route) {
    var matched = match(route);
    var args = new Array(arguments.length);
    args[0] = matched.params;
    for (var i2 = 1; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return matched.cb.apply(matched.cb, args);
  }
  function match(route) {
    assert$a.notEqual(route, void 0, "'route' must be defined");
    var matched = _trie.match(route);
    if (matched && matched.cb)
      return new Route(matched);
    var dft2 = _trie.match(_default);
    if (dft2 && dft2.cb)
      return new Route(dft2);
    throw new Error("route '" + route + "' did not match");
  }
  function Route(matched) {
    this.cb = matched.cb;
    this.route = matched.route;
    this.params = matched.params;
  }
}
var assert$9 = nanoassert$1;
var wayfarer = wayfarer$1;
var isLocalFile = /file:\/\//.test(
  typeof window === "object" && window.location && window.location.origin
);
var electron = "^(file://|/)(.*.html?/?)?";
var protocol = "^(http(s)?(://))?(www.)?";
var domain = "[a-zA-Z0-9-_.]+(:[0-9]{1,5})?(/{1})?";
var qs$1 = "[?].*$";
var stripElectron = new RegExp(electron);
var prefix = new RegExp(protocol + domain);
var normalize = new RegExp("#");
var suffix = new RegExp(qs$1);
var nanorouter$1 = Nanorouter;
function Nanorouter(opts) {
  if (!(this instanceof Nanorouter))
    return new Nanorouter(opts);
  opts = opts || {};
  this.router = wayfarer(opts.default || "/404");
}
Nanorouter.prototype.on = function(routename, listener) {
  assert$9.equal(typeof routename, "string");
  routename = routename.replace(/^[#/]/, "");
  this.router.on(routename, listener);
};
Nanorouter.prototype.emit = function(routename) {
  assert$9.equal(typeof routename, "string");
  routename = pathname(routename, isLocalFile);
  return this.router.emit(routename);
};
Nanorouter.prototype.match = function(routename) {
  assert$9.equal(typeof routename, "string");
  routename = pathname(routename, isLocalFile);
  return this.router.match(routename);
};
function pathname(routename, isElectron) {
  if (isElectron)
    routename = routename.replace(stripElectron, "");
  else
    routename = routename.replace(prefix, "");
  return decodeURI(routename.replace(suffix, "").replace(normalize, "/"));
}
var events$1 = [
  // attribute events (can be set with attributes)
  "onclick",
  "ondblclick",
  "onmousedown",
  "onmouseup",
  "onmouseover",
  "onmousemove",
  "onmouseout",
  "onmouseenter",
  "onmouseleave",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ondragstart",
  "ondrag",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondrop",
  "ondragend",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onunload",
  "onabort",
  "onerror",
  "onresize",
  "onscroll",
  "onselect",
  "onchange",
  "onsubmit",
  "onreset",
  "onfocus",
  "onblur",
  "oninput",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  // other common events
  "oncontextmenu",
  "onfocusin",
  "onfocusout"
];
var events = events$1;
var eventsLength = events.length;
var ELEMENT_NODE = 1;
var TEXT_NODE$1 = 3;
var COMMENT_NODE = 8;
var morph_1 = morph$2;
function morph$2(newNode, oldNode) {
  var nodeType = newNode.nodeType;
  var nodeName = newNode.nodeName;
  if (nodeType === ELEMENT_NODE) {
    copyAttrs(newNode, oldNode);
  }
  if (nodeType === TEXT_NODE$1 || nodeType === COMMENT_NODE) {
    if (oldNode.nodeValue !== newNode.nodeValue) {
      oldNode.nodeValue = newNode.nodeValue;
    }
  }
  if (nodeName === "INPUT")
    updateInput(newNode, oldNode);
  else if (nodeName === "OPTION")
    updateOption(newNode, oldNode);
  else if (nodeName === "TEXTAREA")
    updateTextarea(newNode, oldNode);
  copyEvents(newNode, oldNode);
}
function copyAttrs(newNode, oldNode) {
  var oldAttrs = oldNode.attributes;
  var newAttrs = newNode.attributes;
  var attrNamespaceURI = null;
  var attrValue = null;
  var fromValue = null;
  var attrName = null;
  var attr = null;
  for (var i2 = newAttrs.length - 1; i2 >= 0; --i2) {
    attr = newAttrs[i2];
    attrName = attr.name;
    attrNamespaceURI = attr.namespaceURI;
    attrValue = attr.value;
    if (attrNamespaceURI) {
      attrName = attr.localName || attrName;
      fromValue = oldNode.getAttributeNS(attrNamespaceURI, attrName);
      if (fromValue !== attrValue) {
        oldNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
      }
    } else {
      if (!oldNode.hasAttribute(attrName)) {
        oldNode.setAttribute(attrName, attrValue);
      } else {
        fromValue = oldNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          if (attrValue === "null" || attrValue === "undefined") {
            oldNode.removeAttribute(attrName);
          } else {
            oldNode.setAttribute(attrName, attrValue);
          }
        }
      }
    }
  }
  for (var j = oldAttrs.length - 1; j >= 0; --j) {
    attr = oldAttrs[j];
    if (attr.specified !== false) {
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          oldNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!newNode.hasAttributeNS(null, attrName)) {
          oldNode.removeAttribute(attrName);
        }
      }
    }
  }
}
function copyEvents(newNode, oldNode) {
  for (var i2 = 0; i2 < eventsLength; i2++) {
    var ev = events[i2];
    if (newNode[ev]) {
      oldNode[ev] = newNode[ev];
    } else if (oldNode[ev]) {
      oldNode[ev] = void 0;
    }
  }
}
function updateOption(newNode, oldNode) {
  updateAttribute(newNode, oldNode, "selected");
}
function updateInput(newNode, oldNode) {
  var newValue = newNode.value;
  var oldValue = oldNode.value;
  updateAttribute(newNode, oldNode, "checked");
  updateAttribute(newNode, oldNode, "disabled");
  if (newNode.indeterminate !== oldNode.indeterminate) {
    oldNode.indeterminate = newNode.indeterminate;
  }
  if (oldNode.type === "file")
    return;
  if (newValue !== oldValue) {
    oldNode.setAttribute("value", newValue);
    oldNode.value = newValue;
  }
  if (newValue === "null") {
    oldNode.value = "";
    oldNode.removeAttribute("value");
  }
  if (!newNode.hasAttributeNS(null, "value")) {
    oldNode.removeAttribute("value");
  } else if (oldNode.type === "range") {
    oldNode.value = newValue;
  }
}
function updateTextarea(newNode, oldNode) {
  var newValue = newNode.value;
  if (newValue !== oldNode.value) {
    oldNode.value = newValue;
  }
  if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {
    if (newValue === "" && oldNode.firstChild.nodeValue === oldNode.placeholder) {
      return;
    }
    oldNode.firstChild.nodeValue = newValue;
  }
}
function updateAttribute(newNode, oldNode, name) {
  if (newNode[name] !== oldNode[name]) {
    oldNode[name] = newNode[name];
    if (newNode[name]) {
      oldNode.setAttribute(name, "");
    } else {
      oldNode.removeAttribute(name);
    }
  }
}
var assert$8 = nanoassert$1;
var morph$1 = morph_1;
var TEXT_NODE = 3;
var nanomorph_1 = nanomorph$1;
function nanomorph$1(oldTree, newTree, options2) {
  assert$8.equal(typeof oldTree, "object", "nanomorph: oldTree should be an object");
  assert$8.equal(typeof newTree, "object", "nanomorph: newTree should be an object");
  if (options2 && options2.childrenOnly) {
    updateChildren(newTree, oldTree);
    return oldTree;
  }
  assert$8.notEqual(
    newTree.nodeType,
    11,
    "nanomorph: newTree should have one root node (which is not a DocumentFragment)"
  );
  return walk(newTree, oldTree);
}
function walk(newNode, oldNode) {
  if (!oldNode) {
    return newNode;
  } else if (!newNode) {
    return null;
  } else if (newNode.isSameNode && newNode.isSameNode(oldNode)) {
    return oldNode;
  } else if (newNode.tagName !== oldNode.tagName || getComponentId(newNode) !== getComponentId(oldNode)) {
    return newNode;
  } else {
    morph$1(newNode, oldNode);
    updateChildren(newNode, oldNode);
    return oldNode;
  }
}
function getComponentId(node) {
  return node.dataset ? node.dataset.nanomorphComponentId : void 0;
}
function updateChildren(newNode, oldNode) {
  var oldChild, newChild, morphed, oldMatch;
  var offset2 = 0;
  for (var i2 = 0; ; i2++) {
    oldChild = oldNode.childNodes[i2];
    newChild = newNode.childNodes[i2 - offset2];
    if (!oldChild && !newChild) {
      break;
    } else if (!newChild) {
      oldNode.removeChild(oldChild);
      i2--;
    } else if (!oldChild) {
      oldNode.appendChild(newChild);
      offset2++;
    } else if (same(newChild, oldChild)) {
      morphed = walk(newChild, oldChild);
      if (morphed !== oldChild) {
        oldNode.replaceChild(morphed, oldChild);
        offset2++;
      }
    } else {
      oldMatch = null;
      for (var j = i2; j < oldNode.childNodes.length; j++) {
        if (same(oldNode.childNodes[j], newChild)) {
          oldMatch = oldNode.childNodes[j];
          break;
        }
      }
      if (oldMatch) {
        morphed = walk(newChild, oldMatch);
        if (morphed !== oldMatch)
          offset2++;
        oldNode.insertBefore(morphed, oldChild);
      } else if (!newChild.id && !oldChild.id) {
        morphed = walk(newChild, oldChild);
        if (morphed !== oldChild) {
          oldNode.replaceChild(morphed, oldChild);
          offset2++;
        }
      } else {
        oldNode.insertBefore(newChild, oldChild);
        offset2++;
      }
    }
  }
}
function same(a2, b) {
  if (a2.id)
    return a2.id === b.id;
  if (a2.isSameNode)
    return a2.isSameNode(b);
  if (a2.tagName !== b.tagName)
    return false;
  if (a2.type === TEXT_NODE)
    return a2.nodeValue === b.nodeValue;
  return false;
}
var reg = /([^?=&]+)(=([^&]*))?/g;
var assert$7 = nanoassert$1;
var browser$8 = qs;
function qs(url2) {
  assert$7.equal(typeof url2, "string", "nanoquery: url should be type string");
  var obj = {};
  url2.replace(/^.*\?/, "").replace(reg, function(a0, a1, a2, a3) {
    var value = decodeURIComponent(a3);
    var key = decodeURIComponent(a1);
    if (obj.hasOwnProperty(key)) {
      if (Array.isArray(obj[key]))
        obj[key].push(value);
      else
        obj[key] = [obj[key], value];
    } else {
      obj[key] = value;
    }
  });
  return obj;
}
var assert$6 = nanoassert$1;
var safeExternalLink = /(noopener|noreferrer) (noopener|noreferrer)/;
var protocolLink = /^[\w-_]+:/;
var nanohref$1 = href;
function href(cb, root2) {
  assert$6.notEqual(typeof window, "undefined", "nanohref: expected window to exist");
  root2 = root2 || window.document;
  assert$6.equal(typeof cb, "function", "nanohref: cb should be type function");
  assert$6.equal(typeof root2, "object", "nanohref: root should be type object");
  window.addEventListener("click", function(e) {
    if (e.button && e.button !== 0 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.defaultPrevented)
      return;
    var anchor = function traverse(node) {
      if (!node || node === root2)
        return;
      if (node.localName !== "a" || node.href === void 0) {
        return traverse(node.parentNode);
      }
      return node;
    }(e.target);
    if (!anchor)
      return;
    if (window.location.protocol !== anchor.protocol || window.location.hostname !== anchor.hostname || window.location.port !== anchor.port || anchor.hasAttribute("data-nanohref-ignore") || anchor.hasAttribute("download") || anchor.getAttribute("target") === "_blank" && safeExternalLink.test(anchor.getAttribute("rel")) || protocolLink.test(anchor.getAttribute("href")))
      return;
    e.preventDefault();
    cb(anchor);
  });
}
var assert$5 = nanoassert$1;
var nanoraf_1 = nanoraf$1;
function nanoraf$1(render2, raf2) {
  assert$5.equal(typeof render2, "function", "nanoraf: render should be a function");
  assert$5.ok(typeof raf2 === "function" || typeof raf2 === "undefined", "nanoraf: raf should be a function or undefined");
  if (!raf2)
    raf2 = window.requestAnimationFrame;
  var redrawScheduled = false;
  var args = null;
  return function frame() {
    if (args === null && !redrawScheduled) {
      redrawScheduled = true;
      raf2(function redraw() {
        redrawScheduled = false;
        var length2 = args.length;
        var _args = new Array(length2);
        for (var i2 = 0; i2 < length2; i2++)
          _args[i2] = args[i2];
        render2.apply(render2, _args);
        args = null;
      });
    }
    args = arguments;
  };
}
var removeArrayItems = function removeItems2(arr2, startIdx, removeCount) {
  var i2, length2 = arr2.length;
  if (startIdx >= length2 || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length2 ? length2 - startIdx : removeCount;
  var len2 = length2 - removeCount;
  for (i2 = startIdx; i2 < len2; ++i2) {
    arr2[i2] = arr2[i2 + removeCount];
  }
  arr2.length = len2;
};
var splice = removeArrayItems;
var nanotiming$2 = browser$9;
var assert$4 = nanoassert$1;
var nanobus$1 = Nanobus;
function Nanobus(name) {
  if (!(this instanceof Nanobus))
    return new Nanobus(name);
  this._name = name || "nanobus";
  this._starListeners = [];
  this._listeners = {};
}
Nanobus.prototype.emit = function(eventName) {
  assert$4.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.emit: eventName should be type string or symbol");
  var data2 = [];
  for (var i2 = 1, len2 = arguments.length; i2 < len2; i2++) {
    data2.push(arguments[i2]);
  }
  var emitTiming = nanotiming$2(this._name + "('" + eventName.toString() + "')");
  var listeners2 = this._listeners[eventName];
  if (listeners2 && listeners2.length > 0) {
    this._emit(this._listeners[eventName], data2);
  }
  if (this._starListeners.length > 0) {
    this._emit(this._starListeners, eventName, data2, emitTiming.uuid);
  }
  emitTiming();
  return this;
};
Nanobus.prototype.on = Nanobus.prototype.addListener = function(eventName, listener) {
  assert$4.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.on: eventName should be type string or symbol");
  assert$4.equal(typeof listener, "function", "nanobus.on: listener should be type function");
  if (eventName === "*") {
    this._starListeners.push(listener);
  } else {
    if (!this._listeners[eventName])
      this._listeners[eventName] = [];
    this._listeners[eventName].push(listener);
  }
  return this;
};
Nanobus.prototype.prependListener = function(eventName, listener) {
  assert$4.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.prependListener: eventName should be type string or symbol");
  assert$4.equal(typeof listener, "function", "nanobus.prependListener: listener should be type function");
  if (eventName === "*") {
    this._starListeners.unshift(listener);
  } else {
    if (!this._listeners[eventName])
      this._listeners[eventName] = [];
    this._listeners[eventName].unshift(listener);
  }
  return this;
};
Nanobus.prototype.once = function(eventName, listener) {
  assert$4.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.once: eventName should be type string or symbol");
  assert$4.equal(typeof listener, "function", "nanobus.once: listener should be type function");
  var self2 = this;
  this.on(eventName, once3);
  function once3() {
    listener.apply(self2, arguments);
    self2.removeListener(eventName, once3);
  }
  return this;
};
Nanobus.prototype.prependOnceListener = function(eventName, listener) {
  assert$4.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.prependOnceListener: eventName should be type string or symbol");
  assert$4.equal(typeof listener, "function", "nanobus.prependOnceListener: listener should be type function");
  var self2 = this;
  this.prependListener(eventName, once3);
  function once3() {
    listener.apply(self2, arguments);
    self2.removeListener(eventName, once3);
  }
  return this;
};
Nanobus.prototype.removeListener = function(eventName, listener) {
  assert$4.ok(typeof eventName === "string" || typeof eventName === "symbol", "nanobus.removeListener: eventName should be type string or symbol");
  assert$4.equal(typeof listener, "function", "nanobus.removeListener: listener should be type function");
  if (eventName === "*") {
    this._starListeners = this._starListeners.slice();
    return remove2(this._starListeners, listener);
  } else {
    if (typeof this._listeners[eventName] !== "undefined") {
      this._listeners[eventName] = this._listeners[eventName].slice();
    }
    return remove2(this._listeners[eventName], listener);
  }
  function remove2(arr2, listener2) {
    if (!arr2)
      return;
    var index2 = arr2.indexOf(listener2);
    if (index2 !== -1) {
      splice(arr2, index2, 1);
      return true;
    }
  }
};
Nanobus.prototype.removeAllListeners = function(eventName) {
  if (eventName) {
    if (eventName === "*") {
      this._starListeners = [];
    } else {
      this._listeners[eventName] = [];
    }
  } else {
    this._starListeners = [];
    this._listeners = {};
  }
  return this;
};
Nanobus.prototype.listeners = function(eventName) {
  var listeners2 = eventName !== "*" ? this._listeners[eventName] : this._starListeners;
  var ret = [];
  if (listeners2) {
    var ilength = listeners2.length;
    for (var i2 = 0; i2 < ilength; i2++)
      ret.push(listeners2[i2]);
  }
  return ret;
};
Nanobus.prototype._emit = function(arr2, eventName, data2, uuid) {
  if (typeof arr2 === "undefined")
    return;
  if (arr2.length === 0)
    return;
  if (data2 === void 0) {
    data2 = eventName;
    eventName = null;
  }
  if (eventName) {
    if (uuid !== void 0) {
      data2 = [eventName].concat(data2, uuid);
    } else {
      data2 = [eventName].concat(data2);
    }
  }
  var length2 = arr2.length;
  for (var i2 = 0; i2 < length2; i2++) {
    var listener = arr2[i2];
    listener.apply(listener, data2);
  }
};
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs(nanobus$1);
var nanolru = LRU$1;
function LRU$1(opts) {
  if (!(this instanceof LRU$1))
    return new LRU$1(opts);
  if (typeof opts === "number")
    opts = { max: opts };
  if (!opts)
    opts = {};
  this.cache = {};
  this.head = this.tail = null;
  this.length = 0;
  this.max = opts.max || 1e3;
  this.maxAge = opts.maxAge || 0;
}
Object.defineProperty(LRU$1.prototype, "keys", {
  get: function() {
    return Object.keys(this.cache);
  }
});
LRU$1.prototype.clear = function() {
  this.cache = {};
  this.head = this.tail = null;
  this.length = 0;
};
LRU$1.prototype.remove = function(key) {
  if (typeof key !== "string")
    key = "" + key;
  if (!this.cache.hasOwnProperty(key))
    return;
  var element = this.cache[key];
  delete this.cache[key];
  this._unlink(key, element.prev, element.next);
  return element.value;
};
LRU$1.prototype._unlink = function(key, prev2, next) {
  this.length--;
  if (this.length === 0) {
    this.head = this.tail = null;
  } else {
    if (this.head === key) {
      this.head = prev2;
      this.cache[this.head].next = null;
    } else if (this.tail === key) {
      this.tail = next;
      this.cache[this.tail].prev = null;
    } else {
      this.cache[prev2].next = next;
      this.cache[next].prev = prev2;
    }
  }
};
LRU$1.prototype.peek = function(key) {
  if (!this.cache.hasOwnProperty(key))
    return;
  var element = this.cache[key];
  if (!this._checkAge(key, element))
    return;
  return element.value;
};
LRU$1.prototype.set = function(key, value) {
  if (typeof key !== "string")
    key = "" + key;
  var element;
  if (this.cache.hasOwnProperty(key)) {
    element = this.cache[key];
    element.value = value;
    if (this.maxAge)
      element.modified = Date.now();
    if (key === this.head)
      return value;
    this._unlink(key, element.prev, element.next);
  } else {
    element = { value, modified: 0, next: null, prev: null };
    if (this.maxAge)
      element.modified = Date.now();
    this.cache[key] = element;
    if (this.length === this.max)
      this.evict();
  }
  this.length++;
  element.next = null;
  element.prev = this.head;
  if (this.head)
    this.cache[this.head].next = key;
  this.head = key;
  if (!this.tail)
    this.tail = key;
  return value;
};
LRU$1.prototype._checkAge = function(key, element) {
  if (this.maxAge && Date.now() - element.modified > this.maxAge) {
    this.remove(key);
    return false;
  }
  return true;
};
LRU$1.prototype.get = function(key) {
  if (typeof key !== "string")
    key = "" + key;
  if (!this.cache.hasOwnProperty(key))
    return;
  var element = this.cache[key];
  if (!this._checkAge(key, element))
    return;
  if (this.head !== key) {
    if (key === this.tail) {
      this.tail = element.next;
      this.cache[this.tail].prev = null;
    } else {
      this.cache[element.prev].next = element.next;
    }
    this.cache[element.next].prev = element.prev;
    this.cache[this.head].next = key;
    element.prev = this.head;
    element.next = null;
    this.head = key;
  }
  return element.value;
};
LRU$1.prototype.evict = function() {
  if (!this.tail)
    return;
  this.remove(this.tail);
};
var assert$3 = nanoassert$1;
var LRU = nanolru;
var cache = ChooComponentCache;
function ChooComponentCache(state2, emit2, lru) {
  assert$3.ok(this instanceof ChooComponentCache, "ChooComponentCache should be created with `new`");
  assert$3.equal(typeof state2, "object", "ChooComponentCache: state should be type object");
  assert$3.equal(typeof emit2, "function", "ChooComponentCache: emit should be type function");
  if (typeof lru === "number")
    this.cache = new LRU(lru);
  else
    this.cache = lru || new LRU(100);
  this.state = state2;
  this.emit = emit2;
}
ChooComponentCache.prototype.render = function(Component2, id2) {
  assert$3.equal(typeof Component2, "function", "ChooComponentCache.render: Component should be type function");
  assert$3.ok(typeof id2 === "string" || typeof id2 === "number", "ChooComponentCache.render: id should be type string or type number");
  var el = this.cache.get(id2);
  if (!el) {
    var args = [];
    for (var i2 = 2, len2 = arguments.length; i2 < len2; i2++) {
      args.push(arguments[i2]);
    }
    args.unshift(Component2, id2, this.state, this.emit);
    el = newCall.apply(newCall, args);
    this.cache.set(id2, el);
  }
  return el;
};
function newCall(Cls) {
  return new (Cls.bind.apply(Cls, arguments))();
}
var scrollToAnchor = scrollToAnchor_1;
var documentReady = documentReady$1;
var nanotiming$1 = browser$9;
var nanorouter = nanorouter$1;
var nanomorph = nanomorph_1;
var nanoquery = browser$8;
var nanohref = nanohref$1;
var nanoraf = nanoraf_1;
var nanobus = nanobus$1;
var assert$2 = nanoassert$1;
var Cache = cache;
var choo = Choo;
var HISTORY_OBJECT = {};
function Choo(opts) {
  var timing = nanotiming$1("choo.constructor");
  if (!(this instanceof Choo))
    return new Choo(opts);
  opts = opts || {};
  assert$2.equal(typeof opts, "object", "choo: opts should be type object");
  var self2 = this;
  this._events = {
    DOMCONTENTLOADED: "DOMContentLoaded",
    DOMTITLECHANGE: "DOMTitleChange",
    REPLACESTATE: "replaceState",
    PUSHSTATE: "pushState",
    NAVIGATE: "navigate",
    POPSTATE: "popState",
    RENDER: "render"
  };
  this._historyEnabled = opts.history === void 0 ? true : opts.history;
  this._hrefEnabled = opts.href === void 0 ? true : opts.href;
  this._hashEnabled = opts.hash === void 0 ? false : opts.hash;
  this._hasWindow = typeof window !== "undefined";
  this._cache = opts.cache;
  this._loaded = false;
  this._stores = [ondomtitlechange];
  this._tree = null;
  var _state = {
    events: this._events,
    components: {}
  };
  if (this._hasWindow) {
    this.state = window.initialState ? Object.assign({}, window.initialState, _state) : _state;
    delete window.initialState;
  } else {
    this.state = _state;
  }
  this.router = nanorouter({ curry: true });
  this.emitter = nanobus("choo.emit");
  this.emit = this.emitter.emit.bind(this.emitter);
  if (this._hasWindow)
    this.state.title = document.title;
  function ondomtitlechange(state2) {
    self2.emitter.prependListener(self2._events.DOMTITLECHANGE, function(title) {
      assert$2.equal(typeof title, "string", "events.DOMTitleChange: title should be type string");
      state2.title = title;
      if (self2._hasWindow)
        document.title = title;
    });
  }
  timing();
}
Choo.prototype.route = function(route, handler) {
  var routeTiming = nanotiming$1("choo.route('" + route + "')");
  assert$2.equal(typeof route, "string", "choo.route: route should be type string");
  assert$2.equal(typeof handler, "function", "choo.handler: route should be type function");
  this.router.on(route, handler);
  routeTiming();
};
Choo.prototype.use = function(cb) {
  assert$2.equal(typeof cb, "function", "choo.use: cb should be type function");
  var self2 = this;
  this._stores.push(function(state2) {
    var msg = "choo.use";
    msg = cb.storeName ? msg + "(" + cb.storeName + ")" : msg;
    var endTiming = nanotiming$1(msg);
    cb(state2, self2.emitter, self2);
    endTiming();
  });
};
Choo.prototype.start = function() {
  assert$2.equal(typeof window, "object", "choo.start: window was not found. .start() must be called in a browser, use .toString() if running in Node");
  var startTiming = nanotiming$1("choo.start");
  var self2 = this;
  if (this._historyEnabled) {
    this.emitter.prependListener(this._events.NAVIGATE, function() {
      self2._matchRoute(self2.state);
      if (self2._loaded) {
        self2.emitter.emit(self2._events.RENDER);
        setTimeout(scrollToAnchor.bind(null, window.location.hash), 0);
      }
    });
    this.emitter.prependListener(this._events.POPSTATE, function() {
      self2.emitter.emit(self2._events.NAVIGATE);
    });
    this.emitter.prependListener(this._events.PUSHSTATE, function(href2) {
      assert$2.equal(typeof href2, "string", "events.pushState: href should be type string");
      window.history.pushState(HISTORY_OBJECT, null, href2);
      self2.emitter.emit(self2._events.NAVIGATE);
    });
    this.emitter.prependListener(this._events.REPLACESTATE, function(href2) {
      assert$2.equal(typeof href2, "string", "events.replaceState: href should be type string");
      window.history.replaceState(HISTORY_OBJECT, null, href2);
      self2.emitter.emit(self2._events.NAVIGATE);
    });
    window.onpopstate = function() {
      self2.emitter.emit(self2._events.POPSTATE);
    };
    if (self2._hrefEnabled) {
      nanohref(function(location2) {
        var href2 = location2.href;
        var hash = location2.hash;
        if (href2 === window.location.href) {
          if (!self2._hashEnabled && hash)
            scrollToAnchor(hash);
          return;
        }
        self2.emitter.emit(self2._events.PUSHSTATE, href2);
      });
    }
  }
  this._setCache(this.state);
  this._matchRoute(this.state);
  this._stores.forEach(function(initStore) {
    initStore(self2.state);
  });
  this._tree = this._prerender(this.state);
  assert$2.ok(this._tree, "choo.start: no valid DOM node returned for location " + this.state.href);
  this.emitter.prependListener(self2._events.RENDER, nanoraf(function() {
    var renderTiming = nanotiming$1("choo.render");
    var newTree = self2._prerender(self2.state);
    assert$2.ok(newTree, "choo.render: no valid DOM node returned for location " + self2.state.href);
    assert$2.equal(self2._tree.nodeName, newTree.nodeName, "choo.render: The target node <" + self2._tree.nodeName.toLowerCase() + "> is not the same type as the new node <" + newTree.nodeName.toLowerCase() + ">.");
    var morphTiming = nanotiming$1("choo.morph");
    nanomorph(self2._tree, newTree);
    morphTiming();
    renderTiming();
  }));
  documentReady(function() {
    self2.emitter.emit(self2._events.DOMCONTENTLOADED);
    self2._loaded = true;
  });
  startTiming();
  return this._tree;
};
Choo.prototype.mount = function mount(selector) {
  var mountTiming = nanotiming$1("choo.mount('" + selector + "')");
  if (typeof window !== "object") {
    assert$2.ok(typeof selector === "string", "choo.mount: selector should be type String");
    this.selector = selector;
    mountTiming();
    return this;
  }
  assert$2.ok(typeof selector === "string" || typeof selector === "object", "choo.mount: selector should be type String or HTMLElement");
  var self2 = this;
  documentReady(function() {
    var renderTiming = nanotiming$1("choo.render");
    var newTree = self2.start();
    if (typeof selector === "string") {
      self2._tree = document.querySelector(selector);
    } else {
      self2._tree = selector;
    }
    assert$2.ok(self2._tree, "choo.mount: could not query selector: " + selector);
    assert$2.equal(self2._tree.nodeName, newTree.nodeName, "choo.mount: The target node <" + self2._tree.nodeName.toLowerCase() + "> is not the same type as the new node <" + newTree.nodeName.toLowerCase() + ">.");
    var morphTiming = nanotiming$1("choo.morph");
    nanomorph(self2._tree, newTree);
    morphTiming();
    renderTiming();
  });
  mountTiming();
};
Choo.prototype.toString = function(location2, state2) {
  state2 = state2 || {};
  state2.components = state2.components || {};
  state2.events = Object.assign({}, state2.events, this._events);
  assert$2.notEqual(typeof window, "object", "choo.mount: window was found. .toString() must be called in Node, use .start() or .mount() if running in the browser");
  assert$2.equal(typeof location2, "string", "choo.toString: location should be type string");
  assert$2.equal(typeof state2, "object", "choo.toString: state should be type object");
  this._setCache(state2);
  this._matchRoute(state2, location2);
  this.emitter.removeAllListeners();
  this._stores.forEach(function(initStore) {
    initStore(state2);
  });
  var html2 = this._prerender(state2);
  assert$2.ok(html2, "choo.toString: no valid value returned for the route " + location2);
  assert$2(!Array.isArray(html2), "choo.toString: return value was an array for the route " + location2);
  return typeof html2.outerHTML === "string" ? html2.outerHTML : html2.toString();
};
Choo.prototype._matchRoute = function(state2, locationOverride) {
  var location2, queryString;
  if (locationOverride) {
    location2 = locationOverride.replace(/\?.+$/, "").replace(/\/$/, "");
    if (!this._hashEnabled)
      location2 = location2.replace(/#.+$/, "");
    queryString = locationOverride;
  } else {
    location2 = window.location.pathname.replace(/\/$/, "");
    if (this._hashEnabled)
      location2 += window.location.hash.replace(/^#/, "/");
    queryString = window.location.search;
  }
  var matched = this.router.match(location2);
  this._handler = matched.cb;
  state2.href = location2;
  state2.query = nanoquery(queryString);
  state2.route = matched.route;
  state2.params = matched.params;
};
Choo.prototype._prerender = function(state2) {
  var routeTiming = nanotiming$1("choo.prerender('" + state2.route + "')");
  var res = this._handler(state2, this.emit);
  routeTiming();
  return res;
};
Choo.prototype._setCache = function(state2) {
  var cache2 = new Cache(state2, this.emitter.emit.bind(this.emitter), this._cache);
  state2.cache = renderComponent;
  function renderComponent(Component2, id2) {
    assert$2.equal(typeof Component2, "function", "choo.state.cache: Component should be type function");
    var args = [];
    for (var i2 = 0, len2 = arguments.length; i2 < len2; i2++) {
      args.push(arguments[i2]);
    }
    return cache2.render.apply(cache2, args);
  }
  renderComponent.toJSON = function() {
    return null;
  };
};
const choo$1 = /* @__PURE__ */ getDefaultExportFromCjs(choo);
var client = { exports: {} };
var componentEmitter = { exports: {} };
(function(module2) {
  {
    module2.exports = Emitter2;
  }
  function Emitter2(obj) {
    if (obj)
      return mixin(obj);
  }
  function mixin(obj) {
    for (var key in Emitter2.prototype) {
      obj[key] = Emitter2.prototype[key];
    }
    return obj;
  }
  Emitter2.prototype.on = Emitter2.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
    return this;
  };
  Emitter2.prototype.once = function(event, fn) {
    function on2() {
      this.off(event, on2);
      fn.apply(this, arguments);
    }
    on2.fn = fn;
    this.on(event, on2);
    return this;
  };
  Emitter2.prototype.off = Emitter2.prototype.removeListener = Emitter2.prototype.removeAllListeners = Emitter2.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }
    var callbacks2 = this._callbacks["$" + event];
    if (!callbacks2)
      return this;
    if (1 == arguments.length) {
      delete this._callbacks["$" + event];
      return this;
    }
    var cb;
    for (var i2 = 0; i2 < callbacks2.length; i2++) {
      cb = callbacks2[i2];
      if (cb === fn || cb.fn === fn) {
        callbacks2.splice(i2, 1);
        break;
      }
    }
    if (callbacks2.length === 0) {
      delete this._callbacks["$" + event];
    }
    return this;
  };
  Emitter2.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks2 = this._callbacks["$" + event];
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
    if (callbacks2) {
      callbacks2 = callbacks2.slice(0);
      for (var i2 = 0, len2 = callbacks2.length; i2 < len2; ++i2) {
        callbacks2[i2].apply(this, args);
      }
    }
    return this;
  };
  Emitter2.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
  };
  Emitter2.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
})(componentEmitter);
var componentEmitterExports = componentEmitter.exports;
var shams = function hasSymbols2() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  foo: {}
};
var $Object = Object;
var hasProto$1 = function hasProto2() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice$2 = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind2(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice$2.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        args.concat(slice$2.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice$2.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs.push("$" + i2);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var bind$2 = functionBind;
var src$1 = bind$2.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$1 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = hasSymbols$1();
var hasProto = hasProto$1();
var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
  return x2.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$1 = functionBind;
var hasOwn$3 = src$1;
var $concat$1 = bind$1.call(Function.call, Array.prototype.concat);
var $spliceApply = bind$1.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind$1.call(Function.call, String.prototype.replace);
var $strSlice = bind$1.call(Function.call, String.prototype.slice);
var $exec = bind$1.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last2 = $strSlice(string, -1);
  if (first === "%" && last2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last2 === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string, rePropName, function(match, number, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$3(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$3(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts2 = stringToPath(name);
  var intrinsicBaseName = parts2.length > 0 ? parts2[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts2, $concat$1([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts2.length; i2 += 1) {
    var part = parts2[i2];
    var first = $strSlice(part, 0, 1);
    var last2 = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first !== last2) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$3(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i2 + 1 >= parts2.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$3(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
(function(module2) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind3, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty(
          func,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$1);
var callBindExports = callBind$1.exports;
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBindExports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
  return O.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$3;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options2, depth, seen) {
  var opts = options2 || {};
  if (has$4(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$4(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$4(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$4(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$4(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$6(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf$2(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$4(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp$1(obj)) {
    var name = nameOf(obj);
    var keys3 = arrObjKeys(obj, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys3.length > 0 ? " { " + $join.call(keys3, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i2 = 0; i2 < attrs.length; i2++) {
      s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
    }
    s2 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s2 += "...";
    }
    s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s2;
  }
  if (isArray$6(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts2 = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts2), ", ") + " }";
    }
    if (parts2.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts2, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (!isDate(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s2, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s2 + quoteChar;
}
function quote(s2) {
  return $replace.call(String(s2), /"/g, "&quot;");
}
function isArray$6(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn$2 = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$4(obj, key) {
  return hasOwn$2.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m2 = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf$2(xs, x2) {
  if (xs.indexOf) {
    return xs.indexOf(x2);
  }
  for (var i2 = 0, l = xs.length; i2 < l; i2++) {
    if (xs[i2] === x2) {
      return i2;
    }
  }
  return -1;
}
function isMap(x2) {
  if (!mapSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize.call(x2);
    try {
      setSize.call(x2);
    } catch (s2) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize.call(x2);
    } catch (m2) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s2, "single", opts);
}
function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type) {
  return type + " { ? }";
}
function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (indexOf$2(xs[i2], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$6(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i2 = 0; i2 < obj.length; i2++) {
      xs[i2] = has$4(obj, i2) ? inspect2(obj[i2], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap["$" + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    if (!has$4(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = GetIntrinsic("%TypeError%");
var $WeakMap = GetIntrinsic("%WeakMap%", true);
var $Map = GetIntrinsic("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list2, key) {
  for (var prev2 = list2, curr; (curr = prev2.next) !== null; prev2 = curr) {
    if (curr.key === key) {
      prev2.next = curr.next;
      curr.next = list2.next;
      list2.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = {
      // eslint-disable-line no-param-reassign
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel2() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$3 = Object.prototype.hasOwnProperty;
var isArray$5 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue2) {
  while (queue2.length > 1) {
    var item = queue2.pop();
    var obj = item.obj[item.prop];
    if (isArray$5(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options2) {
  var obj = options2 && options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i2 = 0; i2 < source.length; ++i2) {
    if (typeof source[i2] !== "undefined") {
      obj[i2] = source[i2];
    }
  }
  return obj;
};
var merge = function merge2(target, source, options2) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$5(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options2 && (options2.plainObjects || options2.allowPrototypes) || !has$3.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$5(target) && !isArray$5(source)) {
    mergeTarget = arrayToObject(target, options2);
  }
  if (isArray$5(target) && isArray$5(source)) {
    source.forEach(function(item, i2) {
      if (has$3.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge2(targetItem, item, options2);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$3.call(acc, key)) {
      acc[key] = merge2(acc[key], value, options2);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign$1 = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode$1 = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode$1 = function encode2(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i2 = 0; i2 < string.length; ++i2) {
    var c = string.charCodeAt(i2);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats$2.RFC1738 && (c === 40 || c === 41)) {
      out += string.charAt(i2);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i2 += 1;
    c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i2) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue2 = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue2.length; ++i2) {
    var item = queue2[i2];
    var obj = item.obj[item.prop];
    var keys3 = Object.keys(obj);
    for (var j = 0; j < keys3.length; ++j) {
      var key = keys3[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue2.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue2);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer$1 = function isBuffer3(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a2, b) {
  return [].concat(a2, b);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$5(val)) {
    var mapped = [];
    for (var i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn(val[i2]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$4 = {
  arrayToObject,
  assign: assign$1,
  combine,
  compact,
  decode: decode$1,
  encode: encode$1,
  isBuffer: isBuffer$1,
  isRegExp,
  maybeMap,
  merge
};
var getSideChannel = sideChannel;
var utils$3 = utils$4;
var formats$1 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix2) {
    return prefix2 + "[]";
  },
  comma: "comma",
  indices: function indices(prefix2, key) {
    return prefix2 + "[" + key + "]";
  },
  repeat: function repeat(prefix2) {
    return prefix2;
  }
};
var isArray$4 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr2, valueOrArray) {
  push.apply(arr2, isArray$4(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$2 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$3.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var sentinel = {};
var stringify$2 = function stringify2(object, prefix2, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix2, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$4(obj)) {
    obj = utils$3.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix2, defaults$2.encoder, charset, "key", format2) : prefix2;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$3.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix2 : encoder(prefix2, defaults$2.encoder, charset, "key", format2);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$2.encoder, charset, "value", format2))];
    }
    return [formatter(prefix2) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$4(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = utils$3.maybeMap(obj, encoder);
    }
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$4(filter)) {
    objKeys = filter;
  } else {
    var keys3 = Object.keys(obj);
    objKeys = sort ? keys3.sort(sort) : keys3;
  }
  var adjustedPrefix = commaRoundTrip && isArray$4(obj) && obj.length === 1 ? prefix2 + "[]" : prefix2;
  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$4(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
    sideChannel2.set(object, step);
    var valueSideChannel = getSideChannel();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify2(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      strictNullHandling,
      skipNulls,
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray$4(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate2,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$2;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$2.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$2.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$1.formatters[format2];
  var filter = defaults$2.filter;
  if (typeof opts.filter === "function" || isArray$4(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$2.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$2.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$2.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$2.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$2.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$2.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$2.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$2.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$2.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$2.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options2 = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options2.filter === "function") {
    filter = options2.filter;
    obj = filter("", obj);
  } else if (isArray$4(options2.filter)) {
    filter = options2.filter;
    objKeys = filter;
  }
  var keys3 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options2.sort) {
    objKeys.sort(options2.sort);
  }
  var sideChannel2 = getSideChannel();
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    if (options2.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys3, stringify$2(
      obj[key],
      key,
      generateArrayPrefix,
      commaRoundTrip,
      options2.strictNullHandling,
      options2.skipNulls,
      options2.encode ? options2.encoder : null,
      options2.filter,
      options2.sort,
      options2.allowDots,
      options2.serializeDate,
      options2.format,
      options2.formatter,
      options2.encodeValuesOnly,
      options2.charset,
      sideChannel2
    ));
  }
  var joined = keys3.join(options2.delimiter);
  var prefix2 = options2.addQueryPrefix === true ? "?" : "";
  if (options2.charsetSentinel) {
    if (options2.charset === "iso-8859-1") {
      prefix2 += "utf8=%26%2310003%3B&";
    } else {
      prefix2 += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix2 + joined : "";
};
var utils$2 = utils$4;
var has$1 = Object.prototype.hasOwnProperty;
var isArray$3 = Array.isArray;
var defaults$1 = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils$2.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options2) {
  if (val && typeof val === "string" && options2.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options2) {
  var obj = { __proto__: null };
  var cleanStr = options2.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options2.parameterLimit === Infinity ? void 0 : options2.parameterLimit;
  var parts2 = cleanStr.split(options2.delimiter, limit);
  var skipIndex = -1;
  var i2;
  var charset = options2.charset;
  if (options2.charsetSentinel) {
    for (i2 = 0; i2 < parts2.length; ++i2) {
      if (parts2[i2].indexOf("utf8=") === 0) {
        if (parts2[i2] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts2[i2] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts2.length;
      }
    }
  }
  for (i2 = 0; i2 < parts2.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts2[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options2.decoder(part, defaults$1.decoder, charset, "key");
      val = options2.strictNullHandling ? null : "";
    } else {
      key = options2.decoder(part.slice(0, pos), defaults$1.decoder, charset, "key");
      val = utils$2.maybeMap(
        parseArrayValue(part.slice(pos + 1), options2),
        function(encodedVal) {
          return options2.decoder(encodedVal, defaults$1.decoder, charset, "value");
        }
      );
    }
    if (val && options2.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$3(val) ? [val] : val;
    }
    if (has$1.call(obj, key)) {
      obj[key] = utils$2.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options2, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options2);
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root2 = chain[i2];
    if (root2 === "[]" && options2.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var index2 = parseInt(cleanRoot, 10);
      if (!options2.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options2.parseArrays && index2 <= options2.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options2, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options2.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options2.depth > 0 && brackets2.exec(key);
  var parent2 = segment ? key.slice(0, segment.index) : key;
  var keys3 = [];
  if (parent2) {
    if (!options2.plainObjects && has$1.call(Object.prototype, parent2)) {
      if (!options2.allowPrototypes) {
        return;
      }
    }
    keys3.push(parent2);
  }
  var i2 = 0;
  while (options2.depth > 0 && (segment = child.exec(key)) !== null && i2 < options2.depth) {
    i2 += 1;
    if (!options2.plainObjects && has$1.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options2.allowPrototypes) {
        return;
      }
    }
    keys3.push(segment[1]);
  }
  if (segment) {
    keys3.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys3, val, options2, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults$1.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$1.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults$1.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$1.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults$1.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$1.decoder,
    delimiter: typeof opts.delimiter === "string" || utils$2.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults$1.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$1.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$1.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var parse$4 = function(str, opts) {
  var options2 = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options2) : str;
  var obj = options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys3 = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys3.length; ++i2) {
    var key = keys3[i2];
    var newObj = parseKeys(key, tempObj[key], options2, typeof str === "string");
    obj = utils$2.merge(obj, newObj, options2);
  }
  if (options2.allowSparse === true) {
    return obj;
  }
  return utils$2.compact(obj);
};
var stringify$1 = stringify_1;
var parse$3 = parse$4;
var formats = formats$3;
var lib$3 = {
  formats,
  parse: parse$3,
  stringify: stringify$1
};
var utils$1 = {};
(function(exports2) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof2(obj);
  }
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i2 = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i2 >= o.length)
            return { done: true };
          return { done: false, value: o[i2++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s2() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr2, len2) {
    if (len2 == null || len2 > arr2.length)
      len2 = arr2.length;
    for (var i2 = 0, arr22 = new Array(len2); i2 < len2; i2++) {
      arr22[i2] = arr2[i2];
    }
    return arr22;
  }
  exports2.type = function(string_) {
    return string_.split(/ *; */).shift();
  };
  exports2.params = function(value) {
    var object = {};
    var _iterator = _createForOfIteratorHelper2(value.split(/ *; */)), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var string_ = _step.value;
        var parts2 = string_.split(/ *= */);
        var key = parts2.shift();
        var _value = parts2.shift();
        if (key && _value)
          object[key] = _value;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return object;
  };
  exports2.parseLinks = function(value) {
    var object = {};
    var _iterator2 = _createForOfIteratorHelper2(value.split(/ *, */)), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var string_ = _step2.value;
        var parts2 = string_.split(/ *; */);
        var url2 = parts2[0].slice(1, -1);
        var rel = parts2[1].split(/ *= */)[1].slice(1, -1);
        object[rel] = url2;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return object;
  };
  exports2.cleanHeader = function(header, changesOrigin) {
    delete header["content-type"];
    delete header["content-length"];
    delete header["transfer-encoding"];
    delete header.host;
    if (changesOrigin) {
      delete header.authorization;
      delete header.cookie;
    }
    return header;
  };
  exports2.isObject = function(object) {
    return object !== null && _typeof2(object) === "object";
  };
  exports2.hasOwn = Object.hasOwn || function(object, property) {
    if (object == null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    return Object.prototype.hasOwnProperty.call(new Object(object), property);
  };
  exports2.mixin = function(target, source) {
    for (var key in source) {
      if (exports2.hasOwn(source, key)) {
        target[key] = source[key];
      }
    }
  };
})(utils$1);
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
var semver = require$$3;
var _require = utils$1, isObject = _require.isObject, hasOwn$1 = _require.hasOwn;
var requestBase = RequestBase;
function RequestBase() {
}
RequestBase.prototype.clearTimeout = function() {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  clearTimeout(this._uploadTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  delete this._uploadTimeoutTimer;
  return this;
};
RequestBase.prototype.parse = function(fn) {
  this._parser = fn;
  return this;
};
RequestBase.prototype.responseType = function(value) {
  this._responseType = value;
  return this;
};
RequestBase.prototype.serialize = function(fn) {
  this._serializer = fn;
  return this;
};
RequestBase.prototype.timeout = function(options2) {
  if (!options2 || _typeof$1(options2) !== "object") {
    this._timeout = options2;
    this._responseTimeout = 0;
    this._uploadTimeout = 0;
    return this;
  }
  for (var option in options2) {
    if (hasOwn$1(options2, option)) {
      switch (option) {
        case "deadline":
          this._timeout = options2.deadline;
          break;
        case "response":
          this._responseTimeout = options2.response;
          break;
        case "upload":
          this._uploadTimeout = options2.upload;
          break;
        default:
          console.warn("Unknown timeout option", option);
      }
    }
  }
  return this;
};
RequestBase.prototype.retry = function(count, fn) {
  if (arguments.length === 0 || count === true)
    count = 1;
  if (count <= 0)
    count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};
var ERROR_CODES = /* @__PURE__ */ new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]);
var STATUS_CODES = /* @__PURE__ */ new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);
RequestBase.prototype._shouldRetry = function(error2, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(error2, res);
      if (override === true)
        return true;
      if (override === false)
        return false;
    } catch (err) {
      console.error(err);
    }
  }
  if (res && res.status && STATUS_CODES.has(res.status))
    return true;
  if (error2) {
    if (error2.code && ERROR_CODES.has(error2.code))
      return true;
    if (error2.timeout && error2.code === "ECONNABORTED")
      return true;
    if (error2.crossDomain)
      return true;
  }
  return false;
};
RequestBase.prototype._retry = function() {
  this.clearTimeout();
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }
  this._aborted = false;
  this.timedout = false;
  this.timedoutError = null;
  return this._end();
};
RequestBase.prototype.then = function(resolve, reject) {
  var _this = this;
  if (!this._fullfilledPromise) {
    var self2 = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function(resolve2, reject2) {
      self2.on("abort", function() {
        if (_this._maxRetries && _this._maxRetries > _this._retries) {
          return;
        }
        if (_this.timedout && _this.timedoutError) {
          reject2(_this.timedoutError);
          return;
        }
        var error2 = new Error("Aborted");
        error2.code = "ABORTED";
        error2.status = _this.status;
        error2.method = _this.method;
        error2.url = _this.url;
        reject2(error2);
      });
      self2.end(function(error2, res) {
        if (error2)
          reject2(error2);
        else
          resolve2(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};
RequestBase.prototype.catch = function(callback2) {
  return this.then(void 0, callback2);
};
RequestBase.prototype.use = function(fn) {
  fn(this);
  return this;
};
RequestBase.prototype.ok = function(callback2) {
  if (typeof callback2 !== "function")
    throw new Error("Callback required");
  this._okCallback = callback2;
  return this;
};
RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }
  if (this._okCallback) {
    return this._okCallback(res);
  }
  return res.status >= 200 && res.status < 300;
};
RequestBase.prototype.get = function(field) {
  return this._header[field.toLowerCase()];
};
RequestBase.prototype.getHeader = RequestBase.prototype.get;
RequestBase.prototype.set = function(field, value) {
  if (isObject(field)) {
    for (var key in field) {
      if (hasOwn$1(field, key))
        this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = value;
  this.header[field] = value;
  return this;
};
RequestBase.prototype.unset = function(field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
RequestBase.prototype.field = function(name, value, options2) {
  if (name === null || void 0 === name) {
    throw new Error(".field(name, val) name can not be empty");
  }
  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }
  if (isObject(name)) {
    for (var key in name) {
      if (hasOwn$1(name, key))
        this.field(key, name[key]);
    }
    return this;
  }
  if (Array.isArray(value)) {
    for (var i2 in value) {
      if (hasOwn$1(value, i2))
        this.field(name, value[i2]);
    }
    return this;
  }
  if (value === null || void 0 === value) {
    throw new Error(".field(name, val) val can not be empty");
  }
  if (typeof value === "boolean") {
    value = String(value);
  }
  if (options2)
    this._getFormData().append(name, value, options2);
  else
    this._getFormData().append(name, value);
  return this;
};
RequestBase.prototype.abort = function() {
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  if (this.xhr)
    this.xhr.abort();
  if (this.req) {
    if (semver.gte(process.version, "v13.0.0") && semver.lt(process.version, "v14.0.0")) {
      throw new Error("Superagent does not work in v13 properly with abort() due to Node.js core changes");
    } else if (semver.gte(process.version, "v14.0.0")) {
      this.req.destroyed = true;
    }
    this.req.abort();
  }
  this.clearTimeout();
  this.emit("abort");
  return this;
};
RequestBase.prototype._auth = function(user, pass, options2, base64Encoder) {
  switch (options2.type) {
    case "basic":
      this.set("Authorization", "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
      break;
    case "auto":
      this.username = user;
      this.password = pass;
      break;
    case "bearer":
      this.set("Authorization", "Bearer ".concat(user));
      break;
  }
  return this;
};
RequestBase.prototype.withCredentials = function(on2) {
  if (on2 === void 0)
    on2 = true;
  this._withCredentials = on2;
  return this;
};
RequestBase.prototype.redirects = function(n) {
  this._maxRedirects = n;
  return this;
};
RequestBase.prototype.maxResponseSize = function(n) {
  if (typeof n !== "number") {
    throw new TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};
RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
RequestBase.prototype.send = function(data2) {
  var isObject_ = isObject(data2);
  var type = this._header["content-type"];
  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }
  if (isObject_ && !this._data) {
    if (Array.isArray(data2)) {
      this._data = [];
    } else if (!this._isHost(data2)) {
      this._data = {};
    }
  } else if (data2 && this._data && this._isHost(this._data)) {
    throw new Error("Can't merge these send calls");
  }
  if (isObject_ && isObject(this._data)) {
    for (var key in data2) {
      if (hasOwn$1(data2, key))
        this._data[key] = data2[key];
    }
  } else if (typeof data2 === "string") {
    if (!type)
      this.type("form");
    type = this._header["content-type"];
    if (type)
      type = type.toLowerCase().trim();
    if (type === "application/x-www-form-urlencoded") {
      this._data = this._data ? "".concat(this._data, "&").concat(data2) : data2;
    } else {
      this._data = (this._data || "") + data2;
    }
  } else {
    this._data = data2;
  }
  if (!isObject_ || this._isHost(data2)) {
    return this;
  }
  if (!type)
    this.type("json");
  return this;
};
RequestBase.prototype.sortQuery = function(sort) {
  this._sort = typeof sort === "undefined" ? true : sort;
  return this;
};
RequestBase.prototype._finalizeQueryString = function() {
  var query = this._query.join("&");
  if (query) {
    this.url += (this.url.includes("?") ? "&" : "?") + query;
  }
  this._query.length = 0;
  if (this._sort) {
    var index2 = this.url.indexOf("?");
    if (index2 >= 0) {
      var queryArray = this.url.slice(index2 + 1).split("&");
      if (typeof this._sort === "function") {
        queryArray.sort(this._sort);
      } else {
        queryArray.sort();
      }
      this.url = this.url.slice(0, index2) + "?" + queryArray.join("&");
    }
  }
};
RequestBase.prototype._appendQueryString = function() {
  console.warn("Unsupported");
};
RequestBase.prototype._timeoutError = function(reason, timeout, errno) {
  if (this._aborted) {
    return;
  }
  var error2 = new Error("".concat(reason + timeout, "ms exceeded"));
  error2.timeout = timeout;
  error2.code = "ECONNABORTED";
  error2.errno = errno;
  this.timedout = true;
  this.timedoutError = error2;
  this.abort();
  this.callback(error2);
};
RequestBase.prototype._setTimeouts = function() {
  var self2 = this;
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function() {
      self2._timeoutError("Timeout of ", self2._timeout, "ETIME");
    }, this._timeout);
  }
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function() {
      self2._timeoutError("Response timeout of ", self2._responseTimeout, "ETIMEDOUT");
    }, this._responseTimeout);
  }
};
var utils = utils$1;
var responseBase = ResponseBase;
function ResponseBase() {
}
ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};
ResponseBase.prototype._setHeaderProperties = function(header) {
  var ct = header["content-type"] || "";
  this.type = utils.type(ct);
  var parameters = utils.params(ct);
  for (var key in parameters) {
    if (Object.prototype.hasOwnProperty.call(parameters, key))
      this[key] = parameters[key];
  }
  this.links = {};
  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (_unused) {
  }
};
ResponseBase.prototype._setStatusProperties = function(status) {
  var type = Math.trunc(status / 100);
  this.statusCode = status;
  this.status = this.statusCode;
  this.statusType = type;
  this.info = type === 1;
  this.ok = type === 2;
  this.redirect = type === 3;
  this.clientError = type === 4;
  this.serverError = type === 5;
  this.error = type === 4 || type === 5 ? this.toError() : false;
  this.created = status === 201;
  this.accepted = status === 202;
  this.noContent = status === 204;
  this.badRequest = status === 400;
  this.unauthorized = status === 401;
  this.notAcceptable = status === 406;
  this.forbidden = status === 403;
  this.notFound = status === 404;
  this.unprocessableEntity = status === 422;
};
function _toConsumableArray(arr2) {
  return _arrayWithoutHoles(arr2) || _iterableToArray$1(arr2) || _unsupportedIterableToArray$1(arr2) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr2) {
  if (Array.isArray(arr2))
    return _arrayLikeToArray$1(arr2);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i2 >= o.length)
          return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr2, len2) {
  if (len2 == null || len2 > arr2.length)
    len2 = arr2.length;
  for (var i2 = 0, arr22 = new Array(len2); i2 < len2; i2++) {
    arr22[i2] = arr2[i2];
  }
  return arr22;
}
function Agent() {
  this._defaults = [];
}
var _loop = function _loop2() {
  var fn = _arr[_i];
  Agent.prototype[fn] = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this._defaults.push({
      fn,
      args
    });
    return this;
  };
};
for (var _i = 0, _arr = ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"]; _i < _arr.length; _i++) {
  _loop();
}
Agent.prototype._setDefaults = function(request2) {
  var _iterator = _createForOfIteratorHelper(this._defaults), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var def = _step.value;
      request2[def.fn].apply(request2, _toConsumableArray(def.args));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};
var agentBase = Agent;
(function(module2, exports2) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof2(obj);
  }
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i2 = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i2 >= o.length)
            return { done: true };
          return { done: false, value: o[i2++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s2() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr2, len2) {
    if (len2 == null || len2 > arr2.length)
      len2 = arr2.length;
    for (var i2 = 0, arr22 = new Array(len2); i2 < len2; i2++) {
      arr22[i2] = arr2[i2];
    }
    return arr22;
  }
  var root2;
  if (typeof window !== "undefined") {
    root2 = window;
  } else if (typeof self === "undefined") {
    console.warn("Using browser-only version of superagent in non-browser environment");
    root2 = void 0;
  } else {
    root2 = self;
  }
  var Emitter2 = componentEmitterExports;
  var safeStringify = fastSafeStringify$1;
  var qs2 = lib$3;
  var RequestBase2 = requestBase;
  var _require2 = utils$1, isObject2 = _require2.isObject, mixin = _require2.mixin, hasOwn2 = _require2.hasOwn;
  var ResponseBase2 = responseBase;
  var Agent2 = agentBase;
  function noop2() {
  }
  module2.exports = function(method, url2) {
    if (typeof url2 === "function") {
      return new exports2.Request("GET", method).end(url2);
    }
    if (arguments.length === 1) {
      return new exports2.Request("GET", method);
    }
    return new exports2.Request(method, url2);
  };
  exports2 = module2.exports;
  var request2 = exports2;
  exports2.Request = Request2;
  request2.getXHR = function() {
    if (root2.XMLHttpRequest && (!root2.location || root2.location.protocol !== "file:")) {
      return new XMLHttpRequest();
    }
    throw new Error("Browser-only version of superagent could not find XHR");
  };
  var trim = "".trim ? function(s2) {
    return s2.trim();
  } : function(s2) {
    return s2.replace(/(^\s*|\s*$)/g, "");
  };
  function serialize(object) {
    if (!isObject2(object))
      return object;
    var pairs = [];
    for (var key in object) {
      if (hasOwn2(object, key))
        pushEncodedKeyValuePair(pairs, key, object[key]);
    }
    return pairs.join("&");
  }
  function pushEncodedKeyValuePair(pairs, key, value) {
    if (value === void 0)
      return;
    if (value === null) {
      pairs.push(encodeURI(key));
      return;
    }
    if (Array.isArray(value)) {
      var _iterator = _createForOfIteratorHelper2(value), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var v = _step.value;
          pushEncodedKeyValuePair(pairs, key, v);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else if (isObject2(value)) {
      for (var subkey in value) {
        if (hasOwn2(value, subkey))
          pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), value[subkey]);
      }
    } else {
      pairs.push(encodeURI(key) + "=" + encodeURIComponent(value));
    }
  }
  request2.serializeObject = serialize;
  function parseString(string_) {
    var object = {};
    var pairs = string_.split("&");
    var pair;
    var pos;
    for (var i2 = 0, length_ = pairs.length; i2 < length_; ++i2) {
      pair = pairs[i2];
      pos = pair.indexOf("=");
      if (pos === -1) {
        object[decodeURIComponent(pair)] = "";
      } else {
        object[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
      }
    }
    return object;
  }
  request2.parseString = parseString;
  request2.types = {
    html: "text/html",
    json: "application/json",
    xml: "text/xml",
    urlencoded: "application/x-www-form-urlencoded",
    form: "application/x-www-form-urlencoded",
    "form-data": "application/x-www-form-urlencoded"
  };
  request2.serialize = {
    "application/x-www-form-urlencoded": qs2.stringify,
    "application/json": safeStringify
  };
  request2.parse = {
    "application/x-www-form-urlencoded": parseString,
    "application/json": JSON.parse
  };
  function parseHeader(string_) {
    var lines = string_.split(/\r?\n/);
    var fields = {};
    var index2;
    var line;
    var field;
    var value;
    for (var i2 = 0, length_ = lines.length; i2 < length_; ++i2) {
      line = lines[i2];
      index2 = line.indexOf(":");
      if (index2 === -1) {
        continue;
      }
      field = line.slice(0, index2).toLowerCase();
      value = trim(line.slice(index2 + 1));
      fields[field] = value;
    }
    return fields;
  }
  function isJSON(mime) {
    return /[/+]json($|[^-\w])/i.test(mime);
  }
  function Response(request_) {
    this.req = request_;
    this.xhr = this.req.xhr;
    this.text = this.req.method !== "HEAD" && (this.xhr.responseType === "" || this.xhr.responseType === "text") || typeof this.xhr.responseType === "undefined" ? this.xhr.responseText : null;
    this.statusText = this.req.xhr.statusText;
    var status = this.xhr.status;
    if (status === 1223) {
      status = 204;
    }
    this._setStatusProperties(status);
    this.headers = parseHeader(this.xhr.getAllResponseHeaders());
    this.header = this.headers;
    this.header["content-type"] = this.xhr.getResponseHeader("content-type");
    this._setHeaderProperties(this.header);
    if (this.text === null && request_._responseType) {
      this.body = this.xhr.response;
    } else {
      this.body = this.req.method === "HEAD" ? null : this._parseBody(this.text ? this.text : this.xhr.response);
    }
  }
  mixin(Response.prototype, ResponseBase2.prototype);
  Response.prototype._parseBody = function(string_) {
    var parse4 = request2.parse[this.type];
    if (this.req._parser) {
      return this.req._parser(this, string_);
    }
    if (!parse4 && isJSON(this.type)) {
      parse4 = request2.parse["application/json"];
    }
    return parse4 && string_ && (string_.length > 0 || string_ instanceof Object) ? parse4(string_) : null;
  };
  Response.prototype.toError = function() {
    var req = this.req;
    var method = req.method;
    var url2 = req.url;
    var message = "cannot ".concat(method, " ").concat(url2, " (").concat(this.status, ")");
    var error2 = new Error(message);
    error2.status = this.status;
    error2.method = method;
    error2.url = url2;
    return error2;
  };
  request2.Response = Response;
  function Request2(method, url2) {
    var self2 = this;
    this._query = this._query || [];
    this.method = method;
    this.url = url2;
    this.header = {};
    this._header = {};
    this.on("end", function() {
      var error2 = null;
      var res = null;
      try {
        res = new Response(self2);
      } catch (err) {
        error2 = new Error("Parser is unable to parse the response");
        error2.parse = true;
        error2.original = err;
        if (self2.xhr) {
          error2.rawResponse = typeof self2.xhr.responseType === "undefined" ? self2.xhr.responseText : self2.xhr.response;
          error2.status = self2.xhr.status ? self2.xhr.status : null;
          error2.statusCode = error2.status;
        } else {
          error2.rawResponse = null;
          error2.status = null;
        }
        return self2.callback(error2);
      }
      self2.emit("response", res);
      var new_error;
      try {
        if (!self2._isResponseOK(res)) {
          new_error = new Error(res.statusText || res.text || "Unsuccessful HTTP response");
        }
      } catch (err) {
        new_error = err;
      }
      if (new_error) {
        new_error.original = error2;
        new_error.response = res;
        new_error.status = new_error.status || res.status;
        self2.callback(new_error, res);
      } else {
        self2.callback(null, res);
      }
    });
  }
  Emitter2(Request2.prototype);
  mixin(Request2.prototype, RequestBase2.prototype);
  Request2.prototype.type = function(type) {
    this.set("Content-Type", request2.types[type] || type);
    return this;
  };
  Request2.prototype.accept = function(type) {
    this.set("Accept", request2.types[type] || type);
    return this;
  };
  Request2.prototype.auth = function(user, pass, options2) {
    if (arguments.length === 1)
      pass = "";
    if (_typeof2(pass) === "object" && pass !== null) {
      options2 = pass;
      pass = "";
    }
    if (!options2) {
      options2 = {
        type: typeof btoa === "function" ? "basic" : "auto"
      };
    }
    var encoder = options2.encoder ? options2.encoder : function(string) {
      if (typeof btoa === "function") {
        return btoa(string);
      }
      throw new Error("Cannot use basic auth, btoa is not a function");
    };
    return this._auth(user, pass, options2, encoder);
  };
  Request2.prototype.query = function(value) {
    if (typeof value !== "string")
      value = serialize(value);
    if (value)
      this._query.push(value);
    return this;
  };
  Request2.prototype.attach = function(field, file, options2) {
    if (file) {
      if (this._data) {
        throw new Error("superagent can't mix .send() and .attach()");
      }
      this._getFormData().append(field, file, options2 || file.name);
    }
    return this;
  };
  Request2.prototype._getFormData = function() {
    if (!this._formData) {
      this._formData = new root2.FormData();
    }
    return this._formData;
  };
  Request2.prototype.callback = function(error2, res) {
    if (this._shouldRetry(error2, res)) {
      return this._retry();
    }
    var fn = this._callback;
    this.clearTimeout();
    if (error2) {
      if (this._maxRetries)
        error2.retries = this._retries - 1;
      this.emit("error", error2);
    }
    fn(error2, res);
  };
  Request2.prototype.crossDomainError = function() {
    var error2 = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");
    error2.crossDomain = true;
    error2.status = this.status;
    error2.method = this.method;
    error2.url = this.url;
    this.callback(error2);
  };
  Request2.prototype.agent = function() {
    console.warn("This is not supported in browser version of superagent");
    return this;
  };
  Request2.prototype.ca = Request2.prototype.agent;
  Request2.prototype.buffer = Request2.prototype.ca;
  Request2.prototype.write = function() {
    throw new Error("Streaming is not supported in browser version of superagent");
  };
  Request2.prototype.pipe = Request2.prototype.write;
  Request2.prototype._isHost = function(object) {
    return object && _typeof2(object) === "object" && !Array.isArray(object) && Object.prototype.toString.call(object) !== "[object Object]";
  };
  Request2.prototype.end = function(fn) {
    if (this._endCalled) {
      console.warn("Warning: .end() was called twice. This is not supported in superagent");
    }
    this._endCalled = true;
    this._callback = fn || noop2;
    this._finalizeQueryString();
    this._end();
  };
  Request2.prototype._setUploadTimeout = function() {
    var self2 = this;
    if (this._uploadTimeout && !this._uploadTimeoutTimer) {
      this._uploadTimeoutTimer = setTimeout(function() {
        self2._timeoutError("Upload timeout of ", self2._uploadTimeout, "ETIMEDOUT");
      }, this._uploadTimeout);
    }
  };
  Request2.prototype._end = function() {
    if (this._aborted)
      return this.callback(new Error("The request has been aborted even before .end() was called"));
    var self2 = this;
    this.xhr = request2.getXHR();
    var xhr = this.xhr;
    var data2 = this._formData || this._data;
    this._setTimeouts();
    xhr.addEventListener("readystatechange", function() {
      var readyState = xhr.readyState;
      if (readyState >= 2 && self2._responseTimeoutTimer) {
        clearTimeout(self2._responseTimeoutTimer);
      }
      if (readyState !== 4) {
        return;
      }
      var status;
      try {
        status = xhr.status;
      } catch (_unused) {
        status = 0;
      }
      if (!status) {
        if (self2.timedout || self2._aborted)
          return;
        return self2.crossDomainError();
      }
      self2.emit("end");
    });
    var handleProgress = function handleProgress2(direction, e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
        if (e.percent === 100) {
          clearTimeout(self2._uploadTimeoutTimer);
        }
      }
      e.direction = direction;
      self2.emit("progress", e);
    };
    if (this.hasListeners("progress")) {
      try {
        xhr.addEventListener("progress", handleProgress.bind(null, "download"));
        if (xhr.upload) {
          xhr.upload.addEventListener("progress", handleProgress.bind(null, "upload"));
        }
      } catch (_unused2) {
      }
    }
    if (xhr.upload) {
      this._setUploadTimeout();
    }
    try {
      if (this.username && this.password) {
        xhr.open(this.method, this.url, true, this.username, this.password);
      } else {
        xhr.open(this.method, this.url, true);
      }
    } catch (err) {
      return this.callback(err);
    }
    if (this._withCredentials)
      xhr.withCredentials = true;
    if (!this._formData && this.method !== "GET" && this.method !== "HEAD" && typeof data2 !== "string" && !this._isHost(data2)) {
      var contentType = this._header["content-type"];
      var _serialize = this._serializer || request2.serialize[contentType ? contentType.split(";")[0] : ""];
      if (!_serialize && isJSON(contentType)) {
        _serialize = request2.serialize["application/json"];
      }
      if (_serialize)
        data2 = _serialize(data2);
    }
    for (var field in this.header) {
      if (this.header[field] === null)
        continue;
      if (hasOwn2(this.header, field))
        xhr.setRequestHeader(field, this.header[field]);
    }
    if (this._responseType) {
      xhr.responseType = this._responseType;
    }
    this.emit("request", this);
    xhr.send(typeof data2 === "undefined" ? null : data2);
  };
  request2.agent = function() {
    return new Agent2();
  };
  var _loop3 = function _loop4() {
    var method = _arr2[_i2];
    Agent2.prototype[method.toLowerCase()] = function(url2, fn) {
      var request_ = new request2.Request(method, url2);
      this._setDefaults(request_);
      if (fn) {
        request_.end(fn);
      }
      return request_;
    };
  };
  for (var _i2 = 0, _arr2 = ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"]; _i2 < _arr2.length; _i2++) {
    _loop3();
  }
  Agent2.prototype.del = Agent2.prototype.delete;
  request2.get = function(url2, data2, fn) {
    var request_ = request2("GET", url2);
    if (typeof data2 === "function") {
      fn = data2;
      data2 = null;
    }
    if (data2)
      request_.query(data2);
    if (fn)
      request_.end(fn);
    return request_;
  };
  request2.head = function(url2, data2, fn) {
    var request_ = request2("HEAD", url2);
    if (typeof data2 === "function") {
      fn = data2;
      data2 = null;
    }
    if (data2)
      request_.query(data2);
    if (fn)
      request_.end(fn);
    return request_;
  };
  request2.options = function(url2, data2, fn) {
    var request_ = request2("OPTIONS", url2);
    if (typeof data2 === "function") {
      fn = data2;
      data2 = null;
    }
    if (data2)
      request_.send(data2);
    if (fn)
      request_.end(fn);
    return request_;
  };
  function del(url2, data2, fn) {
    var request_ = request2("DELETE", url2);
    if (typeof data2 === "function") {
      fn = data2;
      data2 = null;
    }
    if (data2)
      request_.send(data2);
    if (fn)
      request_.end(fn);
    return request_;
  }
  request2.del = del;
  request2.delete = del;
  request2.patch = function(url2, data2, fn) {
    var request_ = request2("PATCH", url2);
    if (typeof data2 === "function") {
      fn = data2;
      data2 = null;
    }
    if (data2)
      request_.send(data2);
    if (fn)
      request_.end(fn);
    return request_;
  };
  request2.post = function(url2, data2, fn) {
    var request_ = request2("POST", url2);
    if (typeof data2 === "function") {
      fn = data2;
      data2 = null;
    }
    if (data2)
      request_.send(data2);
    if (fn)
      request_.end(fn);
    return request_;
  };
  request2.put = function(url2, data2, fn) {
    var request_ = request2("PUT", url2);
    if (typeof data2 === "function") {
      fn = data2;
      data2 = null;
    }
    if (data2)
      request_.send(data2);
    if (fn)
      request_.end(fn);
    return request_;
  };
})(client, client.exports);
var clientExports = client.exports;
const request = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
const examples = [
  {
    sketch_id: "example_0",
    code: "JTJGJTJGRmxvciUyMGRlJTIwRnVlZ28lMEElMEFzaGFwZSgyMDAlMkMwLjUlMkMxLjUpJTBBLnNjYWxlKDAuNSUyQzAuNSklMEEuY29sb3IoJTVCMC41JTJDMiU1RC5zbW9vdGgoMSklMkMwLjMlMkMwKSUwQS5yZXBlYXQoMiUyQzIpJTBBLm1vZHVsYXRlU2NhbGUob3NjKDMlMkMwLjUpJTJDLTAuNiklMEEuYWRkKG8wJTJDMC41KSUwQS5zY2FsZSgwLjkpJTBBLm91dCgp"
  },
  {
    sketch_id: "example_3",
    code: "JTJGJTJGJTIwYnklMjBPbGl2aWElMjBKYWNrJTBBJTBBb3NjKDIwJTJDJTIwMC4wMyUyQyUyMDEuNykua2FsZWlkKCkubXVsdChvc2MoMjAlMkMlMjAwLjAwMSUyQyUyMDApLnJvdGF0ZSgxLjU4KSkuYmxlbmQobzAlMkMlMjAwLjk0KS5tb2R1bGF0ZVNjYWxlKG9zYygxMCUyQyUyMDApJTJDLTAuMDMpLnNjYWxlKDAuOCUyQyUyMCgpJTIwJTNEJTNFJTIwKDEuMDUlMjAlMkIlMjAwLjElMjAqJTIwTWF0aC5zaW4oMC4wNSp0aW1lKSkpLm91dChvMCk="
  },
  {
    sketch_id: "example_4",
    code: "JTJGJTJGJTIwYnklMjBOZWxzb24lMjBWZXJhJTBBJTJGJTJGJTIwdHdpdHRlciUzQSUyMCU0MG5lbF9zb25vbG9naWElMEElMEFvc2MoOCUyQy0wLjUlMkMlMjAxKS5jb2xvcigtMS41JTJDJTIwLTEuNSUyQyUyMC0xLjUpLmJsZW5kKG8wKS5yb3RhdGUoLTAuNSUyQyUyMC0wLjUpLm1vZHVsYXRlKHNoYXBlKDQpLnJvdGF0ZSgwLjUlMkMlMjAwLjUpLnNjYWxlKDIpLnJlcGVhdFgoMiUyQyUyMDIpLm1vZHVsYXRlKG8wJTJDJTIwKCklMjAlM0QlM0UlMjBtb3VzZS54JTIwKiUyMDAuMDAwNSkucmVwZWF0WSgyJTJDJTIwMikpLm91dChvMCklMEElMEElMEElMEElMEElMEE="
  },
  {
    sketch_id: "example_6",
    code: "JTJGJTJGJTIwYnklMjBEJUMzJUE5Ym9yYSUyMEZhbGxlaXJvcyUyMEdvbnphbGVzJTBBJTJGJTJGJTIwaHR0cHMlM0ElMkYlMkZ3d3cuZ29uemFsZXNkZWJvcmEuY29tJTJGJTBBJTBBb3NjKDUpLmFkZChub2lzZSg1JTJDJTIwMikpLmNvbG9yKDAlMkMlMjAwJTJDJTIwMykuY29sb3JhbWEoMC40KS5vdXQoKSUwQSUwQSUwQSUwQQ=="
  },
  {
    sketch_id: "example_8",
    code: "JTJGJTJGJTIwYnklMjBSb2RyaWdvJTIwVmVsYXNjbyUwQSUyRiUyRiUyMGh0dHBzJTNBJTJGJTJGeWVjdG8uZ2l0aHViLmlvJTJGJTBBJTBBb3NjKDEwNyUyQyUyMDAlMkMlMjAwLjcpLmNvbG9yKDElMkMlMjAwJTJDJTIwMSkucm90YXRlKDAlMkMlMjAtMC4wOCkubW9kdWxhdGVSb3RhdGUobzElMkMlMjAwLjQpLm91dChvMCklMEFvc2MoMzMpLnJvdGF0ZSgyJTJDJTIwMC44KS5tb2R1bGF0ZVJvdGF0ZShvMCUyQyUyMCgpJTIwJTNEJTNFJTIwKGEuZmZ0JTVCMCU1RCoyKSkub3V0KG8xKSUwQQ=="
  },
  {
    sketch_id: "example_9",
    code: "JTJGJTJGJTIwYnklMjBSb2RyaWdvJTIwVmVsYXNjbyUwQSUyRiUyRiUyMGh0dHBzJTNBJTJGJTJGeWVjdG8uZ2l0aHViLmlvJTJGJTBBJTBBb3NjKDE4JTJDJTIwMC4xJTJDJTIwMCkuY29sb3IoMiUyQyUyMDAuMSUyQyUyMDIpJTBBLm11bHQob3NjKDIwJTJDJTIwMC4wMSUyQyUyMDApKS5yZXBlYXQoMiUyQyUyMDIwKS5yb3RhdGUoMC41KS5tb2R1bGF0ZShvMSklMEEuc2NhbGUoMSUyQyUyMCgpJTIwJTNEJTNFJTIwJTIwKGEuZmZ0JTVCMCU1RCowLjklMjAlMkIlMjAyKSkuZGlmZihvMSkub3V0KG8wKSUwQW9zYygyMCUyQyUyMDAuMiUyQyUyMDApLmNvbG9yKDIlMkMlMjAwLjclMkMlMjAwLjEpLm11bHQob3NjKDQwKSkubW9kdWxhdGVSb3RhdGUobzAlMkMlMjAwLjIpJTBBLnJvdGF0ZSgwLjIpLm91dChvMSk="
  },
  {
    sketch_id: "example_10",
    code: "JTJGJTJGJTIwYnklMjBaYWNoJTIwS3JhbGwlMEElMkYlMkYlMjBodHRwJTNBJTJGJTJGemFjaGtyYWxsLm9ubGluZSUyRiUwQSUwQW9zYyglMjAyMTUlMkMlMjAwLjElMkMlMjAyJTIwKSUwQS5tb2R1bGF0ZSglMEElMjAlMjBvc2MoJTIwMiUyQyUyMC0wLjMlMkMlMjAxMDAlMjApJTBBJTIwJTIwLnJvdGF0ZSgxNSklMEEpJTBBLm11bHQoJTBBJTIwJTIwb3NjKCUyMDIxNSUyQyUyMC0wLjElMkMlMjAyKSUwQSUyMCUyMC5waXhlbGF0ZSglMjA1MCUyQyUyMDUwJTIwKSUwQSklMEEuY29sb3IoJTIwMC45JTJDJTIwMC4wJTJDJTIwMC45JTIwKSUwQS5tb2R1bGF0ZSglMEElMjAlMjBvc2MoJTIwNiUyQyUyMC0wLjElMjApJTBBJTIwJTIwLnJvdGF0ZSglMjA5JTIwKSUwQSklMEEuYWRkKCUwQSUyMCUyMG9zYyglMjAxMCUyQyUyMC0wLjklMkMlMjA5MDAlMjApJTBBJTIwJTIwLmNvbG9yKDElMkMwJTJDMSklMEEpJTBBLm11bHQoJTBBJTIwJTIwc2hhcGUoOTAwJTJDJTIwMC4yJTJDJTIwMSklMEElMjAlMjAubHVtYSgpJTBBJTIwJTIwLnJlcGVhdFgoMiklMEElMjAlMjAucmVwZWF0WSgyKSUwQSUyMCUyMC5jb2xvcmFtYSgxMCklMEEpJTBBLm1vZHVsYXRlKCUwQSUyMCUyMG9zYyglMjA5JTJDJTIwLTAuMyUyQyUyMDkwMCUyMCklMEElMjAlMjAucm90YXRlKCUyMDYlMjApJTBBKSUwQS5hZGQoJTBBJTIwJTIwb3NjKDQlMkMlMjAxJTJDJTIwOTApJTBBJTIwJTIwLmNvbG9yKDAuMiUyQzAlMkMxKSUwQSklMEEub3V0KCklMEE="
  },
  {
    sketch_id: "example_11",
    code: "JTJGJTJGJTIwYnklMjBaYWNoJTIwS3JhbGwlMEElMkYlMkYlMjBodHRwJTNBJTJGJTJGemFjaGtyYWxsLm9ubGluZSUyRiUwQSUwQW9zYygxMCUyQyUyMDAuOSUyQyUyMDMwMCklMEEuY29sb3IoMC45JTJDJTIwMC43JTJDJTIwMC44KSUwQS5kaWZmKCUwQSUyMCUyMG9zYyg0NSUyQyUyMDAuMyUyQyUyMDEwMCklMEElMjAlMjAuY29sb3IoMC45JTJDJTIwMC45JTJDJTIwMC45KSUwQSUyMCUyMC5yb3RhdGUoMC4xOCklMEElMjAlMjAucGl4ZWxhdGUoMTIpJTBBJTIwJTIwLmthbGVpZCgpJTBBKSUwQS5zY3JvbGxYKDEwKSUwQS5jb2xvcmFtYSgpJTBBLmx1bWEoKSUwQS5yZXBlYXRYKDQpJTBBLnJlcGVhdFkoNCklMEEubW9kdWxhdGUoJTBBJTIwJTIwb3NjKDElMkMlMjAtMC45JTJDJTIwMzAwKSUwQSklMEEuc2NhbGUoMiklMEEub3V0KCklMEE="
  },
  {
    sketch_id: "example_13",
    code: "JTJGJTJGJTIwYWNpZCUyMGJ1cyUyMHNlYXQlMEElMkYlMkYlMjBieSUyMFdpbGwlMjBIdW1waHJleXMlMEElMkYlMkYlMjBodHRwcyUzQSUyRiUyRmdpdGh1Yi5jb20lMkZUaGVXaXNweSUwQSUwQW9zYygxMDUpLmNvbG9yKDAuNSUyQzAuMSUyQzAuOCkucm90YXRlKDAuMTElMkMlMjAwLjEpLm1vZHVsYXRlKG9zYygxMCkucm90YXRlKDAuMykuYWRkKG8wJTJDJTIwMC4xKSkuYWRkKG9zYygyMCUyQzAuMDElMkMxKS5jb2xvcigwJTJDMC44JTJDMSkpLm91dChvMCklMEFvc2MoNTAlMkMwLjA1JTJDJTIwMC43KS5jb2xvcigxJTJDMC43JTJDMC41KS5kaWZmKG8wKS5tb2R1bGF0ZShvMSUyQzAuMDUpLm91dChvMSklMEFyZW5kZXIobzEp"
  },
  {
    sketch_id: "example_14",
    code: "JTJGJTJGJTIwYnklMjBPbGl2aWElMjBKYWNrJTBBJTJGJTJGJTIwJTQwX29qYWNrXyUwQSUwQW9zYygyMCUyQyUyMDAuMDElMkMlMjAxLjEpJTBBJTA5LmthbGVpZCg1KSUwQSUwOS5jb2xvcigyLjgzJTJDMC45MSUyQzAuMzkpJTBBJTA5LnJvdGF0ZSgwJTJDJTIwMC4xKSUwQSUwOS5tb2R1bGF0ZShvMCUyQyUyMCgpJTIwJTNEJTNFJTIwbW91c2UueCUyMColMjAwLjAwMDMpJTBBJTA5LnNjYWxlKDEuMDEpJTBBJTIwJTIwJTA5Lm91dChvMCk="
  },
  {
    sketch_id: "example_15",
    code: "JTJGJTJGJTIwYnklMjBPbGl2aWElMjBKYWNrJTBBJTJGJTJGJTIwaHR0cHMlM0ElMkYlMkZvamFjay5naXRodWIuaW8lMEElMEFvc2MoMTAwJTJDJTIwMC4wMSUyQyUyMDEuNCklMEElMDkucm90YXRlKDAlMkMlMjAwLjEpJTBBJTA5Lm11bHQob3NjKDEwJTJDJTIwMC4xKS5tb2R1bGF0ZShvc2MoMTApLnJvdGF0ZSgwJTJDJTIwLTAuMSklMkMlMjAxKSklMEElMDkuY29sb3IoMi44MyUyQzAuOTElMkMwLjM5KSUwQSUyMCUyMC5vdXQobzAp"
  },
  {
    sketch_id: "example_16",
    code: "JTJGJTJGJTIwYnklMjBPbGl2aWElMjBKYWNrJTBBJTJGJTJGJTIwaHR0cHMlM0ElMkYlMkZvamFjay5naXRodWIuaW8lMEElMEFvc2MoNCUyQyUyMDAuMSUyQyUyMDAuOCkuY29sb3IoMS4wNCUyQzAlMkMlMjAtMS4xKS5yb3RhdGUoMC4zMCUyQyUyMDAuMSkucGl4ZWxhdGUoMiUyQyUyMDIwKS5tb2R1bGF0ZShub2lzZSgyLjUpJTJDJTIwKCklMjAlM0QlM0UlMjAxLjUlMjAqJTIwTWF0aC5zaW4oMC4wOCUyMColMjB0aW1lKSkub3V0KG8wKQ=="
  },
  {
    sketch_id: "example_17",
    code: "JTJGJTJGJTIwbW9pcmUlMEElMkYlMkYlMjBieSUyME9saXZpYSUyMEphY2slMEElMkYlMkYlMjB0d2l0dGVyJTNBJTIwJTQwX29qYWNrXyUwQSUwQXBhdHRlcm4lMjAlM0QlMjAoKSUyMCUzRCUzRSUyMG9zYygyMDAlMkMlMjAwKS5rYWxlaWQoMjAwKS5zY2FsZSgxJTJDJTIwMC40KSUwQSUyRiUyRiUwQXBhdHRlcm4oKSUwQSUyMCUyMC5zY3JvbGxYKDAuMSUyQyUyMDAuMDEpJTBBJTIwJTIwLm11bHQocGF0dGVybigpKSUwQSUyMCUyMC5vdXQoKQ=="
  },
  {
    sketch_id: "example_18",
    code: "JTJGJTJGJTIwYnklMjBPbGl2aWElMjBKYWNrJTBBJTJGJTJGJTIwaHR0cHMlM0ElMkYlMkZvamFjay5naXRodWIuaW8lMEElMEFvc2MoNiUyQyUyMDAlMkMlMjAwLjgpJTBBJTIwJTIwLmNvbG9yKDEuMTQlMkMlMjAwLjYlMkMuODApJTBBJTIwJTIwLnJvdGF0ZSgwLjkyJTJDJTIwMC4zKSUwQSUyMCUyMC5waXhlbGF0ZSgyMCUyQyUyMDEwKSUwQSUyMCUyMC5tdWx0KG9zYyg0MCUyQyUyMDAuMDMpLnRocmVzaCgwLjQpLnJvdGF0ZSgwJTJDJTIwLTAuMDIpKSUwQSUyMCUyMC5tb2R1bGF0ZVJvdGF0ZShvc2MoMjAlMkMlMjAwKS50aHJlc2goMC4zJTJDJTIwMC42KSUyQyUyMCgpJTIwJTNEJTNFJTIwMC4xJTIwJTJCJTIwbW91c2UueCUyMColMjAwLjAwMiklMEElMjAlMjAub3V0KG8wKQ=="
  },
  {
    sketch_id: "rangga_0",
    code: "JTJGJTJGJTIwRHJlYW15JTIwRGlhbW9uZCUwQSUyRiUyRiUyMGJ5JTIwUmFuZ2dhJTIwUHVybmFtYSUyMEFqaSUwQSUyRiUyRiUyMGh0dHBzJTNBJTJGJTJGcmFuZ2dhcHVybmFtYWFqaTEud2l4c2l0ZS5jb20lMkZwb3J0Zm9saW8lMEElMEFvc2MoNyUyQy0wLjEyNSkubW9kdWxhdGUodm9yb25vaSgxKSkuZGlmZih2b3Jvbm9pKDEpLm11bHQoZ3JhZGllbnQoLTEpLmx1bWEoMC4xMjUpKSklMEElMjAlMjAubHVtYSgwLjEyNSklMEElMjAlMjAuYWRkKHNoYXBlKDclMkMlMjAwLjUpJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwLm11bHQodm9yb25vaSgxMCUyQzIpLmJsZW5kKG8wKS5kaWZmKGdyYWRpZW50KDEpKS5tb2R1bGF0ZSh2b3Jvbm9pKCkpKSklMEElMjAlMjAuc2Nyb2xsWSgtMC4xKSUwQSUyMCUyMC5zY3JvbGxYKDAuMTI1KSUwQSUyMCUyMC5ibGVuZChvMCklMEElMjAlMjAuYmxlbmQobzApJTBBJTIwJTIwLm91dCgpJTBB"
  },
  {
    sketch_id: "rangga_1",
    code: "JTJGJTJGJTIwVGFnJTIwJTI2JTIwU3dlZXAlMEElMkYlMkYlMjBieSUyMFJhbmdnYSUyMFB1cm5hbWElMjBBamklMEElMkYlMkYlMjBodHRwcyUzQSUyRiUyRnJhbmdnYXB1cm5hbWFhamkxLndpeHNpdGUuY29tJTJGcG9ydGZvbGlvJTBBJTBBb3NjKDUlMkMwLjEyNSkuY29sb3JhbWEoMSklMEElMjAlMjAubHVtYSgwLjEyNSkuYWRkKHNoYXBlKDElMkMwLjUpLmx1bWEoMikuZGlmZihncmFkaWVudCgxKSkpJTBBJTIwJTIwLmRpZmYob3NjKC0xJTJDLTAuMjUpKS5ibGVuZChvMCkuY29sb3IoMCUyQzIuNSUyQzEuNzUpJTBBJTIwJTIwLm91dCgp"
  },
  {
    sketch_id: "rangga_2",
    code: "JTJGJTJGJTIwTW9ub2Nocm9tZSUyME1lbW9hciUwQSUyRiUyRiUyMGJ5JTIwUmFuZ2dhJTIwUHVybmFtYSUyMEFqaSUwQSUyRiUyRiUyMGh0dHBzJTNBJTJGJTJGcmFuZ2dhcHVybmFtYWFqaTEud2l4c2l0ZS5jb20lMkZwb3J0Zm9saW8lMEElMEF2b3Jvbm9pKDUwJTJDMSklMEElMjAlMjAubHVtYSgwLjUpLmFkZChzaGFwZSgxJTJDMSkubHVtYSgxKSklMEElMjAlMjAubW9kdWxhdGUob3NjKC0xMDAwJTJDLTEpJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwLm1vZHVsYXRlKG9zYygpLmx1bWEoKSkpJTBBJTIwJTIwLmJsZW5kKG8wKSUwQSUyMCUyMC5ibGVuZChvMCklMEElMjAlMjAuYmxlbmQobzApJTBBJTIwJTIwLmJsZW5kKG8wKSUwQSUyMCUyMC5vdXQoKQ=="
  },
  {
    sketch_id: "rangga_3",
    code: "JTJGJTJGJTIwR2FsYXh5JTIwVHJpcCUwQSUyRiUyRiUyMGJ5JTIwUmFuZ2dhJTIwUHVybmFtYSUyMEFqaSUwQSUyRiUyRiUyMGh0dHBzJTNBJTJGJTJGcmFuZ2dhcHVybmFtYWFqaTEud2l4c2l0ZS5jb20lMkZwb3J0Zm9saW8lMEElMEFzaGFwZSgxJTJDMSklMEElMjAlMjAubXVsdCh2b3Jvbm9pKDEwMDAlMkMyKSUwQSUyMCUyMC5ibGVuZChvMCkubHVtYSgpKSUwQSUyMCUyMC5hZGQoc2hhcGUoMyUyQzAuMTI1KSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMC5yb3RhdGUoMSUyQzEpLm11bHQodm9yb25vaSgxMDAwJTJDMSkubHVtYSgpKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMC5yb3RhdGUoMS41KSkuc2Nyb2xsWCglNUIwLjElMkMtMC4wNjI1JTJDMC4wMDUlMkMwLjAwMDAxJTVEJTJDMCklMEElMjAlMjAuc2Nyb2xsWSglNUIwLjElMkMtMC4wNjI1JTJDMC4wMDUlMkMwLjAwMDAxJTVEJTJDMCklMEElMjAlMjAub3V0KCk="
  },
  {
    sketch_id: "rangga_4",
    code: "JTJGJTJGJTIwU3VtZXQlMEElMkYlMkYlMjBieSUyMFJhbmdnYSUyMFB1cm5hbWElMjBBamklMEElMkYlMkYlMjBodHRwcyUzQSUyRiUyRnJhbmdnYXB1cm5hbWFhamkxLndpeHNpdGUuY29tJTJGcG9ydGZvbGlvJTBBJTBBb3NjKDAuNSUyQzEuMjUpLm11bHQoc2hhcGUoMSUyQzAuMDkpLnJvdGF0ZSgxLjUpKSUwQSUyMCUyMC5kaWZmKGdyYWRpZW50KCkpJTBBJTIwJTIwLmFkZChzaGFwZSgyJTJDMikuYmxlbmQoZ3JhZGllbnQoMSkpKSUwQSUyMCUyMC5tb2R1bGF0ZShub2lzZSgpJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwLm1vZHVsYXRlKG5vaXNlKCkuc2Nyb2xsWSgxJTJDMC4wNjI1KSkpJTBBJTIwJTIwLmJsZW5kKG8wKSUwQSUyMCUyMC5jb2xvcigxJTJDLTAuNSUyQy0wLjc1KSUwQSUyMCUyMC5vdXQoKQ=="
  },
  {
    sketch_id: "marianne_0",
    code: "JTJGJTJGcG9ydCUwQSUyRiUyRmJ5JTIwTWFyaWFubmUlMjBUZWl4aWRvJTBBJTJGJTJGaHR0cHMlM0ElMkYlMkZtYXJpYW5uZXRlaXhpZG8uZ2l0aHViLmlvJTJGJTBBJTBBb3NjKDUlMkMlMjAwLjklMkMlMjAwLjAwMSklMEElMjAlMjAlMjAlMjAua2FsZWlkKCU1QjMlMkM0JTJDNSUyQzclMkM4JTJDOSUyQzEwJTVELmZhc3QoMC4xKSklMEElMjAlMjAlMjAlMjAuY29sb3IoMC41JTJDJTIwMC4zKSUwQSUyMCUyMCUyMCUyMC5jb2xvcmFtYSgwLjQpJTBBJTIwJTIwJTIwJTIwLnJvdGF0ZSgwLjAwOSUyQygpJTNEJTNFTWF0aC5zaW4odGltZSkqJTIwLTAuMDAxJTIwKSUwQSUyMCUyMCUyMCUyMC5tb2R1bGF0ZVJvdGF0ZShvMCUyQygpJTNEJTNFTWF0aC5zaW4odGltZSklMjAqJTIwMC4wMDMpJTBBJTIwJTIwJTIwJTIwLm1vZHVsYXRlKG8wJTJDJTIwMC45KSUwQSUyMCUyMCUyMCUyMC5zY2FsZSgwLjkpJTBBJTIwJTIwJTIwJTIwLm91dChvMCklMEElMEE="
  },
  {
    sketch_id: "marianne_1",
    code: "JTJGJTJGUGl4ZWxzY2FwZSUwQSUyRiUyRk1hcmlhbm5lJTIwVGVpeGlkbyUwQSUyRiUyRmh0dHBzJTNBJTJGJTJGZ2l0aHViLmNvbSUyRk1hcmlhbm5lVGVpeGlkbyUwQSUwQXNyYyhvMCklMEElMjAuc2F0dXJhdGUoMS4wMSklMEElMjAuc2NhbGUoLjk5OSklMEElMjAuY29sb3IoMS4wMSUyQzEuMDElMkMxLjAxKSUwQSUyMC5odWUoLjAxKSUwQSUyMC5tb2R1bGF0ZUh1ZShzcmMobzEpLmh1ZSguMykucG9zdGVyaXplKC0xKS5jb250cmFzdCguNyklMkMyKSUwQSUyMCUyMC5sYXllcihzcmMobzEpJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwLmx1bWEoKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMC5tdWx0KGdyYWRpZW50KDEpJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwLnNhdHVyYXRlKC45KSkpJTBBJTIwJTIwLm91dChvMCklMEElMEFub2lzZSgxJTJDJTIwLjIpJTBBJTIwJTIwLnJvdGF0ZSgyJTJDLjUpJTBBJTIwJTIwLmxheWVyKHNyYyhvMCklMEElMjAlMjAuc2Nyb2xsWCguMikpJTBBJTIwJTIwLm91dChvMSklMEElMEFyZW5kZXIobzAp"
  },
  {
    sketch_id: "naoto_0",
    code: "JTJGJTJGJTIwJTQwbmFvdG9faGllZGElMEFvc2MoMjAlMkMlMjAwLjElMkMlMjAwKS5jb2xvcigwJTJDJTIwMSUyQyUyMDIpLnJvdGF0ZSgxLjU3JTJGMikub3V0KG8xKSUwQW9zYygzMCUyQyUyMDAuMDElMkMlMjAwKS5jb2xvcigyJTJDJTIwMC43JTJDJTIwMSkubW9kdWxhdGUobzElMkMlMjAwKS5hZGQobzElMkMxKS5tb2R1bGF0ZVBpeGVsYXRlKG8xJTJDMSUyQzEwKS5vdXQobzAp"
  },
  {
    sketch_id: "naoto_1",
    code: "JTJGJTJGJTIwJTQwbmFvdG9faGllZGElMEFzb2xpZCgwLjIlMkMwLjYlMkMwLjkpLmxheWVyKG9zYygzMS40JTJDMCkudGhyZXNoKDAuNykubHVtYSgpLm1vZHVsYXRlKG9zYyg0JTJDMSkucm90YXRlKDEpJTJDMC4wNSkuY29sb3IoMCUyQzAlMkMwKSkubGF5ZXIob3NjKDMxLjQlMkMwKS50aHJlc2goMC43KS5sdW1hKCkubW9kdWxhdGUob3NjKDQlMkMxKS5yb3RhdGUoMSklMkMwLjEpKS5vdXQoKQ=="
  },
  {
    sketch_id: "ritchse_0",
    code: "JTJGJTJGcmFuZG9tJTIwdHJ5cG9waG9iaWElMjAtJTIwY2hhbmdlcyUyMGV2ZXJ5dGltZSUyMHlvdSUyMGxvYWQlMjBpdCElMEElMkYlMkZieSUyMFJpdGNoc2UlMEElMkYlMkZpbnN0YWdyYW0uY29tJTJGcml0Y2hzZSUwQSUyMCUwQWZ1bmN0aW9uJTIwcihtaW4lM0QwJTJDbWF4JTNEMSklMjAlN0IlMjByZXR1cm4lMjBNYXRoLnJhbmRvbSgpKihtYXgtbWluKSUyQm1pbiUzQiUyMCU3RCUwQSUyMCUwQXNvbGlkKDElMkMxJTJDMSklMEElMjAlMjAlMDkuZGlmZihzaGFwZSglNUI0JTJDNCUyQzQlMkMyNCU1RC5zbW9vdGgoKS5mYXN0KC41KSUyQ3IoMC42JTJDMC45MyklMkMuMDkpLnJlcGVhdCgyMCUyQzEwKSklMEElMDkubW9kdWxhdGVTY2FsZShvc2MoOCkucm90YXRlKHIoLS41JTJDLjUpKSUyQy41MiklMEElMDkuYWRkKCUwQSUyMCUyMCUwOSUwOXNyYyhvMCkuc2NhbGUoMC45NjUpLnJvdGF0ZSguMDEyKihNYXRoLnJvdW5kKHIoLTIlMkMxKSkpKSUwQSUyMCUyMCUwOSUwOS5jb2xvcihyKCklMkNyKCklMkNyKCkpJTBBJTIwJTIwJTIwJTIwJTA5Lm1vZHVsYXRlUm90YXRlKG8wJTJDcigwJTJDMC41KSklMEElMjAlMjAlMDklMDkuYnJpZ2h0bmVzcyguMTUpJTBBJTIwJTIwJTA5JTA5JTJDLjcpJTBBJTA5Lm91dCgp"
  },
  {
    sketch_id: "ritchse_1",
    code: "JTJGJTJGY29ycnVwdGVkJTIwc2NyZWVuc2F2ZXIlMEElMkYlMkZieSUyMFJpdGNoc2UlMEElMkYlMkZpbnN0YWdyYW0uY29tJTJGcml0Y2hzZSUwQSUyMCUwQXZvcm9ub2koMzUwJTJDMC4xNSklMEElMjAlMjAlMDkubW9kdWxhdGVTY2FsZShvc2MoOCkucm90YXRlKE1hdGguc2luKHRpbWUpKSUyQy41KSUwQSUyMCUyMCUwOS50aHJlc2goLjgpJTBBJTA5Lm1vZHVsYXRlUm90YXRlKG9zYyg3KSUyQy40KSUwQSUwOS50aHJlc2goLjcpJTBBJTIwJTIwJTA5LmRpZmYoc3JjKG8wKS5zY2FsZSgxLjgpKSUwQSUwOS5tb2R1bGF0ZVNjYWxlKG9zYygyKS5tb2R1bGF0ZVJvdGF0ZShvMCUyQy43NCkpJTBBJTA5LmRpZmYoc3JjKG8wKS5yb3RhdGUoJTVCLS4wMTIlMkMuMDElMkMtLjAwMiUyQzAlNUQpLnNjcm9sbFkoMCUyQyU1Qi0xJTJGMTk5ODAwJTJDMCU1RC5mYXN0KDAuNykpKSUwQSUwOS5icmlnaHRuZXNzKCU1Qi0uMDIlMkMtLjE3JTVELnNtb290aCgpLmZhc3QoLjUpKSUwQSUwOS5vdXQoKQ=="
  },
  {
    sketch_id: "ritchse_2",
    code: "JTJGJTJGdHJvcGljYWwlMjBqdWljZSUwQSUyRiUyRmJ5JTIwUml0Y2hzZSUwQSUyRiUyRmluc3RhZ3JhbS5jb20lMkZyaXRjaHNlJTBBJTIwJTBBdm9yb25vaSgyJTJDMC4zJTJDMC4yKS5zaGlmdCgwLjUpJTBBLm1vZHVsYXRlUGl4ZWxhdGUodm9yb25vaSg0JTJDMC4yKSUyQzMyJTJDMiklMEEuc2NhbGUoKCklM0QlM0UxJTJCKE1hdGguc2luKHRpbWUqMi41KSowLjA1KSklMEEuZGlmZih2b3Jvbm9pKDMpLnNoaWZ0KDAuNikpJTBBLmRpZmYob3NjKDIlMkMwLjE1JTJDMS4xKS5yb3RhdGUoKSklMEEuYnJpZ2h0bmVzcygwLjEpLmNvbnRyYXN0KDEuMikuc2F0dXJhdGUoMS4yKSUwQSUwOS5vdXQoKSUwQXNwZWVkJTIwJTNEJTIwMC44"
  },
  {
    sketch_id: "ritchse_3",
    code: "JTJGJTJGdHJ5aW5nJTIwdG8lMjBnZXQlMjBjbG9zZXIlMEElMkYlMkZieSUyMFJpdGNoc2UlMEElMkYlMkZpbnN0YWdyYW0uY29tJTJGcml0Y2hzZSUwQSUyMCUwQW9zYyg2MCUyQy0wLjAxNSUyQzAuMykuZGlmZihvc2MoNjAlMkMwLjA4KS5yb3RhdGUoTWF0aC5QSSUyRjIpKSUwQSUwOS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDMuNSUyQzAuMjUpLm1vZHVsYXRlU2NhbGUob3NjKDE1KS5yb3RhdGUoKCklM0QlM0VNYXRoLnNpbih0aW1lJTJGMikpKSUyQzAuNiklMEElMDkuY29sb3IoMSUyQzAuNSUyQzAuNCkuY29udHJhc3QoMS40KSUwQSUwOS5hZGQoc3JjKG8wKS5tb2R1bGF0ZShvMCUyQy4wNCklMkMuNiklMEElMDkuaW52ZXJ0KCkuYnJpZ2h0bmVzcygwLjEpLmNvbnRyYXN0KDEuMiklMEElMDkubW9kdWxhdGVTY2FsZShvc2MoMiklMkMtMC4yKSUwQSUyMCUyMC5vdXQoKQ=="
  },
  {
    sketch_id: "ritchse_4",
    code: "JTJGJTJGJTIwZGlzaW50ZWdyYXRpb24lMEElMkYlMkYlMjBieSUyMFJpdGNoc2UlMEElMkYlMkYlMjBpbnN0YWdyYW0uY29tJTJGcml0Y2hzZSUwQSUyMCUwQW9zYyg1JTJDLjEpLm1vZHVsYXRlKG5vaXNlKDYpJTJDLjIyKS5kaWZmKG8wKSUwQSUyMCUyMCUwOS5tb2R1bGF0ZVNjcm9sbFkob3NjKDIpLm1vZHVsYXRlKG9zYygpLnJvdGF0ZSgpJTJDLjExKSklMEElMDkuc2NhbGUoLjcyKS5jb2xvcigwLjk5JTJDMS4wMTQlMkMxKSUwQSUyMCUyMCUwOS5vdXQoKQ==  "
  },
  {
    sketch_id: "flor_0",
    code: "JTJGJTJGRmxvciUyMGRlJTIwRnVlZ28lMEElMkYlMkZodHRwcyUzQSUyRiUyRmZsb3JkZWZ1ZWdvLmdpdGh1Yi5pbyUyRiUwQW9zYygzMCUyQzAuMDElMkMxKSUwQS5tdWx0KG9zYygyMCUyQy0wLjElMkMxKS5tb2R1bGF0ZShub2lzZSgzJTJDMSkpLnJvdGF0ZSgwLjcpKSUwQS5wb3N0ZXJpemUoJTVCMyUyQzEwJTJDMiU1RC5mYXN0KDAuNSkuc21vb3RoKDEpKSUwQS5tb2R1bGF0ZVJvdGF0ZShvMCUyQygpJTNEJTNFbW91c2UueCowLjAwMyklMEEub3V0KCk= "
  },
  {
    sketch_id: "mahalia_0",
    code: "JTJGJTJGJTIwTWFoYWxpYSUyMEgtUiUwQSUyRiUyRiUyMElHJTNBJTIwJTQwbW1faHJfJTBBJTBBc2hhcGUoMjAlMkMwLjElMkMwLjAxKSUwQSUyMCUyMC5zY2FsZSgoKSUyMCUzRCUzRSUyME1hdGguc2luKHRpbWUpKjMpJTBBJTIwJTIwLnJlcGVhdCgoKSUyMCUzRCUzRSUyME1hdGguc2luKHRpbWUpKjEwKSUwQSUyMCUyMC5tb2R1bGF0ZVJvdGF0ZShvMCklMEElMjAlMjAuc2NhbGUoKCklMjAlM0QlM0UlMjBNYXRoLnNpbih0aW1lKSoyKSUwQSUyMCUyMC5tb2R1bGF0ZShub2lzZSgyJTJDMCkpJTBBJTIwJTIwLnJvdGF0ZSgwLjElMkMlMjAwLjkpJTBBLm91dChvMCklMEElMEFzcmMobzApJTBBLm1vZHVsYXRlKG9zYyg1MDAlMkMwJTJDMCkpJTBBLm91dChvMSklMEElMEFzcmMobzEpJTBBLm1vZHVsYXRlS2FsZWlkKHZvcm9ub2koKCklMjAlM0QlM0UlMjBNYXRoLnNpbih0aW1lKSozJTJDMC4xJTJDMC4wMSklMkMoKSUyMCUzRCUzRSUyME1hdGguc2luKHRpbWUpKjMpJTBBLnNjYWxlKCgpJTIwJTNEJTNFJTIwTWF0aC5zaW4odGltZSkqMyklMEEub3V0KG8yKSUwQSUwQXJlbmRlcihvMik="
  },
  {
    sketch_id: "mahalia_1",
    code: "JTJGJTJGJTIwTWFoYWxpYSUyMEgtUiUwQSUyRiUyRiUyMElHJTNBJTIwJTQwbW1faHJfJTBBJTBBc2hhcGUoKCklMjAlM0QlM0UlMjBNYXRoLnNpbih0aW1lKSUyQjEqMiklMEEucm90YXRlKCgpJTIwJTNEJTNFJTIwTWF0aC5QSSUyMColMjBtb3VzZS54JTIwJTJGMTgwKSUwQS5yZXBlYXRYKDMpJTBBLnJlcGVhdFkoKCklM0QlM0VNYXRoLnNpbih0aW1lKSo1KSUwQS5zY2FsZSgoKSUyMCUzRCUzRSUyME1hdGguUEklMkY0KSUwQS5ibGVuZChzcmMobzApLmNvbG9yKDElMkMwJTJDMCkpJTBBLm1vZHVsYXRlKG9zYygyMCUyQyUyMDAlMkMuNCkpJTBBLmthbGVpZCgyKSUwQSUyMC5vdXQobzApJTBBJTBBcmVuZGVyKG8wKQ=="
  },
  {
    sketch_id: "mahalia_2",
    code: "JTJGJTJGJTIwVmVsdmV0JTIwUG9vbCUwQSUyRiUyRiUyMGJ5JTIwTWFoYWxpYSUyMEgtUiUwQSUyRiUyRiUyMElHJTNBJTIwbW1faHJfJTBBJTBBJTBBbm9pc2UoKSUwQS5jb2xvcigoKSUyMCUzRCUzRSUyMGEuZmZ0JTVCMiU1RCoyJTJDMCUyQy42KSUwQS5tb2R1bGF0ZShub2lzZSgoKSUyMCUzRCUzRSUyMGEuZmZ0JTVCMCU1RCoxMCkpJTBBLnNjYWxlKCgpJTNEJTNFJTIwYS5mZnQlNUIyJTVEKjUpJTBBLmxheWVyKCUwQSUyMCUyMHNyYyhvMCklMEElMjAlMjAubWFzayhvc2MoMTApLm1vZHVsYXRlUm90YXRlKG9zYygpJTJDOTAlMkMwKSklMEElMjAlMjAuc2NhbGUoKCklMjAlM0QlM0UlMjBhLmZmdCU1QjAlNUQqMiklMEElMjAlMjAubHVtYSgwLjIlMkMwLjMpJTBBKSUwQS5ibGVuZChvMCklMEEub3V0KG8wKSUwQSUwQW9zYygpJTBBLm1vZHVsYXRlKG5vaXNlKCgpJTIwJTNEJTNFJTIwYS5mZnQlNUIxJTVEJTJCNSkpJTBBLmNvbG9yKDElMkMwJTJDMCklMEEub3V0KG8xKSUwQSUwQXNyYyhvMCklMEEubW9kdWxhdGUobzEpJTBBLmxheWVyKCUwQSUyMCUyMHNyYyhvMSklMEElMjAlMjAubWFzayhvMSklMEElMjAlMjAuc2F0dXJhdGUoNyklMEEpJTBBLm1vZHVsYXRlUm90YXRlKG8xKSUwQS5yb3RhdGUoKCU3QnRpbWUlN0QpJTIwJTNEJTNFJTIwdGltZSUyNTM2MCowLjA1KSUwQS5vdXQobzIpJTBBJTBBcmVuZGVyKG8yKQ=="
  },
  {
    sketch_id: "mahalia_3",
    code: "JTJGJTJGJTIwYnklMjBNYWhhbGlhJTIwSC1SJTBBJTJGJTJGJTIwSUclM0ElMjBtbV9ocl8lMEElMEFzaGFwZSgoKSUzRCUzRU1hdGguc2luKHRpbWUpJTJCMSozJTJDJTIwLjUlMkMuMDEpJTBBLnJlcGVhdCg1JTJDMyUyQyUyMCgpJTNEJTNFYS5mZnQlNUIwJTVEKjIlMkMlMjAoKSUzRCUzRWEuZmZ0JTVCMSU1RCoyKSUwQS5zY3JvbGxZKC41JTJDMC4xKSUwQS5sYXllciglMEElMjAlMjBzcmMobzEpJTBBJTIwJTIwLm1hc2sobzApJTBBJTIwJTIwLmx1bWEoLjAxJTJDJTIwLjEpJTBBJTIwJTIwLmludmVydCguMiklMEEpJTBBLm1vZHVsYXRlKG8xJTJDLjAyKSUwQS5vdXQobzApJTBBJTBBb3NjKDQwJTJDJTIwMC4wOSUyQyUyMDAuOSklMEEuY29sb3IoLjklMkMwJTJDNSklMEEubW9kdWxhdGUob3NjKDEwKS5yb3RhdGUoMSUyQyUyMDAuNSkpJTBBLnJvdGF0ZSgxJTJDJTIwMC4yKSUwQS5vdXQobzEpJTBBJTBBcmVuZGVyKG8wKSUwQSUwQQ=="
  },
  {
    sketch_id: "mahalia_4",
    code: "JTJGJTJGJTIwQ2VsbHVsYXIlMjAlMjYlMjBCbG9idWxhciUwQSUyRiUyRiUyMGJ5JTIwTWFoYWxpYSUyMEgtUiUwQSUyRiUyRiUyMElHJTNBJTIwbW1faHJfJTBBJTBBc3BlZWQlMjAlM0QlMjAwLjMlMEElMEFzaGFwZSgyMCUyQzAuMiUyQzAuMyklMEEuY29sb3IoMC41JTJDMC44JTJDNTApJTBBJTIwJTIwLnNjYWxlKCgpJTIwJTNEJTNFJTIwTWF0aC5zaW4odGltZSklMkIxKjIpJTBBJTIwJTIwLnJlcGVhdCgoKSUyMCUzRCUzRSUyME1hdGguc2luKHRpbWUpKjEwKSUwQSUyMCUyMC5tb2R1bGF0ZVJvdGF0ZShvMCklMEElMjAlMjAuc2NhbGUoKCklMjAlM0QlM0UlMjBNYXRoLnNpbih0aW1lKSUyQjElMjAqMS41KSUwQSUyMCUyMC5tb2R1bGF0ZShub2lzZSgyJTJDMikpJTBBJTIwJTIwLnJvdGF0ZSgxJTJDJTIwLjIpJTBBJTIwJTIwJTJGJTJGJTIwLmludmVydCgyLjQpJTBBLm91dChvMCklMEE="
  },
  {
    sketch_id: "andromeda_0",
    code: "JTJGJTJGJTIwMy4wJTBBJTJGJTJGJTIwYnklMjAlQ0UlOTRORFIwTTNEJUNFJTk0JTBBJTJGJTJGJTIwaHR0cHMlM0ElMkYlMkZ3d3cuaW5zdGFncmFtLmNvbSUyRmFuZHJvbTNfZGElMkYlMEElMEElMEFub2lzZSgzJTJDMC4zJTJDMykudGhyZXNoKDAuMyUyQzAuMDMpLmRpZmYobzMlMkMwLjMpLm91dChvMSklMEFncmFkaWVudCglNUIwLjMlMkMwLjMlMkMzJTVEKS5kaWZmKG8wKS5ibGVuZChvMSkub3V0KG8zKSUwQXZvcm9ub2koMzMlMkMzJTJDMzApLnJvdGF0ZSgzJTJDMC4zJTJDMCkubW9kdWxhdGVTY2FsZShvMiUyQzAuMykuY29sb3IoLTMlMkMzJTJDMCkuYnJpZ2h0bmVzcygzKS5vdXQobzApJTBBc2hhcGUoMzAlMkMwLjMlMkMxKS5pbnZlcnQoKCU3QnRpbWUlN0QpJTNEJTNFTWF0aC5zaW4odGltZSkqMykub3V0KG8yKSUwQSUwQXJlbmRlcihvMyklMEE="
  },
  {
    sketch_id: "andromeda_1",
    code: "JTJGJTJGJTIwMy4zJTBBJTJGJTJGJTIwYnklMjAlQ0UlOTRORFIwTTNEJUNFJTk0JTBBJTJGJTJGJTIwaHR0cHMlM0ElMkYlMkZ3d3cuaW5zdGFncmFtLmNvbSUyRmFuZHJvbTNfZGElMkYlMEElMEFvc2MoKS5tb2R1bGF0ZVJvdGF0ZShvMCUyQzAuMykub3V0KCklMEFvc2MoMzMlMkMwLjMlMkMwLjMpLmRpZmYobzMlMkMzKS5vdXQobzEpJTBBb3NjKDMlMkMwLjMlMkMzMykubW9kdWxhdGVLYWxlaWQobzMlMkMzKS5kaWZmKG8wKS5vdXQobzIpJTBBc3JjKG8wJTJDMykubXVsdChvMSUyQzMpLmthbGVpZCgzKS5vdXQobzMpJTBBcmVuZGVyKG8yKQ=="
  },
  {
    sketch_id: "asdrubal_0",
    code: "JTJGJTJGQXNkciVDMyVCQWJhbCUyMEdvbWV6JTBBJTBBbm9pc2UoMyUyQzAuMSUyQzcpJTBBLnJvdGF0ZSgxJTJDLTElMkMtMikubWFzayhzaGFwZSgyMCkpJTBBLmNvbG9yYW1hKDAuNSklMEEubW9kdWxhdGVTY2FsZShvMCklMEEubW9kdWxhdGVTY2FsZShvMCUyQzElMkMpJTBBLmJsZW5kKG8wKSUwQS5ibGVuZChvMCklMEEuYmxlbmQobzApJTBBLmJsZW5kKG8wKSUwQS5vdXQobzApJTBB"
  },
  {
    sketch_id: "flor_1",
    code: "JTJGJTJGSHlkcmElMjBHbGl0Y2h5JTIwU2xpdCUyMFNjYW4lMEElMkYlMkZGbG9yJTIwZGUlMjBGdWVnbyUwQSUyRiUyRmh0dHBzJTNBJTJGJTJGZmxvcmRlZnVlZ28uZ2l0aHViLmlvJTJGJTIwJTBBczAuaW5pdENhbSgpJTBBc3JjKHMwKS5zYXR1cmF0ZSgyKS5jb250cmFzdCgxLjMpLmxheWVyKHNyYyhvMCkubWFzayhzaGFwZSg0JTJDMikuc2NhbGUoMC41JTJDMC43KS5zY3JvbGxYKDAuMjUpKS5zY3JvbGxYKDAuMDAxKSkubW9kdWxhdGUobzAlMkMwLjAwMSkub3V0KG8wKSUwQSUwQQ=="
  },
  {
    sketch_id: "flor_2",
    code: "JTJGJTJGR2xpdGNoJTIwUml2ZXIlMEElMkYlMkZGbG9yJTIwZGUlMjBGdWVnbyUwQSUyRiUyRmh0dHBzJTNBJTJGJTJGZmxvcmRlZnVlZ28uZ2l0aHViLmlvJTJGJTBBdm9yb25vaSg4JTJDMSklMEEubXVsdChvc2MoMTAlMkMwLjElMkMoKSUzRCUzRU1hdGguc2luKHRpbWUpKjMpLnNhdHVyYXRlKDMpLmthbGVpZCgyMDApKSUwQS5tb2R1bGF0ZShvMCUyQzAuNSklMEEuYWRkKG8wJTJDMC44KSUwQS5zY3JvbGxZKC0wLjAxKSUwQS5zY2FsZSgwLjk5KSUwQS5tb2R1bGF0ZSh2b3Jvbm9pKDglMkMxKSUyQzAuMDA4KSUwQS5sdW1hKDAuMyklMEEub3V0KCklMEElMEElMEFzcGVlZCUyMCUzRCUyMDAuMSUwQSUwQSUwQSUwQQ=="
  },
  {
    sketch_id: "nesso_0",
    code: "JTBBJTJGJTJGY2xvdWRzJTIwb2YlMjBwYXNzYWdlJTBBJTJGJTJGYnklMjBOZXNzbyUwQSUyRiUyRnd3dy5uZXNzby54eXolMEElMEFzaGFwZSglNUI0JTJDNSUyQzYlNUQuZmFzdCgwLjEpLnNtb290aCgxKSUyQzAuMDAwMDAxJTJDJTVCMC4yJTJDMC43JTVELnNtb290aCgxKSklMEEuY29sb3IoMC4yJTJDMC40JTJDMC4zKSUwQS5zY3JvbGxYKCgpJTNEJTNFTWF0aC5zaW4odGltZSowLjI3KSklMEEuYWRkKCUwQSUyMCUyMHNoYXBlKCU1QjQlMkM1JTJDNiU1RC5mYXN0KDAuMSkuc21vb3RoKDEpJTJDMC4wMDAwMDElMkMlNUIwLjIlMkMwLjclMkMwLjUlMkMwLjMlNUQuc21vb3RoKDEpKSUwQSUyMCUyMC5jb2xvcigwLjYlMkMwLjIlMkMwLjUpJTBBJTIwJTIwLnNjcm9sbFkoMC4zNSklMEElMjAlMjAuc2Nyb2xsWCgoKSUzRCUzRU1hdGguc2luKHRpbWUqMC4zMykpKSUwQS5hZGQoJTBBJTIwJTIwc2hhcGUoJTVCNCUyQzUlMkM2JTVELmZhc3QoMC4xKS5zbW9vdGgoMSklMkMwLjAwMDAwMSUyQyU1QjAuMiUyQzAuNyUyQzAuMyU1RC5zbW9vdGgoMSkpJTBBJTIwJTIwLmNvbG9yKDAuMiUyQzAuNCUyQzAuNiklMEElMjAlMjAuc2Nyb2xsWSgtMC4zNSklMEElMjAlMjAuc2Nyb2xsWCgoKSUzRCUzRU1hdGguc2luKHRpbWUqMC40MSkqLTEpKSUwQS5hZGQoJTBBJTIwJTIwJTIwJTIwJTIwJTIwc3JjKG8wKS5zaGlmdCgwLjAwMSUyQzAuMDElMkMwLjAwMSklMEElMjAlMjAlMjAlMjAlMjAlMjAuc2Nyb2xsWCglNUIwLjA1JTJDLTAuMDUlNUQuZmFzdCgwLjEpLnNtb290aCgxKSklMEElMjAlMjAlMjAlMjAlMjAlMjAuc2NhbGUoJTVCMS4wNSUyQzAuOSU1RC5mYXN0KDAuMykuc21vb3RoKDEpJTJDJTVCMS4wNSUyQzAuOSUyQzElNUQuZmFzdCgwLjI5KS5zbW9vdGgoMSkpJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTJDMC44NSklMEEubW9kdWxhdGUodm9yb25vaSgxMCUyQzIlMkMyKSklMEEub3V0KCk="
  },
  {
    sketch_id: "malitzin_0",
    code: "JTJGJTJGQ05EU0QlMEElMkYlMkZodHRwJTNBJTJGJTJGbWFsaXR6aW5jb3J0ZXMubmV0JTJGJTBBJTJGJTJGJTIwc2FuZCUyMHNwaXJhbHMlMEElMEFvc2MoMyUyQyUyMDAuMDElMkMlMjAwLjQpJTBBLmNvbG9yKDEuMiUyQzEuMiUyQzEuMyklMEEuc2F0dXJhdGUoMC40KSUwQS5tb2R1bGF0ZVJlcGVhdChvc2MoMiklMkMxJTJDJTIwMiUyQyUyMDQlMkMlMjAzKSUwQS5tb2R1bGF0ZUthbGVpZChvc2MoMTIlMkMwLjA1JTJDMCklMkMxKSUwQS5sdW1hJTIwKDAuNCklMEEucm90YXRlKDQlMkMlMjAwLjElMkMwKSUwQS5tb2R1bGF0ZShvMCUyQyUyMCgpJTIwJTNEJTNFJTIwbW91c2UueSUyMCowLjAwMDIlMjApJTBBLnNjYWxlKDEpLmRpZmYobzEpJTBBLm91dChvMCk="
  },
  {
    sketch_id: "malitzin_1",
    code: "JTJGJTJGQ05EU0QlMEElMkYlMkZodHRwJTNBJTJGJTJGbWFsaXR6aW5jb3J0ZXMubmV0JTJGJTBBJTJGJTJGYW1lYmElMEElMEFvc2MoMTUlMkMlMjAwLjAxJTJDJTIwMC4xKS5tdWx0KG9zYygxJTJDJTIwLTAuMSkubW9kdWxhdGUob3NjKDIpLnJvdGF0ZSg0JTJDMSklMkMlMjAyMCkpJTBBLmNvbG9yKDAlMkMyLjQlMkM1KSUwQS5zYXR1cmF0ZSgwLjQpJTBBLmx1bWEoMSUyQzAuMSUyQyUyMCg2JTJDJTIwKCklM0QlM0UlMjAxJTIwJTJCJTIwYS5mZnQlNUIzJTVEKSklMEEuc2NhbGUoMC43JTJDJTIwKCklM0QlM0UlMjAwLjclMjAlMkIlMjBhLmZmdCU1QjMlNUQpJTBBLmRpZmYobzApJTJGJTJGJTIwbzAlMEEub3V0KG8wKSUyRiUyRiUyMG8x"
  },
  {
    sketch_id: "malitzin_2",
    code: "JTJGJTJGQ05EU0QlMEElMkYlMkZodHRwJTNBJTJGJTJGbWFsaXR6aW5jb3J0ZXMubmV0JTJGJTBBJTJGJTJGY3JhenklMjBzcXVhcmVzJTBBJTBBc2hhcGUoNCUyQyUyMCgwLjAxJTJDJTIwKCklM0QlM0UlMjAwLjIlMjAlMkIlMjBhLmZmdCU1QjIlNUQpJTJDMSklMEEubXVsdChvc2MoMSUyQyUyMDEpLm1vZHVsYXRlKG9zYyg1KS5yb3RhdGUoMS40JTJDMSklMkMzKSklMEEuY29sb3IoMSUyQzIlMkM0KSUwQS5zYXR1cmF0ZSgwLjIpJTBBLmx1bWEoMS4yJTJDMC4wNSUyQyUyMCg1JTJDJTIwKCklM0QlM0UlMjAyJTIwJTJCJTIwYS5mZnQlNUIzJTVEKSklMEEuc2NhbGUoMC42JTJDJTIwKCklM0QlM0UlMjAwLjklMjAlMkIlMjBhLmZmdCU1QjMlNUQpJTBBLmRpZmYobzApJTJGJTJGJTIwbzAlMEEub3V0KG8wKSUyRiUyRiUyMG8x"
  },
  {
    sketch_id: "khoparzi_0",
    code: "JTJGJTJGJTIwSGFwcHklMjBNYW5kYWxhJTBBJTJGJTJGJTIwQnklMjBBYmhpbmF5JTIwS2hvcGFyemklMEElMkYlMkYlMjB0d2l0dGVyJTJGZ2l0aHViJTJGaW5zdGFncmFtJTNBJTIwJTQwa2hvcGFyemklMEF2b3Jvbm9pKDUlMkMtMC4xJTJDNSklMEEuYWRkKG9zYygxJTJDMCUyQzEpKS5rYWxlaWQoMjEpJTBBLnNjYWxlKDElMkMxJTJDMikuY29sb3JhbWEoKS5vdXQobzEpJTBBc3JjKG8xKS5tdWx0KHNyYyhzMCkubW9kdWxhdGVSb3RhdGUobzElMkMxMDApJTJDJTIwLTAuNSklMEElMjAlMjAub3V0KG8wKSUwQSUwQQ=="
  },
  {
    sketch_id: "khoparzi_1",
    code: "JTJGJTJGJTIwUGVycGV0dWFsJTIwZWxldmF0b3IlMjBidXR0b25zJTBBJTJGJTJGJTIwQnklMjBLaG9wYXJ6aSUwQSUyRiUyRiUyMGh0dHAlM0ElMkYlMkZraG9wYXJ6aS5jb20lMEElMEFzaGFwZSgzKS5hZGQob3NjKDElMkMwLjUlMkMxKSUyQyUyMDEpJTBBJTA5LmFkZChvMSUyQyUyMCgpJTIwJTNEJTNFJTIwKE1hdGguc2luKHRpbWUlMkY0KSUyMColMjAwLjclMjAlMkIlMjAwLjEpKSUwQSUwOSUyRiUyRi5yZXBlYXQoNSklMEElMjAlMjAlMDkuc2NhbGUoKCklM0QlM0VNYXRoLnNpbih0aW1lJTIwJTJGJTIwMTYpKS5yb3RhdGUoMCUyQyUyMC0wLjEpJTBBJTA5Lm91dChvMSklMEElMEFzcmMobzEpJTBBJTIwJTIwLnJvdGF0ZSgwJTJDMC4xKSUwQSUyMCUyMC5vdXQoKQ=="
  },
  {
    sketch_id: "khoparzi_2",
    code: "JTJGJTJGJTIwUmVhbGx5JTIwTG92ZSUwQSUyRiUyRiUyMGJ5JTIwQWJoaW5heSUyMEtob3BhcnppJTBBJTJGJTJGJTIwaHR0cCUzQSUyRiUyRmtob3BhcnppLmNvbSUwQW9zYygxMDAlMkMtMC4wMTI0NSUyQzEpLnBpeGVsYXRlKDUwKS5rYWxlaWQoKCklM0QlM0UoTWF0aC5zaW4odGltZSUyRjgpKjklMkIzKSkucm90YXRlKDAlMkMwLjEyNSklMEEubW9kdWxhdGVSb3RhdGUoc2hhcGUoMykuc2NhbGUoKCklM0QlM0UoTWF0aC5jb3ModGltZSkqMikpLnJvdGF0ZSgwJTJDLTAuMjUpKS5kaWZmKHNyYyhvMCkuYnJpZ2h0bmVzcygwLjMpKSUwQSUyMCUyMC5vdXQoKQ=="
  },
  {
    sketch_id: "khoparzi_3",
    code: "JTJGJTJGJTIwQXFhdXRpYyUyMGJsdWJzJTBBJTJGJTJGJTIwQnklMjBLaG9wYXJ6aSUwQSUyRiUyRiUyMGh0dHBzJTNBJTJGJTJGa2hvcGFyemkuY29tJTBBJTBBZ3JhZGllbnQoMC4yNSklMEEuYWRkKG5vaXNlKCklMkMlMjAoKSUzRCUzRU1hdGguY29zKHRpbWUpKSUwQS5tb2R1bGF0ZVJvdGF0ZShzcmMobzApLnJvdGF0ZSgwJTJDJTIwLTAuNTIpJTJDJTIwMC4yKS5tdWx0KHNoYXBlKDM2MCklMkMlMjAwLjgpJTBBLnJlcGVhdCgxMCUyQzUpLm11bHQoc2hhcGUoMzYwKS5zY2FsZSgoKSUzRCUzRU1hdGguc2luKHRpbWUpKSUyQyUyMDAuOCkucm90YXRlKDAlMkMlMjAwLjIpJTBBLmRpZmYoc3JjKG8wKS5yb3RhdGUoMCUyQyUyMC0wLjIpJTJDJTIwMC4yKSUwQS5vdXQoKQ=="
  },
  {
    sketch_id: "celeste_0",
    code: "JTBBJTIwJTJGJTJGJTIwUHVlcnRhcyUyMElJJTBBJTJGJTJGJTIwcG9yJTIwQ2VsZXN0ZSUyMEJldGFuY3VyJTBBJTJGJTJGJTIwaHR0cHMlM0ElMkYlMkZnaXRodWIuY29tJTJGZXNzdGViYW4lMEElMEFvc2MoMTMlMkMwJTJDMSklMEElMjAlMjAua2FsZWlkKCklMEElMjAlMjAubWFzayhzaGFwZSg0JTJDMC4zJTJDMSkpJTBBJTIwJTIwLm1vZHVsYXRlUm90YXRlKHNoYXBlKDQlMkMwLjElMkMxKSklMEElMjAlMjAubW9kdWxhdGVSb3RhdGUoc2hhcGUoNCUyQzAuMSUyQzAuOSkpJTBBJTIwJTIwLm1vZHVsYXRlUm90YXRlKHNoYXBlKDQlMkMwLjElMkMwLjgpKSUwQSUyMCUyMC5zY2FsZSgwLjMpJTBBJTIwJTIwLmFkZChzaGFwZSg0JTJDMC4yJTJDMSkuY29sb3IoMC4zJTJDMSUyQzElMkMwLjUpKSUwQSUyMCUyMC5yb3RhdGUoKCklM0QlM0V0aW1lKSUwQSUyMCUyMC5vdXQoKQ=="
  },
  {
    sketch_id: "celeste_1",
    code: "JTJGJTJGJTIwUHVlcnRhcyUyMElJSSUwQSUyRiUyRiUyMHBvciUyMENlbGVzdGUlMjBCZXRhbmN1ciUwQSUyRiUyRiUyMGh0dHBzJTNBJTJGJTJGZ2l0aHViLmNvbSUyRmVzc3RlYmFuJTBBJTIwJTBBb3NjKDQwJTJDMC4yJTJDMSklMEElMjAlMjAubW9kdWxhdGVTY2FsZShvc2MoNDAlMkMwJTJDMSkua2FsZWlkKDgpKSUwQSUyMCUyMC5yZXBlYXQoMiUyQzQpJTBBJTIwJTIwLm1vZHVsYXRlKG8wJTJDMC4wNSklMEElMjAlMjAubW9kdWxhdGVLYWxlaWQoc2hhcGUoNCUyQzAuMSUyQzEpKSUwQSUyMCUyMC5vdXQobzAp"
  },
  {
    sketch_id: "celeste_2",
    code: "JTBBJTIwJTJGJTJGJTIwUHVlcnRhcyUwQSUyRiUyRiUyMHBvciUyMENlbGVzdGUlMjBCZXRhbmN1ciUwQSUyRiUyRiUyMGh0dHBzJTNBJTJGJTJGZ2l0aHViLmNvbSUyRmVzc3RlYmFuJTBBJTBBb3NjKDEzJTJDMCUyQzEpJTBBJTIwJTIwLm1vZHVsYXRlKG9zYygyMSUyQzAuMjUlMkMwKSklMEElMjAlMjAubW9kdWxhdGVTY2FsZShvc2MoMzQpKSUwQSUyMCUyMC5tb2R1bGF0ZUthbGVpZChvc2MoNTUpJTJDMC4xJTJDMSklMEElMjAlMjAub3V0KCk="
  },
  {
    sketch_id: "alexandre_0",
    code: "JTJGJTJGJTIwJTIydGhlLXdhbGwlMjIlMEElMkYlMkYlMjBBbGV4YW5kcmUlMjBSYW5nZWwlMEElMkYlMkYlMjB3d3cuYWxleGFuZHJlcmFuZ2VsLmFydC5iciUyRmh5ZHJhLmh0bWwlMEElMEFzcGVlZCUzRC4wMjIyJTBBb3NjKDQ4JTJDLS4xJTJDMCkudGhyZXNoKCU1Qi4zJTJDLjclNUQuZmFzdCguNzUpJTJDMCkuY29sb3IoMCUyQzAlMkMxKSUwQSUwQS5hZGQoJTBBJTIwJTIwJTIwJTIwb3NjKDI4JTJDLjElMkMwKS50aHJlc2goJTVCLjMlMkMuNyU1RC5mYXN0KC43NSklMkMwKS5yb3RhdGUoMy4xNCUyRjQpJTBBJTIwJTIwJTIwJTIwLmNvbG9yKDElMkMwJTJDMCklMEElMjAlMjAlMjAlMjAubW9kdWxhdGVTY2FsZSglMjBvc2MoNjQlMkMtLjAxJTJDMCkudGhyZXNoKCU1Qi4zJTJDLjclNUQuZmFzdCguNzUpJTJDMCklMjApJTBBKSUwQS5kaWZmKCUwQSUyMCUyMCUyMCUyMG9zYygyOCUyQy4xJTJDMCkudGhyZXNoKCU1Qi4zJTJDLjclNUQuZmFzdCguNSklMkMwKS5yb3RhdGUoMy4xNCUyRjIpJTBBJTIwJTIwJTIwJTIwLmNvbG9yKDElMkMwJTJDMSklMEElMjAlMjAlMjAlMjAubW9kdWxhdGVTY2FsZSglMjBvc2MoNjQlMkMtLjAxNSUyQzApLnRocmVzaCglNUIuMyUyQy43JTVELmZhc3QoLjUpJTJDMCklMjApJTBBKSUwQS5tb2R1bGF0ZVJvdGF0ZSglMjBvc2MoNTQlMkMtLjAwNSUyQzApLnRocmVzaCglNUIuMyUyQy43JTVELmZhc3QoLjI1KSUyQzApJTIwKSUwQS5tb2R1bGF0ZVNjYWxlKCUyMG9zYyg0NCUyQy0uMDIwJTJDMCkudGhyZXNoKCU1Qi4zJTJDLjclNUQuZmFzdCguMjUpJTJDMCklMjApJTBBLmNvbG9yYW1hKCUyMCgpJTNEJTNFTWF0aC5zaW4odGltZSUyRjI3KSouMDEyMjIlMkI5Ljg5KSUwQS5zY2FsZSgyLjEyMiklMEElMEEub3V0KCk="
  },
  {
    sketch_id: "alexandre_1",
    code: "JTBBJTIwJTJGJTJGJTIwJTIyZXllJTIwb2YlMjB0aGUlMjBiZWhvbGRlciUyMiUwQSUyRiUyRiUyMEFsZXhhbmRyZSUyMFJhbmdlbCUwQSUyRiUyRiUyMHd3dy5hbGV4YW5kcmVyYW5nZWwuYXJ0LmJyJTJGaHlkcmEuaHRtbCUwQSUwQW5vaXNlKDYlMkMuMDUpJTBBLm11bHQoJTIwb3NjKDklMkMwJTJDJTIwKCklM0QlM0VNYXRoLnNpbih0aW1lJTJGMS41KSUyQjIlMjApJTIwKSUwQS5tdWx0KCUwQSUyMCUyMCUyMCUyMG5vaXNlKDklMkMuMDMpLmJyaWdodG5lc3MoMS4yKS5jb250cmFzdCgyKSUwQSUyMCUyMCUyMCUyMC5tdWx0KCUyMG9zYyg5JTJDMCUyQyUyMCgpJTNEJTNFTWF0aC5zaW4odGltZSUyRjMpJTJCMTMlMjApJTIwKSUwQSklMEEuZGlmZiglMEElMjAlMjAlMjAlMjBub2lzZSgxNSUyQy4wNCkuYnJpZ2h0bmVzcyguMikuY29udHJhc3QoMS4zKSUwQSUyMCUyMCUyMCUyMC5tdWx0KCUyMG9zYyg5JTJDMCUyQyUyMCgpJTNEJTNFTWF0aC5zaW4odGltZSUyRjUpJTJCMTMlMjApJTIwKSUwQSUyMCUyMCUyMCUyMC5yb3RhdGUoJTIwKCklM0QlM0V0aW1lJTJGMzMlMjApJTBBKSUwQS5zY2FsZSglMjAoKSUzRCUzRU1hdGguc2luKHRpbWUlMkY2LjIpKi4xMiUyQi4xNSUyMCklMEEubW9kdWxhdGVTY2FsZSglMEElMjAlMjAlMjAlMjBvc2MoMyUyQzAlMkMwKS5tdWx0KCUyMG9zYygzJTJDMCUyQzApLnJvdGF0ZSgzLjE0JTJGMiklMjApJTBBJTIwJTIwJTIwJTIwLnJvdGF0ZSglMjAoKSUzRCUzRXRpbWUlMkYyNSUyMCkuc2NhbGUoLjM5KS5zY2FsZSgxJTJDLjYlMkMxKS5pbnZlcnQoKSUwQSUyMCUyMCUyMCUyMCUyQyUyMCgpJTNEJTNFTWF0aC5zaW4odGltZSUyRjUuMykqMS41JTJCMyUyMCUyMCklMEEucm90YXRlKCUyMCgpJTNEJTNFdGltZSUyRjIyJTIwKSUwQS5tdWx0KCUyMHNoYXBlKDEwMCUyQy45JTJDLjAxKS5zY2FsZSgxJTJDLjYlMkMxKSUyMCklMEEub3V0KCk="
  },
  {
    sketch_id: "alexandre_2",
    code: "JTJGJTJGJTIwJTIyZWdnJTIwb2YlMjB0aGUlMjBwaG9lbml4JTIyJTBBJTJGJTJGJTIwQWxleGFuZHJlJTIwUmFuZ2VsJTBBJTJGJTJGJTIwd3d3LmFsZXhhbmRyZXJhbmdlbC5hcnQuYnIlMkZoeWRyYS5odG1sJTBBJTBBc3BlZWQlM0QxLjIlMEFzaGFwZSg5OSUyQy4xNSUyQy41KS5jb2xvcigwJTJDMSUyQzIpJTBBJTBBLmRpZmYoJTIwc2hhcGUoMjQwJTJDLjUlMkMwKS5zY3JvbGxYKC4wNSkucm90YXRlKCUyMCgpJTNEJTNFdGltZSUyRjEwJTIwKS5jb2xvcigxJTJDMCUyQy43NSklMjApJTBBLmRpZmYoJTIwc2hhcGUoOTklMkMuNCUyQy4wMDIpLnNjcm9sbFgoLjEwKS5yb3RhdGUoJTIwKCklM0QlM0V0aW1lJTJGMjAlMjApLmNvbG9yKDElMkMwJTJDLjc1KSUyMCklMEEuZGlmZiglMjBzaGFwZSg5OSUyQy4zJTJDLjAwMikuc2Nyb2xsWCguMTUpLnJvdGF0ZSglMjAoKSUzRCUzRXRpbWUlMkYzMCUyMCkuY29sb3IoMSUyQzAlMkMuNzUpJTIwKSUwQS5kaWZmKCUyMHNoYXBlKDk5JTJDLjIlMkMuMDAyKS5zY3JvbGxYKC4yMCkucm90YXRlKCUyMCgpJTNEJTNFdGltZSUyRjQwJTIwKS5jb2xvcigxJTJDMCUyQy43NSklMjApJTBBLmRpZmYoJTIwc2hhcGUoOTklMkMuMSUyQy4wMDIpLnNjcm9sbFgoLjI1KS5yb3RhdGUoJTIwKCklM0QlM0V0aW1lJTJGNTAlMjApLmNvbG9yKDElMkMwJTJDLjc1KSUyMCklMEElMEEubW9kdWxhdGVTY2FsZSglMEElMjAlMjBzaGFwZSgyNDAlMkMuNSUyQzApLnNjcm9sbFgoLjA1KS5yb3RhdGUoJTIwKCklM0QlM0V0aW1lJTJGMTAlMjApJTBBJTIwJTIwJTJDJTIwKCklM0QlM0UoTWF0aC5zaW4odGltZSUyRjMpKi4yKSUyQi4yJTIwKSUwQSUwQS5zY2FsZSgxLjYlMkMuNiUyQzEpJTBBLm91dCgp"
  },
  {
    sketch_id: "afalfl_0",
    code: "JTJGJTJGZmlsZXQlMjBtaWdub24lMEElMkYlMkYlMjBBRkFMRkwlMEElMkYlMkYlMjBpbnN0YWdyYW0lMkZhX2ZfYWxmbCUyMCUwQSUwQW9zYygxMDAlMkMtMC4wMDE4JTJDMC4xNykuZGlmZihvc2MoMjAlMkMwLjAwMDA4KS5yb3RhdGUoTWF0aC5QSSUyRjAuMDAwMDMpKSUwQS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDEuNSUyQzAuMTgpLm1vZHVsYXRlU2NhbGUob3NjKDEzKS5yb3RhdGUoKCklM0QlM0VNYXRoLnNpbih0aW1lJTJGMjIpKSklMkMzKSUwQS5jb2xvcigxMSUyQzAuNSUyQzAuNCUyQyUyMDAuOSUyQyUyMDAuMiUyQyUyMDAuMDExJTJDJTIwNSUyQyUyMDIyJTJDJTIwJTIwMC41JTJDJTIwLTEpLmNvbnRyYXN0KDEuNCklMEEuYWRkKHNyYyhvMCkubW9kdWxhdGUobzAlMkMuMDQpJTJDLjYlMkMlMjAuOSklMEElMjAlMjAlMkYlMkYucGl4ZWxhdGUoMC40JTJDJTIwMC4yJTJDJTIwMC4xKSUwQS5pbnZlcnQoKS5icmlnaHRuZXNzKDAuMDAwMyUyQyUyMDIpLmNvbnRyYXN0KCUyMDAuNSUyQyUyMDIlMkMlMjAwLjElMkMlMjAyKS5jb2xvcig0JTJDJTIwLTIlMkMlMjAwLjEpJTBBLm1vZHVsYXRlU2NhbGUob3NjKDIpJTJDLTAuMiUyQyUyMDIlMkMlMjAxJTJDJTIwMC4zKSUwQSUyMC5wb3N0ZXJpemUoMjAwKSUyMC5yb3RhdGUoMSUyQyUyMDAuMiUyQyUyMDAuMDElMkMlMjAwLjAwMSklMEElMjAuY29sb3IoMjIlMkMlMjAtMiUyQyUyMDAuNSUyQyUyMDAuNSUyQyUyMDAuMDAwMSUyQyUyMCUyMDAuMSUyQyUyMDAuMiUyQyUyMDgpLmNvbnRyYXN0KDAuMTglMkMlMjAwLjMlMkMlMjAwLjElMkMlMjAwLjIlMkMlMjAwLjAzJTJDJTIwMSklMjAuJTIwYnJpZ2h0bmVzcygwLjAwMDElMkMlMjAtMSUyQyUyMDEwKSUwQSUwOS5vdXQoKQ=="
  },
  {
    sketch_id: "eerie_ear_0",
    code: "JTJGJTJGJTIwZWVfMiUyMC4lMjBNVUxUSVZFUlNFJTIwLiUyMHRpbWUlMjBhbmQlMjBmZWVkYmFjayUwQSUyRiUyRiUyMGVfZSUyMCUyRiUyRiUyMCU0MGVlcmllX2VhciUwQXBhdCUyMCUzRCUyMCgpJTNEJTNFJTBBc29saWQoKSUwQS5sYXllcihzb2xpZCgpLmRpZmYoJTBBJTIwJTIwb3NjKCh0aW1lJTJGMTYpJTIwKiUyMDElMkMlMjAodGltZSUyRjEwMDApJTIwKiUyMDAuMiUyMCUyMCklMEElMjAlMjAlMjAlMjAubXVsdChvc2MoKHRpbWUlMkY4KSUyMColMjAxJTJDJTIwKHRpbWUlMkYxMDA2KSUyMColMjAwLjIlMjAlMjApLnJvdGF0ZSgxLjU3KSklMEElMjAlMjAlMjAlMjAubW9kdWxhdGUoKHNoYXBlKDEwNiUyQzElMkMwLjA1KSkpJTBBJTIwJTIwJTIwJTIwLm11bHQoc2hhcGUoMTA2JTJDMSUyQzAuMDUpKSUwQSUyMCUyMCkpJTBBJTIwJTIwLm1vZHVsYXRlU2NhbGUob3NjKDIlMkMwLjEyNSklMkMwLjEyNSklMEElMkYlMkYlMEFzb2xpZCgpJTBBLmxheWVyKHNvbGlkKDElMkMxJTJDMSklMEElMjAlMjAubXVsdChwYXQoKSUwQSUyMCUyMC5kaWZmKHNyYyhvMCkuc2NhbGUoMC4yKS5tdWx0KHNvbGlkKCklMkMlNUIwLjclMkMwLjYlMkMwLjQlMkMwLjYlNUQpLmthbGVpZCgxLjAxKS5zYXR1cmF0ZSgwLjMpKSUwQSklMEEubGF5ZXIoc29saWQoMSUyQzElMkMxKSUwQSUyMCUyMCUyMCUyMC5tYXNrKCUwQSUyMCUyMCUyMCUyMCUyMCUyMG5vaXNlKDIlMkMwLjA1KSUwQSUyMCUyMCUyMCUyMCUyMCUyMC5pbnZlcnQoKS5jb2xvcmFtYSgyKS5wb3N0ZXJpemUoOCUyQzQpLmx1bWEoMC4yNSkudGhyZXNoKDAuNSklMEElMjAlMjAlMjAlMjAlMjAlMjAubW9kdWxhdGVSb3RhdGUob3NjKDElMkMwLjUpKSUwQSUyMCUyMCUyMCUyMCklMEElMjAlMjAlMjAlMjAubXVsdChncmFkaWVudCgwLjUpLmthbGVpZCgxKS5jb2xvcmFtYSgyKS5zYXR1cmF0ZSgxLjEpLmNvbnRyYXN0KDEuNikubXVsdChzb2xpZCgpJTJDMC40NSkpJTBBJTIwJTIwKSklMEElMjAlMjAub3V0KCklMEElMkYlMkYlMEFzcGVlZCUzRCUyMDAuNSUwQQ=="
  },
  {
    sketch_id: "eerie_ear_1",
    code: "JTJGJTJGJTIwZWVfMyUyMCUyRiUyRkxJTkVTJTBBJTJGJTJGJTIwZV9lJTIwJTJGJTJGJTIwJTQwZWVyaWVfZWFyJTBBJTJGJTJGJTBBJTJGJTJGYmFzZWQlMjBvbiUwQSUyRiUyRiU0MG5hb3RvX2hpZWRhJTBBJTJGJTJGaHR0cHMlM0ElMkYlMkZuYW90b2hpZWRhLmNvbSUyRmJsb2clMkZoeWRyYS1ib29rJTJGJTBBJTJGJTJGJTBBbiUyMCUzRCUyMDglMEFhJTIwJTNEJTIwKCklMjAlM0QlM0UlMjBzaGFwZSg0JTJDMC4yNSUyQzAuMDA5KS5yb3RhdGUoKCklM0QlM0V0aW1lJTJGLTQwKS5yZXBlYXQobiUyQ24pJTBBYSgpLmFkZChhKCkuc2Nyb2xsWCgwLjUlMkZuKS5zY3JvbGxZKDAuNSUyRm4pJTJDMSkubW9kdWxhdGUobzElMkMwLjEpLm1vZHVsYXRlKHNyYyhvMSkuY29sb3IoMTAlMkMxMCkuYWRkKHNvbGlkKC0xNCUyQy0xNCkpLnJvdGF0ZSgoKSUzRCUzRXRpbWUlMkY0MCklMkMwLjAwNSkuYWRkKHNyYyhvMSkuc2Nyb2xsWSgwLjAxMiUyQzAuMDIpJTJDMC41KS5vdXQobzEpJTBBc3JjKG8xKS5jb2xvcmFtYSgxLjIpLnBvc3Rlcml6ZSg0KS5zYXR1cmF0ZSgwLjcpLmNvbnRyYXN0KDYpLm11bHQoc29saWQoKSUyQzAuMTUpLm91dChvMCklMEElMEElMEE="
  },
  {
    sketch_id: "eerie_ear_2",
    code: "JTJGJTJGZWVfNSUyMC4lMjBGVUdJVElWRSUyMEdFT01FVFJZJTIwVkhTJTIwLiUyMGF1ZGlvcmVhY3RpdmUlMjBzaGFwZXMlMjBhbmQlMjBncmFkaWVudHMlMEElMkYlMkYlMjBlX2UlMjAlMkYlMkYlMjAlNDBlZXJpZV9lYXIlMEElMkYlMkYlMEFzJTNEJTIwKCklM0QlM0UlMEElMjAlMjBzaGFwZSg0KSUwQS5zY3JvbGxYKCU1Qi0wLjUlMkMtMC4yJTJDMC4zJTJDLTAuMSUyQy0wLjElNUQuc21vb3RoKDAuMSkuZmFzdCgwLjMpKSUwQS5zY3JvbGxZKCU1QjAuMjUlMkMtMC4yJTJDMC4zJTJDLTAuMSUyQzAuMiU1RC5zbW9vdGgoMC45KS5mYXN0KDAuMTUpKSUwQSUyRiUyRiUwQXNvbGlkKCklMEEuYWRkKGdyYWRpZW50KDMlMkMwLjA1KS5yb3RhdGUoMC4wNSUyQy0wLjIpLnBvc3Rlcml6ZSgyKS5jb250cmFzdCgwLjYpJTJDJTVCMSUyQzAlMkMxJTJDMC41JTJDMCUyQzAuNiU1RC5zbW9vdGgoMC45KSklMEEuYWRkKHMoKSklMEEubXVsdChzKCkuc2NhbGUoMC44KS5zY3JvbGxYKDAuMDEpLnNjcm9sbFkoLTAuMDEpLnJvdGF0ZSgwLjIlMkMwLjA2KS5hZGQoZ3JhZGllbnQoMykuY29udHJhc3QoMC42KSUyQyU1QjElMkMwJTJDMSUyQzAuNSU1RC5zbW9vdGgoMC45KSUyQzAuNSkubXVsdChzcmMobzApLnNjYWxlKDAuOTgpJTJDKCklM0QlM0VhLmZmdCU1QjAlNUQqOSklMEElMjAlMjAlMjAlMjAlMjApJTBBLmRpZmYocygpLm1vZHVsYXRlKHNoYXBlKDUwMCkpLnNjYWxlKCU1QjEuNyUyQzEuMiU1RC5zbW9vdGgoMC45KS5mYXN0KDAuMDUpKSklMEEuYWRkKGdyYWRpZW50KDIpLmludmVydCgpJTJDKCklM0QlM0VhLmZmdCU1QjIlNUQpJTBBLm11bHQoZ3JhZGllbnQoKCklM0QlM0VhLmZmdCU1QjMlNUQqOCkpJTBBLmJsZW5kKHNyYygobzApJTJDKCklM0QlM0VhLmZmdCU1QjElNUQqNDApKSUwQS5hZGQodm9yb25vaSgoKSUzRCUzRWEuZmZ0JTVCMSU1RCUyQygpJTNEJTNFYS5mZnQlNUIzJTVEJTJDKCklM0QlM0VhLmZmdCU1QjAlNUQpLnRocmVzaCgwLjcpLnBvc3Rlcml6ZSgyJTJDNCkubHVtYSgwLjkpLnNjcm9sbFkoMSUyQygpJTNEJTNFYS5mZnQlNUIwJTVEJTJGMzApLmNvbG9yYW1hKDMpLnRocmVzaCgoKSUzRCUzRWEuZmZ0JTVCMSU1RCkuc2NhbGUoKCklM0QlM0VhLmZmdCU1QjMlNUQqMiklMkMoKSUzRCUzRWEuZmZ0JTVCMCU1RCUyRjIpJTBBJTIwJTIwLm91dCgpJTBBJTJGJTJGJTBBc3BlZWQlM0QlMjAxJTBBJTBBYS5zZXRTbW9vdGgoMC45Nik="
  },
  {
    sketch_id: "eerie_ear_3",
    code: "JTJGJTJGJTIwZWVfMSUyMC4lMjBFWUUlMjBJTiUyMFRIRSUyMFNLWSUwQSUyRiUyRmV4YW1wbGUlMjBvZiUyMG1hc2slMjBhbmQlMjBmdW5jdGlvbiUyMG1vZHVsYXRpb24lMEElMkYlMkYlMjBlX2UlMjAlMkYlMkYlMjAlNDBlZXJpZV9lYXIlMEFub2lzZSgxOCklMEElMjAlMjAuY29sb3JhbWEoMSklMEElMjAlMjAucG9zdGVyaXplKDIpJTBBJTIwJTIwLmthbGVpZCg1MCklMEElMjAlMjAubWFzayglMEElMjAlMjAlMjAlMjBzaGFwZSgyNSUyQyUyMDAuMjUpLm1vZHVsYXRlU2NhbGUoJTBBJTIwJTIwJTIwJTIwJTIwJTIwbm9pc2UoNDAwLjUlMkMlMjAwLjUpJTBBJTIwJTIwJTIwJTIwKSUwQSUyMCUyMCklMEElMjAlMjAubWFzayhzaGFwZSg0MDAlMkMlMjAxJTJDJTIwMi4xMjUpKSUwQSUyMCUyMC5tb2R1bGF0ZVNjYWxlKG9zYyg2JTJDJTIwMC4xMjUlMkMlMjAwLjA1KS5rYWxlaWQoNTApKSUwQSUyMCUyMC5tdWx0KG9zYygyMCUyQyUyMDAuMDUlMkMlMjAyLjQpLmthbGVpZCg1MCklMkMlMjAwLjI1KSUwQSUyMCUyMC5zY2FsZSgxLjc1JTJDJTIwMC42NSUyQyUyMDAuNSklMEElMjAlMjAubW9kdWxhdGUobm9pc2UoMC41KSklMEElMjAlMjAuc2F0dXJhdGUoNiklMEElMjAlMjAucG9zdGVyaXplKDQlMkMlMjAwLjIpJTBBJTIwJTIwLnNjYWxlKDEuNSklMEElMjAlMjAub3V0KCklM0IlMEE="
  }
];
const license = `// licensed with CC BY-NC-SA 4.0 https://creativecommons.org/licenses/by-nc-sa/4.0/`;
class Gallery {
  constructor(callback2) {
    this.sketches = [];
    this.examples = [];
    this.current = null;
    this.code = null;
    this.exampleIndex = null;
    this.examples = examples;
    this.setSketchFromURL(callback2);
    window.addEventListener("popstate", (event) => {
      this.setSketchFromURL(callback2);
    });
    this.setRandomSketch = this.setRandomSketch.bind(this);
  }
  clear() {
    this.current = null;
    this.code = null;
    let newurl = window.location.protocol + "//" + window.location.host + window.location.pathname;
    window.history.pushState({ path: newurl }, "", newurl);
    this.url = newurl;
  }
  setSketchFromURL(callback2) {
    hush();
    render(o0);
    let searchParams = new URLSearchParams(window.location.search);
    this.searchParams = searchParams;
    let base64Code = searchParams.get("code");
    let sketch_id = searchParams.get("sketch_id");
    this.foundSketch = false;
    if (sketch_id) {
      var sketch = this.getExampleById(sketch_id);
      if (sketch) {
        this.setSketch(sketch);
        callback2(this.code, false);
      } else {
        request.get("/sketchById").query({ sketch_id }).end((err, res) => {
          if (err) {
            console.log("err getting sketches", err);
            this.setSketchFromCode(base64Code, callback2);
          } else {
            this.sketches = JSON.parse(res.text);
            if (this.sketches.length > 0) {
              this.setSketch(this.sketches[0]);
              this.foundSketch = true;
              callback2(this.code, this.foundSketch);
            } else {
              this.setSketchFromCode(base64Code, callback2);
            }
          }
        });
      }
    } else {
      this.setSketchFromCode(base64Code, callback2);
    }
  }
  setSketchFromCode(base64Code, callback2) {
    if (base64Code) {
      this.code = this.decodeBase64(base64Code);
      this.foundSketch = true;
    } else {
      this.setRandomSketch();
    }
    callback2(this.code, this.foundSketch);
  }
  saveImage() {
  }
  setToURL(params) {
    this.searchParams.delete("sketch_id");
    this.searchParams.delete("code");
    if (params.sketch_id) {
      `sketch_id=${params.sketch_id}`;
      this.searchParams.append("sketch_id", params.sketch_id);
    } else {
      `sketch_id=${params.sketch_id}&code=${params.code}`;
      this.searchParams.append("sketch_id", params.sketch_id);
      this.searchParams.append("code", params.code);
    }
    let newurl = window.location.protocol + "//" + window.location.host + window.location.pathname + "?" + this.searchParams.toString();
    window.history.replaceState({ path: newurl }, "", newurl);
    this.url = newurl;
  }
  encodeBase64(text) {
    return btoa(encodeURIComponent(text));
  }
  decodeBase64(base64Code) {
    return decodeURIComponent(atob(base64Code));
  }
  setSketch(sketch) {
    let code2 = this.decodeBase64(sketch.code);
    if (code2.indexOf(license) < 0)
      code2 = `${license}
${code2}
`;
    this.code = code2;
    this.current = sketch;
    this.setToURL(sketch);
  }
  setRandomSketch() {
    if (this.examples.length > 0) {
      let index2;
      index2 = Math.floor(Math.random() * this.examples.length);
      while (index2 === this.exampleIndex) {
        index2 = Math.floor(Math.random() * this.examples.length);
      }
      this.exampleIndex = index2;
      this.setSketch(this.examples[index2]);
    } else {
      var startString = "osc(2" + Math.floor(Math.pow(10, Math.random() * 2)) + ")";
      startString += ".color(" + Math.random().toFixed(2) + "," + Math.random().toFixed(2) + "," + Math.random().toFixed(2) + ")";
      startString += ".rotate(" + Math.random().toFixed(2) + ")";
      startString += ".out(o0)";
      this.code = startString;
    }
  }
  // shares via twitter
  shareSketch(code2, hydra, name) {
    this.saveSketch(code2, () => {
      console.log("URL is", this.url, "sketch is", this.current);
      hydra.getScreenImage((img) => {
        request.post("/image").attach("previewImage", img).query({
          url: this.url,
          sketch_id: this.current.sketch_id,
          name
        }).end((err, res) => {
          if (err) {
            console.log("error postingimage", err);
          } else {
            console.log("image response", res.text);
          }
        });
      });
    });
  }
  saveSketch(code2, callback2) {
    let self2 = this;
    let base64 = this.encodeBase64(code2);
    let query = {
      code: base64,
      parent: this.current ? this.current.sketch_id : null
    };
    console.log("saving in gallery", query);
    request.post("/sketch").query(query).end((err, res) => {
      if (err) {
        console.log("error posting sketch", err);
        if (callback2)
          callback2(err);
      } else {
        console.log("response", res.text);
        self2.setSketch({
          sketch_id: res.text,
          code: base64
        });
        if (callback2)
          callback2(null);
      }
    });
  }
  saveLocally(code2) {
    let base64 = this.encodeBase64(code2);
    this.searchParams.delete("sketch_id");
    this.searchParams.delete("code");
    this.searchParams.append("code", base64);
    var url_params = this.searchParams.toString();
    let newurl = window.location.protocol + "//" + window.location.host + window.location.pathname + "?" + url_params;
    window.history.pushState({ path: newurl }, "", newurl);
    this.url = newurl;
  }
  getExampleById(id2) {
    var sketches = this.examples.filter((sketch) => sketch.sketch_id === id2);
    if (sketches.length <= 0)
      sketches = this.sketches.filter((sketch) => sketch.sketch_id === id2);
    return sketches[0];
  }
}
var logElement;
const log$1 = {
  init: (el) => {
    logElement = el;
  },
  log: (msg, className = "") => {
    console.log("logging", msg, className);
    if (logElement)
      logElement.innerHTML = ` >> <span class=${className}> ${msg} </span> `;
  },
  hide: () => {
    if (logElement)
      logElement.style.display = "none";
  },
  show: () => {
    if (logElement)
      logElement.style.display = "block";
  },
  toggle: () => {
    if (logElement.style.display == "none") {
      logElement.style.display = "block";
    } else {
      logElement.style.display = "none";
    }
  }
};
const log = log$1.log;
const repl = {
  eval: (arg, callback) => {
    var jsString = `(async() => {
    ${arg}
})().catch(${(err) => log(err.message, "log-error")})`;
    var isError = false;
    try {
      eval(jsString);
      log("");
    } catch (e) {
      isError = true;
      console.log("logging", e);
      log(e.message, "log-error");
    }
    if (callback)
      callback(jsString, isError);
  }
};
function store$1(state2, emitter) {
  state2.showInfo = true;
  state2.showUI = true;
  let sketches;
  emitter.on("DOMContentLoaded", function() {
    const editor = state2.editor.editor;
    sketches = new Gallery((code2, sketchFromURL) => {
      editor.setValue(code2);
      repl.eval(code2);
      if (sketchFromURL) {
        state2.showInfo = false;
      } else {
        state2.showInfo = true;
      }
      emitter.emit("render");
    });
  });
  emitter.on("screencap", () => {
    screencap();
    const editor = state2.editor.editor;
    const text = editor.getValue();
    const data2 = new Blob([text], { type: "text/plain" });
    const a2 = document.createElement("a");
    a2.style.display = "none";
    let d2 = /* @__PURE__ */ new Date();
    a2.download = `hydra-${d2.getFullYear()}-${d2.getMonth() + 1}-${d2.getDate()}-${d2.getHours()}.${d2.getMinutes()}.${d2.getSeconds()}.js`;
    a2.href = URL.createObjectURL(data2);
    a2.click();
    setTimeout(() => {
      window.URL.revokeObjectURL(a2.href);
    }, 300);
  });
  emitter.on("editor:randomize", function(evt) {
    const editor = state2.editor.editor;
    if (evt.shiftKey) {
      editor.mutator.doUndo();
    } else {
      editor.mutator.mutate({ reroll: false, changeTransform: evt.metaKey });
      editor.formatCode();
      sketches.saveLocally(editor.getValue());
    }
  });
  function clearAll() {
    const editor = state2.editor.editor;
    hush();
    speed = 1;
    sketches.clear();
    editor.clear();
  }
  emitter.on("editor:clearAll", function() {
    clearAll();
  });
  emitter.on("editor:evalAll", function() {
    const editor = state2.editor.editor;
    const code2 = editor.getValue();
    repl.eval(code2, (string, err) => {
      editor.flashCode();
      if (!err)
        sketches.saveLocally(code2);
    });
  });
  emitter.on("editor:evalLine", (line) => {
    repl.eval(line);
  });
  emitter.on("editor:evalBlock", (block) => {
    repl.eval(block);
  });
  emitter.on("gallery:saveToURL", function() {
    let editor = state2.editor.editor;
    const editorText = editor.getValue();
    sketches.saveLocally(editorText);
  });
  emitter.on("gallery:shareSketch", function() {
    let editor = state2.editor.editor;
    const editorText = editor.getValue();
    repl.eval(editor.getValue(), (code2, error2) => {
      if (!error2) {
        showConfirmation((name) => {
          sketches.shareSketch(editorText, state2.hydra.hydra, name);
        }, () => {
        });
      } else {
        console.warn(error2);
      }
    });
  });
  emitter.on("gallery:showExample", () => {
    const editor = state2.editor.editor;
    clearAll();
    sketches.setRandomSketch();
    editor.setValue(sketches.code);
    repl.eval(editor.getValue());
  });
  emitter.on("show confirmation", function(count) {
  });
  emitter.on("clear all", function(count) {
  });
  emitter.on("hideAll", function() {
    state2.showUI = !state2.showUI;
    emitter.emit("render");
  });
  emitter.on("toggle info", function(count) {
    state2.showInfo = !state2.showInfo;
    emitter.emit("render");
  });
  emitter.on("mutate sketch", function() {
  });
}
function showConfirmation(successCallback, terminateCallback) {
  var c = prompt("Pressing OK will share this sketch to \nhttps://twitter.com/hydra_patterns.\n\nInclude your name or twitter handle (optional):");
  if (c !== null) {
    successCallback(c);
  } else {
    terminateCallback();
  }
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg2) {
  var key = _toPrimitive(arg2, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _arrayWithHoles(arr2) {
  if (Array.isArray(arr2))
    return arr2;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayLikeToArray(arr2, len2) {
  if (len2 == null || len2 > arr2.length)
    len2 = arr2.length;
  for (var i2 = 0, arr22 = new Array(len2); i2 < len2; i2++)
    arr22[i2] = arr2[i2];
  return arr22;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toArray(arr2) {
  return _arrayWithHoles(arr2) || _iterableToArray(arr2) || _unsupportedIterableToArray(arr2) || _nonIterableRest();
}
function ownKeys(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log2(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output2(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options2);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options2;
      this.debug = options2.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate2() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix2, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create2(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function clone2(options2) {
      options2 = options2 || this.options;
      options2.prefix = options2.prefix || this.prefix;
      return new Logger2(this.logger, options2);
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on2(events2, listener) {
      var _this = this;
      events2.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit2(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer2) {
          observer2.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer2) {
          observer2.apply(observer2, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise2 = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise2.resolve = res;
  promise2.reject = rej;
  return promise2;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a2, s2, t) {
  a2.forEach(function(m2) {
    if (s2[m2])
      t[m2] = s2[m2];
  });
}
function getLastOfPath(object, path2, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path2 !== "string" ? [].concat(path2) : path2.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path2, newValue) {
  var _getLastOfPath = getLastOfPath(object, path2, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
  obj[k] = newValue;
}
function pushPath(object, path2, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path2, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
  obj[k] = obj[k] || [];
  if (concat)
    obj[k] = obj[k].concat(newValue);
  if (!concat)
    obj[k].push(newValue);
}
function getPath(object, path2) {
  var _getLastOfPath3 = getLastOfPath(object, path2), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k];
}
function getPathWithDefaults(data2, defaultData, key) {
  var value = getPath(data2, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape$1(data2) {
  if (typeof data2 === "string") {
    return data2.replace(/[&<>"'\/]/g, function(s2) {
      return _entityMap[s2];
    });
  }
  return data2;
}
var isIE10 = typeof window !== "undefined" && window.navigator && typeof window.navigator.userAgentData === "undefined" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c) {
    return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r = new RegExp("(".concat(possibleChars.map(function(c) {
    return c === "?" ? "\\?" : c;
  }).join("|"), ")"));
  var matched = !r.test(key);
  if (!matched) {
    var ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function ownKeys$1(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function deepFind(obj, path2) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path2])
    return obj[path2];
  var paths = path2.split(keySeparator);
  var current2 = obj;
  for (var i2 = 0; i2 < paths.length; ++i2) {
    if (!current2)
      return void 0;
    if (typeof current2[paths[i2]] === "string" && i2 + 1 < paths.length) {
      return void 0;
    }
    if (current2[paths[i2]] === void 0) {
      var j = 2;
      var p = paths.slice(i2, i2 + j).join(keySeparator);
      var mix = current2[p];
      while (mix === void 0 && paths.length > i2 + j) {
        j++;
        p = paths.slice(i2, i2 + j).join(keySeparator);
        mix = current2[p];
      }
      if (mix === void 0)
        return void 0;
      if (mix === null)
        return null;
      if (path2.endsWith(p)) {
        if (typeof mix === "string")
          return mix;
        if (p && typeof mix[p] === "string")
          return mix[p];
      }
      var joinedPath = paths.slice(i2 + j).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current2 = current2[paths[i2]];
  }
  return current2;
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper(ResourceStore2);
  function ResourceStore2(data2) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data2 || {};
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index2 = this.options.ns.indexOf(ns);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path2 = [lng, ns];
      if (key && typeof key !== "string")
        path2 = path2.concat(key);
      if (key && typeof key === "string")
        path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
      }
      var result = getPath(this.data, path2);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path2 = [lng, ns];
      if (key)
        path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        value = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path2, value);
      if (!options2.silent)
        this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m2 in resources) {
        if (typeof resources[m2] === "string" || Object.prototype.toString.apply(resources[m2]) === "[object Array]")
          this.addResource(lng, ns, m2, resources[m2], {
            silent: true
          });
      }
      if (!options2.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path2 = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path2) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
      }
      setPath(this.data, path2, pack);
      if (!options2.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data2 = this.getDataByLanguage(lng);
      var n = data2 && Object.keys(data2) || [];
      return !!n.find(function(v) {
        return data2[v] && Object.keys(data2[v]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle: function handle(processors, value, key, options2, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options2, translator);
    });
    return value;
  }
};
function ownKeys$2(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1(Translator2);
  function Translator2(services) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options2);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options2) {
      var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var namespaces = options2.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options2.keySeparator && !this.options.userDefinedNsSeparator && !options2.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts2 = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts2[0]) > -1)
          namespaces = parts2.shift();
        key = parts2.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys3, options2, lastKey) {
      var _this2 = this;
      if (_typeof(options2) !== "object" && this.options.overloadTranslationOptionHandler) {
        options2 = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options2)
        options2 = {};
      if (keys3 === void 0 || keys3 === null)
        return "";
      if (!Array.isArray(keys3))
        keys3 = [String(keys3)];
      var returnDetails = options2.returnDetails !== void 0 ? options2.returnDetails : this.options.returnDetails;
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys3[keys3.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options2.lng || this.language;
      var appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            resolved.res = "".concat(namespace).concat(nsSeparator).concat(key);
            return resolved;
          }
          return "".concat(namespace).concat(nsSeparator).concat(key);
        }
        if (returnDetails) {
          resolved.res = key;
          return resolved;
        }
        return key;
      }
      var resolved = this.resolve(keys3, options2);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options2), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          if (returnDetails) {
            resolved.res = r;
            return resolved;
          }
          return r;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m2 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
              copy2[m2] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options2), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m2] === deepKey)
                copy2[m2] = res[m2];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys3, options2, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options2);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options2.count, options2) : "";
        var defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options2.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options2), {}, {
              keySeparator: false
            }));
            if (fk && fk.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i2 = 0; i2 < fallbackLngs.length; i2++) {
              lngs.push(fallbackLngs[i2]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language);
          } else {
            lngs.push(options2.lng || this.language);
          }
          var send = function send2(l, k, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options2);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options2);
            }
            _this2.emit("missingKey", l, namespace, k, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language, options2).forEach(function(suffix2) {
                  send([language], key + suffix2, options2["defaultValue".concat(suffix2)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys3, options2, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options2, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options2), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options2.skipInterpolation) {
        if (options2.interpolation)
          this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options2), {
            interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options2.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data2 = options2.replace && typeof options2.replace !== "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables)
          data2 = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data2);
        res = this.interpolator.interpolate(res, data2, options2.lng || this.language, options2);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft)
            options2.nest = false;
        }
        if (options2.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options2.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options2);
        if (options2.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options2) : options2, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys3) {
      var _this4 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys3 === "string")
        keys3 = [keys3];
      keys3.forEach(function(k) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k, options2);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options2.ordinal && options2.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options2.context !== void 0 && (typeof options2.context === "string" || typeof options2.context === "number") && options2.context !== "";
        var codes2 = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes2[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes2[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes2.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes2.forEach(function(code2) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code2;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code2, ns, options2);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code2, options2.count, options2);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options2.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code2, ns, possibleKey, options2);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code2, ns, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code2, ns, key, options2);
      return this.resourceStore.getResource(code2, ns, key, options2);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options2) {
      var prefix2 = "defaultValue";
      for (var option in options2) {
        if (Object.prototype.hasOwnProperty.call(options2, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options2[option]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options2) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options2;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0)
        return null;
      var p = code2.split("-");
      if (p.length === 2)
        return null;
      p.pop();
      if (p[p.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0)
        return code2;
      var p = code2.split("-");
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code2) {
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p = code2.split("-");
        if (this.options.lowerCaseLng) {
          p = p.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p.length === 2) {
          p[0] = p[0].toLowerCase();
          p[1] = p[1].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1)
            p[1] = capitalize(p[1].toLowerCase());
        } else if (p.length === 3) {
          p[0] = p[0].toLowerCase();
          if (p[1].length === 2)
            p[1] = p[1].toUpperCase();
          if (p[0] !== "sgn" && p[2].length === 2)
            p[2] = p[2].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1)
            p[1] = capitalize(p[1].toLowerCase());
          if (specialCases.indexOf(p[2].toLowerCase()) > -1)
            p[2] = capitalize(p[2].toLowerCase());
        }
        return p.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code2) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code2 = this.getLanguagePartFromCode(code2);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code2) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes2) {
      var _this = this;
      if (!codes2)
        return null;
      var found;
      codes2.forEach(function(code2) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code2);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes2.forEach(function(code2) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code2);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code2) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code2);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code2)
        return fallbacks["default"] || [];
      var found = fallbacks[code2];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code2)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code2)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code2)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code2, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code2);
      var codes2 = [];
      var addCode = function addCode2(c) {
        if (!c)
          return;
        if (_this2.isSupportedCode(c)) {
          codes2.push(c);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
        }
      };
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code2));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code2));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code2));
      } else if (typeof code2 === "string") {
        addCode(this.formatLanguageCode(code2));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes2.indexOf(fc) < 0)
          addCode(_this2.formatLanguageCode(fc));
      });
      return codes2;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _2(n) {
    return Number(n != 1);
  },
  3: function _3(n) {
    return 0;
  },
  4: function _4(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _7(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _9(n) {
    return Number(n >= 2);
  },
  10: function _10(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _11(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _12(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _13(n) {
    return Number(n !== 0);
  },
  14: function _14(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _15(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _17(n) {
    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
  },
  18: function _18(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _19(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _20(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _21(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _22(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set) {
    set.lngs.forEach(function(l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code2) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code2, {
            type: options2.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code2] || this.rules[this.languageUtils.getLanguagePartFromCode(code2)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code2) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code2, options2);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code2, key) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code2, options2).map(function(suffix2) {
        return "".concat(key).concat(suffix2);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code2) {
      var _this = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code2, options2);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code2, number, options2);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code2, count) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code2, options2);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code2));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix2 = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix2 === 2) {
          suffix2 = "plural";
        } else if (suffix2 === 1) {
          suffix2 = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix2.toString() ? _this2.options.prepend + suffix2.toString() : suffix2.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix2 === 1)
          return "";
        if (typeof suffix2 === "number")
          return "_plural_".concat(suffix2.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options2;
    this.format = options2.interpolation && options2.interpolation.format || function(value) {
      return value;
    };
    this.init(options2);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options2.interpolation)
        options2.interpolation = {
          escapeValue: true
        };
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape$1;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset3() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data2, lng, options2) {
      var _this = this;
      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path2 = getPathWithDefaults(data2, defaultData, key);
          return _this.alwaysFormat ? _this.format(path2, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data2), {}, {
            interpolationkey: key
          })) : path2;
        }
        var p = key.split(_this.formatSeparator);
        var k = p.shift().trim();
        var f = p.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data2, defaultData, k), f, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data2), {}, {
          interpolationkey: k
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match = todo.regex.exec(str)) {
          var matchedVar = match[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match, options2);
              value = typeof temp === "string" ? temp : "";
            } else if (options2 && options2.hasOwnProperty(matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match;
      var value;
      var clonedOptions = _objectSpread$3({}, options2);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c[1]);
        key = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        var matchedSingleQuotes = optionsString.match(/'/g);
        var matchedDoubleQuotes = optionsString.match(/"/g);
        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          var r = match[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match[1] = r.shift();
          formatters = r;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v, f) {
            return _this2.format(v, f, options2.lng, _objectSpread$3(_objectSpread$3({}, options2), {}, {
              interpolationkey: match[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    var optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn) {
  var cache2 = {};
  return function invokeFormatter(val, lng, options2) {
    var key = lng + JSON.stringify(options2);
    var formatter = cache2[key];
    if (!formatter) {
      formatter = fn(lng, options2);
      cache2[key] = formatter;
    }
    return formatter(val);
  };
}
var Formatter = function() {
  function Formatter2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options2;
    this.formats = {
      number: createCachedFormatter(function(lng, options3) {
        var formatter = new Intl.NumberFormat(lng, options3);
        return function(val) {
          return formatter.format(val);
        };
      }),
      currency: createCachedFormatter(function(lng, options3) {
        var formatter = new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options3), {}, {
          style: "currency"
        }));
        return function(val) {
          return formatter.format(val);
        };
      }),
      datetime: createCachedFormatter(function(lng, options3) {
        var formatter = new Intl.DateTimeFormat(lng, _objectSpread$4({}, options3));
        return function(val) {
          return formatter.format(val);
        };
      }),
      relativetime: createCachedFormatter(function(lng, options3) {
        var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options3));
        return function(val) {
          return formatter.format(val, options3.range || "day");
        };
      }),
      list: createCachedFormatter(function(lng, options3) {
        var formatter = new Intl.ListFormat(lng, _objectSpread$4({}, options3));
        return function(val) {
          return formatter.format(val);
        };
      })
    };
    this.init(options2);
  }
  _createClass(Formatter2, [{
    key: "init",
    value: function init(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options2.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "addCached",
    value: function addCached(name, fc) {
      this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
    }
  }, {
    key: "format",
    value: function format2(value, _format, lng, options2) {
      var _this = this;
      var formats2 = _format.split(this.formatSeparator);
      var result = formats2.reduce(function(mem, f) {
        var _parseFormatStr = parseFormatStr(f), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options2 && options2.formatParams && options2.formatParams[options2.interpolationkey] || {};
            var l = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng;
            formatted = _this.formats[formatName](mem, l, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options2), valOptions));
          } catch (error2) {
            _this.logger.warn(error2);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function removePending(q, name) {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store2, services) {
    var _this;
    var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store2;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options2;
    _this.logger = baseLogger.create("backendConnector");
    _this.waitingReads = [];
    _this.maxParallelReads = options2.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.maxRetries = options2.maxRetries >= 0 ? options2.maxRetries : 5;
    _this.retryTimeout = options2.retryTimeout >= 1 ? options2.retryTimeout : 350;
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options2.backend, options2);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options2, callback2) {
      var _this2 = this;
      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options2.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending[name] === void 0)
              pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === void 0)
              pending[name] = true;
            if (toLoad[name] === void 0)
              toLoad[name] = true;
            if (toLoadNamespaces[ns] === void 0)
              toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback: callback2
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data2) {
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data2) {
        this.store.addResourceBundle(lng, ns, data2);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q) {
        pushPath(q.loaded, [lng], ns);
        removePending(q, name);
        if (err)
          q.errors.push(err);
        if (q.pendingCount === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function(l) {
            if (!loaded2[l])
              loaded2[l] = {};
            var loadedKeys = q.loaded[l];
            if (loadedKeys.length) {
              loadedKeys.forEach(function(ns2) {
                if (loaded2[l][ns2] === void 0)
                  loaded2[l][ns2] = true;
              });
            }
          });
          q.done = true;
          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read2(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
      var callback2 = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback2(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback: callback2
        });
        return;
      }
      this.readingCalls++;
      return this.backend[fcName](lng, ns, function(err, data2) {
        _this3.readingCalls--;
        if (_this3.waitingReads.length > 0) {
          var next = _this3.waitingReads.shift();
          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }
        if (err && data2 && tried < _this3.maxRetries) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback2);
          }, wait);
          return;
        }
        callback2(err, data2);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback2 = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback2 && callback2();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options2, callback2);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback2();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {}, callback2);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback2);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data2) {
        if (err)
          _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data2)
          _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns, " for language ").concat(lng), data2);
        _this5.loaded(name, err, data2);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options2), {}, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get$1() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng, options2) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options2) {
  if (typeof options2.ns === "string")
    options2.ns = [options2.ns];
  if (typeof options2.fallbackLng === "string")
    options2.fallbackLng = [options2.fallbackLng];
  if (typeof options2.fallbackNS === "string")
    options2.fallbackNS = [options2.fallbackNS];
  if (options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0) {
    options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
  }
  return options2;
}
function ownKeys$6(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function noop$3() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this;
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback2 = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options2);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));
    if (callback2 && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options2, callback2);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options2, callback2);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init() {
      var _this2 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback2 = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options2 === "function") {
        callback2 = options2;
        options2 = {};
      }
      if (!options2.defaultNS && options2.defaultNS !== false && options2.ns) {
        if (typeof options2.ns === "string") {
          options2.defaultNS = options2.ns;
        } else if (options2.ns.indexOf("translation") < 0) {
          options2.defaultNS = options2.ns[0];
        }
      }
      var defOpts = get$1();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options2));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options2.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options2.keySeparator;
      }
      if (options2.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options2.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s2 = this.services;
        s2.logger = baseLogger;
        s2.resourceStore = this.store;
        s2.languageUtils = lu;
        s2.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s2.formatter = createClassOnDemand(formatter);
          s2.formatter.init(s2, this.options);
          this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
        }
        s2.interpolator = new Interpolator(this.options);
        s2.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
        s2.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s2.languageDetector.init(s2, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s2.i18nFormat.init)
            s2.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m2) {
          if (m2.init)
            m2.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback2)
        callback2 = noop$3;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes2 = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes2.length > 0 && codes2[0] !== "dev")
          this.options.lng = codes2[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t);
          callback2(err, t);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;
      var callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$3;
      var usedCallback = callback2;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append = function append2(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l) {
            if (toLoad.indexOf(l) < 0)
              toLoad.push(l);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l) {
            return append(l);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e) {
          if (!e && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback2) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback2)
        callback2 = noop$3;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback2(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module2) {
      if (!module2)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module2.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module2.type === "backend") {
        this.modules.backend = module2;
      }
      if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
        this.modules.logger = module2;
      }
      if (module2.type === "languageDetector") {
        this.modules.languageDetector = module2;
      }
      if (module2.type === "i18nFormat") {
        this.modules.i18nFormat = module2;
      }
      if (module2.type === "postProcessor") {
        postProcessor.addPostProcessor(module2);
      }
      if (module2.type === "formatter") {
        this.modules.formatter = module2;
      }
      if (module2.type === "3rdParty") {
        this.modules.external.push(module2);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l) {
      if (!l || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l) > -1)
        return;
      for (var li = 0; li < this.languages.length; li++) {
        var lngInLngs = this.languages[li];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback2) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l) {
        _this4.language = l;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l);
      };
      var done2 = function done3(err, l) {
        if (l) {
          setLngProps(l);
          _this4.translator.changeLanguage(l);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l);
          _this4.logger.log("languageChanged", l);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback2)
          callback2(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l) {
          if (!_this4.language) {
            setLngProps(l);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l);
        }
        _this4.loadResources(l, function(err) {
          done2(err, l);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options2;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options2 = _objectSpread$6({}, opts);
        }
        options2.lng = options2.lng || fixedT2.lng;
        options2.lngs = options2.lngs || fixedT2.lngs;
        options2.ns = options2.ns || fixedT2.ns;
        options2.keyPrefix = options2.keyPrefix || keyPrefix || fixedT2.keyPrefix;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey = options2.keyPrefix ? "".concat(options2.keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options2);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l, n) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];
        return loadState === -1 || loadState === 2;
      };
      if (options2.precheck) {
        var preResult = options2.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback2) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback2 && callback2();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n) {
        if (_this7.options.ns.indexOf(n) < 0)
          _this7.options.ns.push(n);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback2)
          callback2(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback2) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback2)
          callback2();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback2)
          callback2(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$3;
      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options2), {
        isClone: true
      });
      var clone2 = new I18n2(mergedOptions);
      if (options2.debug !== void 0 || options2.prefix !== void 0) {
        clone2.logger = clone2.logger.clone(options2);
      }
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m2) {
        clone2[m2] = _this8[m2];
      });
      clone2.services = _objectSpread$6({}, this.services);
      clone2.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      clone2.translator = new Translator(clone2.services, clone2.options);
      clone2.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone2.emit.apply(clone2, [event].concat(args));
      });
      clone2.init(mergedOptions, callback2);
      clone2.translator.options = clone2.options;
      clone2.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      return clone2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty(I18n, "createInstance", function() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback2 = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options2, callback2);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
var arr = [];
var each = arr.forEach;
var slice$1 = arr.slice;
function defaults(obj) {
  each.call(slice$1.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0)
          obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var serializeCookie = function serializeCookie2(name, val, options2) {
  var opt = options2 || {};
  opt.path = opt.path || "/";
  var value = encodeURIComponent(val);
  var str = "".concat(name, "=").concat(value);
  if (opt.maxAge > 0) {
    var maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge))
      throw new Error("maxAge should be a Number");
    str += "; Max-Age=".concat(Math.floor(maxAge));
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=".concat(opt.domain);
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=".concat(opt.path);
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=".concat(opt.expires.toUTCString());
  }
  if (opt.httpOnly)
    str += "; HttpOnly";
  if (opt.secure)
    str += "; Secure";
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
var cookie = {
  create: function create(name, value, minutes, domain2) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain2)
      cookieOptions.domain = domain2;
    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read: function read(name) {
    var nameEQ = "".concat(name, "=");
    var ca = document.cookie.split(";");
    for (var i2 = 0; i2 < ca.length; i2++) {
      var c = ca[i2];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEQ) === 0)
        return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove: function remove(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  lookup: function lookup2(options2) {
    var found;
    if (options2.lookupCookie && typeof document !== "undefined") {
      var c = cookie.read(options2.lookupCookie);
      if (c)
        found = c;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options2) {
    if (options2.lookupCookie && typeof document !== "undefined") {
      cookie.create(options2.lookupCookie, lng, options2.cookieMinutes, options2.cookieDomain, options2.cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  lookup: function lookup3(options2) {
    var found;
    if (typeof window !== "undefined") {
      var search = window.location.search;
      if (!window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      var query = search.substring(1);
      var params = query.split("&");
      for (var i2 = 0; i2 < params.length; i2++) {
        var pos = params[i2].indexOf("=");
        if (pos > 0) {
          var key = params[i2].substring(0, pos);
          if (key === options2.lookupQuerystring) {
            found = params[i2].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hasLocalStorageSupport = null;
var localStorageAvailable = function localStorageAvailable2() {
  if (hasLocalStorageSupport !== null)
    return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    var testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage$1 = {
  name: "localStorage",
  lookup: function lookup4(options2) {
    var found;
    if (options2.lookupLocalStorage && localStorageAvailable()) {
      var lng = window.localStorage.getItem(options2.lookupLocalStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage2(lng, options2) {
    if (options2.lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(options2.lookupLocalStorage, lng);
    }
  }
};
var hasSessionStorageSupport = null;
var sessionStorageAvailable = function sessionStorageAvailable2() {
  if (hasSessionStorageSupport !== null)
    return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    var testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage$1 = {
  name: "sessionStorage",
  lookup: function lookup5(options2) {
    var found;
    if (options2.lookupSessionStorage && sessionStorageAvailable()) {
      var lng = window.sessionStorage.getItem(options2.lookupSessionStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage3(lng, options2) {
    if (options2.lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(options2.lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup: function lookup6(options2) {
    var found = [];
    if (typeof navigator !== "undefined") {
      if (navigator.languages) {
        for (var i2 = 0; i2 < navigator.languages.length; i2++) {
          found.push(navigator.languages[i2]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  lookup: function lookup7(options2) {
    var found;
    var htmlTag2 = options2.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
    if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
      found = htmlTag2.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  lookup: function lookup8(options2) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options2.lookupFromPathIndex === "number") {
          if (typeof language[options2.lookupFromPathIndex] !== "string") {
            return void 0;
          }
          found = language[options2.lookupFromPathIndex].replace("/", "");
        } else {
          found = language[0].replace("/", "");
        }
      }
    }
    return found;
  }
};
var subdomain = {
  name: "subdomain",
  lookup: function lookup9(options2) {
    var lookupFromSubdomainIndex = typeof options2.lookupFromSubdomainIndex === "number" ? options2.lookupFromSubdomainIndex + 1 : 1;
    var language = typeof window !== "undefined" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (!language)
      return void 0;
    return language[lookupFromSubdomainIndex];
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"]
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
  };
}
var Browser = /* @__PURE__ */ function() {
  function Browser2(services) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Browser2);
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options2);
  }
  _createClass(Browser2, [{
    key: "init",
    value: function init(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services;
      this.options = defaults(options2, this.options || {}, getDefaults());
      if (this.options.lookupFromUrlIndex)
        this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage$1);
      this.addDetector(sessionStorage$1);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder)
        detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function(detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup10 = _this.detectors[detectorName].lookup(_this.options);
          if (lookup10 && typeof lookup10 === "string")
            lookup10 = [lookup10];
          if (lookup10)
            detected = detected.concat(lookup10);
        }
      });
      if (this.services.languageUtils.getBestMatchFromCodes)
        return detected;
      return detected.length > 0 ? detected[0] : null;
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage4(lng, caches) {
      var _this2 = this;
      if (!caches)
        caches = this.options.caches;
      if (!caches)
        return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1)
        return;
      caches.forEach(function(cacheName) {
        if (_this2.detectors[cacheName])
          _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }]);
  return Browser2;
}();
Browser.type = "languageDetector";
const languageResources = {
  en: {
    translation: {
      "language-name": "english",
      toolbar: {
        run: "Run all code (ctrl+shift+enter)",
        upload: "upload to gallery",
        clear: "clear all",
        shuffle: "show random sketch",
        random: "make random change",
        "show-info": "show info window",
        "hide-info": "hide info window"
      },
      info: {
        title: "hydra",
        subtitle: "live coding video synth",
        description: "Hydra is live code-able video synth and coding environment that runs directly in the browser. It is free and open-source and made for beginners and experts alike.",
        "get-started-title": "To get started:",
        "get-started-list": [
          "Close this window",
          "Change some numbers",
          "Type Ctrl + Shift + Enter"
        ],
        "description-detailed": "Hydra is written in JavaScript and compiles to WebGL under the hood. The syntax is inspired by analog modular synthesis, in which chaining or patching a set of transformations together generates a visual result.",
        "uses": "Hydra can be used:",
        "uses-list": [
          "to mix and add effects to camera feeds, screenshares, live streams, and videos",
          "to create generative and audio-reactive visuals, and share them online with others",
          "in combination with other javascript libraries such as P5.js, Tone.js, THREE.js, or gibber",
          "to add interactive video effects to a website",
          "to experiment with and learn about video feedback, fractals, and pixel operations",
          "to stream video between browsers and live-jam with others online"
        ],
        "author": "Created by <a {{author}}>olivia.</a>",
        "more-info": "For more information and instructions, see: <a {{docs}}>the interactive documentation</a>, <a {{functions}}>a list of hydra functions</a>, <a {{garden}}>the community database of projects and tutorials</a>, <a {{gallery}}>a gallery of user-generated sketches</a>, and <a {{repo}}>the source code on github</a>,",
        "more-info-forums": "There is also an active <a {{discord}}>Discord server</a> and <a {{facebook}}>facebook group</a> for hydra users+contributors.",
        "support": "If you enjoy using Hydra, please consider  <a {{open-collective}} >supporting continued development <3 </a>."
      }
    }
  }
};
const availableLanguages = ["ja", "es", "ar", "id", "pt-br"];
const languagePath = (lang) => `https://raw.githubusercontent.com/hydra-synth/l10n/main/${lang}/editor.json`;
instance.use(Browser).init({
  debug: true,
  fallbackLng: "en",
  partialBundledLanguages: true,
  // backend: {
  //   loadPath: `${window.location.origin}/locales/{{lng}}.json`,
  //   crossDomain: true
  // },
  resources: languageResources
});
function store(state2, emitter) {
  const languages = {};
  let searchParams = new URLSearchParams(window.location.search);
  let lang = searchParams.get("l10n-lang");
  let path2 = searchParams.get("l10n-url");
  availableLanguages.forEach((lang2) => {
    loadLanguageFromURL(lang2, languagePath(lang2));
  });
  if (lang !== null && path2 !== null) {
    loadLanguageFromURL(lang, path2);
  }
  updateAvailableLanguages();
  emitter.on("set language", (lang2) => {
    instance.changeLanguage(lang2, (err, t) => {
      state2.translation.selectedLanguage = lang2;
      emitter.emit("render");
    });
  });
  function updateAvailableLanguages() {
    Object.keys(languageResources).forEach((key) => {
      const k = key.split("-")[0];
      languages[k] = instance.getFixedT(k)("language-name");
    });
    state2.translation = {
      t: instance.t,
      languages,
      // languages: ['en', 'ja'],
      selectedLanguage: instance.language
    };
  }
  function loadLanguageFromURL(lang2 = "es", path3) {
    const css2 = "color: purple; background: orange; font-size: 14px;padding:10px";
    console.log(`%cloading translation for ${lang2} from ${path3}`, css2);
    fetch(path3).then((res) => {
      if (!res.ok) {
        return res.text().then((text) => {
          throw new Error(text);
        });
      } else {
        return res.json();
      }
    }).then((json) => {
      window.i18n = instance;
      console.log("adding language", lang2, json);
      const k = lang2.split("-")[0];
      instance.addResourceBundle(k, "translation", json);
      updateAvailableLanguages();
      emitter.emit("render");
    });
  }
}
var hyperscriptAttributeToProperty = attributeToProperty;
var transform = {
  "class": "className",
  "for": "htmlFor",
  "http-equiv": "httpEquiv"
};
function attributeToProperty(h2) {
  return function(tagName, attrs, children) {
    for (var attr in attrs) {
      if (attr in transform) {
        attrs[transform[attr]] = attrs[attr];
        delete attrs[attr];
      }
    }
    return h2(tagName, attrs, children);
  };
}
var attrToProp = hyperscriptAttributeToProperty;
var VAR = 0, TEXT = 1, OPEN = 2, CLOSE = 3, ATTR = 4;
var ATTR_KEY = 5, ATTR_KEY_W = 6;
var ATTR_VALUE_W = 7, ATTR_VALUE = 8;
var ATTR_VALUE_SQ = 9, ATTR_VALUE_DQ = 10;
var ATTR_EQ = 11, ATTR_BREAK = 12;
var COMMENT = 13;
var hyperx$1 = function(h2, opts) {
  if (!opts)
    opts = {};
  var concat = opts.concat || function(a2, b) {
    return String(a2) + String(b);
  };
  if (opts.attrToProp !== false) {
    h2 = attrToProp(h2);
  }
  return function(strings) {
    var state2 = TEXT, reg2 = "";
    var arglen = arguments.length;
    var parts2 = [];
    for (var i2 = 0; i2 < strings.length; i2++) {
      if (i2 < arglen - 1) {
        var arg2 = arguments[i2 + 1];
        var p = parse4(strings[i2]);
        var xstate = state2;
        if (xstate === ATTR_VALUE_DQ)
          xstate = ATTR_VALUE;
        if (xstate === ATTR_VALUE_SQ)
          xstate = ATTR_VALUE;
        if (xstate === ATTR_VALUE_W)
          xstate = ATTR_VALUE;
        if (xstate === ATTR)
          xstate = ATTR_KEY;
        if (xstate === OPEN) {
          if (reg2 === "/") {
            p.push([OPEN, "/", arg2]);
            reg2 = "";
          } else {
            p.push([OPEN, arg2]);
          }
        } else if (xstate === COMMENT && opts.comments) {
          reg2 += String(arg2);
        } else if (xstate !== COMMENT) {
          p.push([VAR, xstate, arg2]);
        }
        parts2.push.apply(parts2, p);
      } else
        parts2.push.apply(parts2, parse4(strings[i2]));
    }
    var tree = [null, {}, []];
    var stack = [[tree, -1]];
    for (var i2 = 0; i2 < parts2.length; i2++) {
      var cur = stack[stack.length - 1][0];
      var p = parts2[i2], s2 = p[0];
      if (s2 === OPEN && /^\//.test(p[1])) {
        var ix = stack[stack.length - 1][1];
        if (stack.length > 1) {
          stack.pop();
          stack[stack.length - 1][0][2][ix] = h2(
            cur[0],
            cur[1],
            cur[2].length ? cur[2] : void 0
          );
        }
      } else if (s2 === OPEN) {
        var c = [p[1], {}, []];
        cur[2].push(c);
        stack.push([c, cur[2].length - 1]);
      } else if (s2 === ATTR_KEY || s2 === VAR && p[1] === ATTR_KEY) {
        var key = "";
        var copyKey;
        for (; i2 < parts2.length; i2++) {
          if (parts2[i2][0] === ATTR_KEY) {
            key = concat(key, parts2[i2][1]);
          } else if (parts2[i2][0] === VAR && parts2[i2][1] === ATTR_KEY) {
            if (typeof parts2[i2][2] === "object" && !key) {
              for (copyKey in parts2[i2][2]) {
                if (parts2[i2][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {
                  cur[1][copyKey] = parts2[i2][2][copyKey];
                }
              }
            } else {
              key = concat(key, parts2[i2][2]);
            }
          } else
            break;
        }
        if (parts2[i2][0] === ATTR_EQ)
          i2++;
        var j = i2;
        for (; i2 < parts2.length; i2++) {
          if (parts2[i2][0] === ATTR_VALUE || parts2[i2][0] === ATTR_KEY) {
            if (!cur[1][key])
              cur[1][key] = strfn(parts2[i2][1]);
            else
              parts2[i2][1] === "" || (cur[1][key] = concat(cur[1][key], parts2[i2][1]));
          } else if (parts2[i2][0] === VAR && (parts2[i2][1] === ATTR_VALUE || parts2[i2][1] === ATTR_KEY)) {
            if (!cur[1][key])
              cur[1][key] = strfn(parts2[i2][2]);
            else
              parts2[i2][2] === "" || (cur[1][key] = concat(cur[1][key], parts2[i2][2]));
          } else {
            if (key.length && !cur[1][key] && i2 === j && (parts2[i2][0] === CLOSE || parts2[i2][0] === ATTR_BREAK)) {
              cur[1][key] = key.toLowerCase();
            }
            if (parts2[i2][0] === CLOSE) {
              i2--;
            }
            break;
          }
        }
      } else if (s2 === ATTR_KEY) {
        cur[1][p[1]] = true;
      } else if (s2 === VAR && p[1] === ATTR_KEY) {
        cur[1][p[2]] = true;
      } else if (s2 === CLOSE) {
        if (selfClosing(cur[0]) && stack.length) {
          var ix = stack[stack.length - 1][1];
          stack.pop();
          stack[stack.length - 1][0][2][ix] = h2(
            cur[0],
            cur[1],
            cur[2].length ? cur[2] : void 0
          );
        }
      } else if (s2 === VAR && p[1] === TEXT) {
        if (p[2] === void 0 || p[2] === null)
          p[2] = "";
        else if (!p[2])
          p[2] = concat("", p[2]);
        if (Array.isArray(p[2][0])) {
          cur[2].push.apply(cur[2], p[2]);
        } else {
          cur[2].push(p[2]);
        }
      } else if (s2 === TEXT) {
        cur[2].push(p[1]);
      } else if (s2 === ATTR_EQ || s2 === ATTR_BREAK)
        ;
      else {
        throw new Error("unhandled: " + s2);
      }
    }
    if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) {
      tree[2].shift();
    }
    if (tree[2].length > 2 || tree[2].length === 2 && /\S/.test(tree[2][1])) {
      if (opts.createFragment)
        return opts.createFragment(tree[2]);
      throw new Error(
        "multiple root elements must be wrapped in an enclosing tag"
      );
    }
    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === "string" && Array.isArray(tree[2][0][2])) {
      tree[2][0] = h2(tree[2][0][0], tree[2][0][1], tree[2][0][2]);
    }
    return tree[2][0];
    function parse4(str) {
      var res = [];
      if (state2 === ATTR_VALUE_W)
        state2 = ATTR;
      for (var i3 = 0; i3 < str.length; i3++) {
        var c2 = str.charAt(i3);
        if (state2 === TEXT && c2 === "<") {
          if (reg2.length)
            res.push([TEXT, reg2]);
          reg2 = "";
          state2 = OPEN;
        } else if (c2 === ">" && !quot(state2) && state2 !== COMMENT) {
          if (state2 === OPEN && reg2.length) {
            res.push([OPEN, reg2]);
          } else if (state2 === ATTR_KEY) {
            res.push([ATTR_KEY, reg2]);
          } else if (state2 === ATTR_VALUE && reg2.length) {
            res.push([ATTR_VALUE, reg2]);
          }
          res.push([CLOSE]);
          reg2 = "";
          state2 = TEXT;
        } else if (state2 === COMMENT && /-$/.test(reg2) && c2 === "-") {
          if (opts.comments) {
            res.push([ATTR_VALUE, reg2.substr(0, reg2.length - 1)]);
          }
          reg2 = "";
          state2 = TEXT;
        } else if (state2 === OPEN && /^!--$/.test(reg2)) {
          if (opts.comments) {
            res.push([OPEN, reg2], [ATTR_KEY, "comment"], [ATTR_EQ]);
          }
          reg2 = c2;
          state2 = COMMENT;
        } else if (state2 === TEXT || state2 === COMMENT) {
          reg2 += c2;
        } else if (state2 === OPEN && c2 === "/" && reg2.length)
          ;
        else if (state2 === OPEN && /\s/.test(c2)) {
          if (reg2.length) {
            res.push([OPEN, reg2]);
          }
          reg2 = "";
          state2 = ATTR;
        } else if (state2 === OPEN) {
          reg2 += c2;
        } else if (state2 === ATTR && /[^\s"'=/]/.test(c2)) {
          state2 = ATTR_KEY;
          reg2 = c2;
        } else if (state2 === ATTR && /\s/.test(c2)) {
          if (reg2.length)
            res.push([ATTR_KEY, reg2]);
          res.push([ATTR_BREAK]);
        } else if (state2 === ATTR_KEY && /\s/.test(c2)) {
          res.push([ATTR_KEY, reg2]);
          reg2 = "";
          state2 = ATTR_KEY_W;
        } else if (state2 === ATTR_KEY && c2 === "=") {
          res.push([ATTR_KEY, reg2], [ATTR_EQ]);
          reg2 = "";
          state2 = ATTR_VALUE_W;
        } else if (state2 === ATTR_KEY) {
          reg2 += c2;
        } else if ((state2 === ATTR_KEY_W || state2 === ATTR) && c2 === "=") {
          res.push([ATTR_EQ]);
          state2 = ATTR_VALUE_W;
        } else if ((state2 === ATTR_KEY_W || state2 === ATTR) && !/\s/.test(c2)) {
          res.push([ATTR_BREAK]);
          if (/[\w-]/.test(c2)) {
            reg2 += c2;
            state2 = ATTR_KEY;
          } else
            state2 = ATTR;
        } else if (state2 === ATTR_VALUE_W && c2 === '"') {
          state2 = ATTR_VALUE_DQ;
        } else if (state2 === ATTR_VALUE_W && c2 === "'") {
          state2 = ATTR_VALUE_SQ;
        } else if (state2 === ATTR_VALUE_DQ && c2 === '"') {
          res.push([ATTR_VALUE, reg2], [ATTR_BREAK]);
          reg2 = "";
          state2 = ATTR;
        } else if (state2 === ATTR_VALUE_SQ && c2 === "'") {
          res.push([ATTR_VALUE, reg2], [ATTR_BREAK]);
          reg2 = "";
          state2 = ATTR;
        } else if (state2 === ATTR_VALUE_W && !/\s/.test(c2)) {
          state2 = ATTR_VALUE;
          i3--;
        } else if (state2 === ATTR_VALUE && /\s/.test(c2)) {
          res.push([ATTR_VALUE, reg2], [ATTR_BREAK]);
          reg2 = "";
          state2 = ATTR;
        } else if (state2 === ATTR_VALUE || state2 === ATTR_VALUE_SQ || state2 === ATTR_VALUE_DQ) {
          reg2 += c2;
        }
      }
      if (state2 === TEXT && reg2.length) {
        res.push([TEXT, reg2]);
        reg2 = "";
      } else if (state2 === ATTR_VALUE && reg2.length) {
        res.push([ATTR_VALUE, reg2]);
        reg2 = "";
      } else if (state2 === ATTR_VALUE_DQ && reg2.length) {
        res.push([ATTR_VALUE, reg2]);
        reg2 = "";
      } else if (state2 === ATTR_VALUE_SQ && reg2.length) {
        res.push([ATTR_VALUE, reg2]);
        reg2 = "";
      } else if (state2 === ATTR_KEY) {
        res.push([ATTR_KEY, reg2]);
        reg2 = "";
      }
      return res;
    }
  };
  function strfn(x2) {
    if (typeof x2 === "function")
      return x2;
    else if (typeof x2 === "string")
      return x2;
    else if (x2 && typeof x2 === "object")
      return x2;
    else if (x2 === null || x2 === void 0)
      return x2;
    else
      return concat("", x2);
  }
};
function quot(state2) {
  return state2 === ATTR_VALUE_SQ || state2 === ATTR_VALUE_DQ;
}
var closeRE = RegExp("^(" + [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr",
  "!--",
  // SVG TAGS
  "animate",
  "animateTransform",
  "circle",
  "cursor",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "font-face-format",
  "font-face-name",
  "font-face-uri",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "missing-glyph",
  "mpath",
  "path",
  "polygon",
  "polyline",
  "rect",
  "set",
  "stop",
  "tref",
  "use",
  "view",
  "vkern"
].join("|") + ")(?:[.#][a-zA-Z0-9-Ôøø_:-]+)*$");
function selfClosing(tag) {
  return closeRE.test(tag);
}
var trailingNewlineRegex = /\n[\s]+$/;
var leadingNewlineRegex = /^\n[\s]+/;
var trailingSpaceRegex = /[\s]+$/;
var leadingSpaceRegex = /^[\s]+/;
var multiSpaceRegex = /[\n\s]+/g;
var TEXT_TAGS = [
  "a",
  "abbr",
  "b",
  "bdi",
  "bdo",
  "br",
  "cite",
  "data",
  "dfn",
  "em",
  "i",
  "kbd",
  "mark",
  "q",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "amp",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "time",
  "u",
  "var",
  "wbr"
];
var VERBATIM_TAGS = [
  "code",
  "pre",
  "textarea"
];
var appendChild$1 = function appendChild2(el, childs) {
  if (!Array.isArray(childs))
    return;
  var nodeName = el.nodeName.toLowerCase();
  var hadText = false;
  var value, leader;
  for (var i2 = 0, len2 = childs.length; i2 < len2; i2++) {
    var node = childs[i2];
    if (Array.isArray(node)) {
      appendChild2(el, node);
      continue;
    }
    if (typeof node === "number" || typeof node === "boolean" || typeof node === "function" || node instanceof Date || node instanceof RegExp) {
      node = node.toString();
    }
    var lastChild = el.childNodes[el.childNodes.length - 1];
    if (typeof node === "string") {
      hadText = true;
      if (lastChild && lastChild.nodeName === "#text") {
        lastChild.nodeValue += node;
      } else {
        node = el.ownerDocument.createTextNode(node);
        el.appendChild(node);
        lastChild = node;
      }
      if (i2 === len2 - 1) {
        hadText = false;
        if (TEXT_TAGS.indexOf(nodeName) === -1 && VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue.replace(leadingNewlineRegex, "").replace(trailingSpaceRegex, "").replace(trailingNewlineRegex, "").replace(multiSpaceRegex, " ");
          if (value === "") {
            el.removeChild(lastChild);
          } else {
            lastChild.nodeValue = value;
          }
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          leader = i2 === 0 ? "" : " ";
          value = lastChild.nodeValue.replace(leadingNewlineRegex, leader).replace(leadingSpaceRegex, " ").replace(trailingSpaceRegex, "").replace(trailingNewlineRegex, "").replace(multiSpaceRegex, " ");
          lastChild.nodeValue = value;
        }
      }
    } else if (node && node.nodeType) {
      if (hadText) {
        hadText = false;
        if (TEXT_TAGS.indexOf(nodeName) === -1 && VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue.replace(leadingNewlineRegex, "").replace(trailingNewlineRegex, " ").replace(multiSpaceRegex, " ");
          if (value === "") {
            el.removeChild(lastChild);
          } else {
            lastChild.nodeValue = value;
          }
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue.replace(leadingSpaceRegex, " ").replace(leadingNewlineRegex, "").replace(trailingNewlineRegex, " ").replace(multiSpaceRegex, " ");
          lastChild.nodeValue = value;
        }
      }
      var _nodeName = node.nodeName;
      if (_nodeName)
        nodeName = _nodeName.toLowerCase();
      el.appendChild(node);
    }
  }
};
var svgTags = [
  "svg",
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "stop",
  "switch",
  "symbol",
  "text",
  "textPath",
  "title",
  "tref",
  "tspan",
  "use",
  "view",
  "vkern"
];
var boolProps = [
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defaultchecked",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var directProps = [
  "indeterminate"
];
var hyperx = hyperx$1;
var appendChild = appendChild$1;
var SVG_TAGS = svgTags;
var BOOL_PROPS = boolProps;
var DIRECT_PROPS = directProps;
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var COMMENT_TAG = "!--";
var dom = function(document2) {
  function nanoHtmlCreateElement(tag, props, children) {
    var el;
    if (SVG_TAGS.indexOf(tag) !== -1) {
      props.namespace = SVGNS;
    }
    var ns = false;
    if (props.namespace) {
      ns = props.namespace;
      delete props.namespace;
    }
    var isCustomElement = false;
    if (props.is) {
      isCustomElement = props.is;
      delete props.is;
    }
    if (ns) {
      if (isCustomElement) {
        el = document2.createElementNS(ns, tag, { is: isCustomElement });
      } else {
        el = document2.createElementNS(ns, tag);
      }
    } else if (tag === COMMENT_TAG) {
      return document2.createComment(props.comment);
    } else if (isCustomElement) {
      el = document2.createElement(tag, { is: isCustomElement });
    } else {
      el = document2.createElement(tag);
    }
    for (var p in props) {
      if (props.hasOwnProperty(p)) {
        var key = p.toLowerCase();
        var val = props[p];
        if (key === "classname") {
          key = "class";
          p = "class";
        }
        if (p === "htmlFor") {
          p = "for";
        }
        if (BOOL_PROPS.indexOf(key) !== -1) {
          if (String(val) === "true")
            val = key;
          else if (String(val) === "false")
            continue;
        }
        if (key.slice(0, 2) === "on" || DIRECT_PROPS.indexOf(key) !== -1) {
          el[p] = val;
        } else {
          if (ns) {
            if (p === "xlink:href") {
              el.setAttributeNS(XLINKNS, p, val);
            } else if (/^xmlns($|:)/i.test(p))
              ;
            else {
              el.setAttributeNS(null, p, val);
            }
          } else {
            el.setAttribute(p, val);
          }
        }
      }
    }
    appendChild(el, children);
    return el;
  }
  function createFragment(nodes) {
    var fragment = document2.createDocumentFragment();
    for (var i2 = 0; i2 < nodes.length; i2++) {
      if (nodes[i2] == null)
        continue;
      if (Array.isArray(nodes[i2])) {
        fragment.appendChild(createFragment(nodes[i2]));
      } else {
        if (typeof nodes[i2] === "string")
          nodes[i2] = document2.createTextNode(nodes[i2]);
        fragment.appendChild(nodes[i2]);
      }
    }
    return fragment;
  }
  var exports2 = hyperx(nanoHtmlCreateElement, {
    comments: true,
    createFragment
  });
  exports2.default = exports2;
  exports2.createComment = nanoHtmlCreateElement;
  return exports2;
};
var browser$7 = dom(document);
var html$1 = browser$7;
const html$2 = /* @__PURE__ */ getDefaultExportFromCjs(html$1);
function nanohtmlRawBrowser(tag) {
  var el = document.createElement("div");
  el.innerHTML = tag;
  return toArray$1(el.childNodes);
}
function toArray$1(arr2) {
  return Array.isArray(arr2) ? arr2 : [].slice.call(arr2);
}
var rawBrowser = nanohtmlRawBrowser;
var raw = rawBrowser;
const raw$1 = /* @__PURE__ */ getDefaultExportFromCjs(raw);
function toolbar(state2, emit2) {
  const hidden = state2.showInfo ? "hidden" : "";
  const { t } = state2.translation;
  const dispatch = (eventName) => (e) => emit2(eventName, e);
  const icon = (id2, className, title, event) => html$2`
        <i id="${id2}-icon" class="fas icon ${className}" title="${title}" onclick=${dispatch(event)} aria-hidden="true"></i>`;
  const toggleInfo = state2.showInfo ? icon("close", "fa-times", t("toolbar.hide-info"), "toggle info") : icon("close", "fa-question-circle", t("toolbar.show-info"), "toggle info");
  return html$2`<div>
        ${icon("run", `fa-play-circle ${hidden}`, t("toolbar.run"), "editor:evalAll")}
        ${icon("share", `fa-upload ${hidden}`, t("toolbar.upload"), "gallery:shareSketch")}
        ${icon("clear", `fa fa-trash ${hidden}`, t("toolbar.clear"), "editor:clearAll")}
        ${icon("shuffle", `fa-random`, t("toolbar.shuffle"), "gallery:showExample")}
        ${icon("mutator", `fa-dice ${hidden}`, t("toolbar.random"), "editor:randomize")}
        ${toggleInfo}
    </div>`;
}
const link = (url2) => `href=${url2} target=_blank`;
function mainView$1(state2, emit2) {
  const { t, languages } = state2.translation;
  const textDirection = state2.translation.selectedLanguage === "ar" && state2.showInfo === true ? "rtl" : "ltr";
  const langArray = Object.entries(languages);
  return html$2`
<div id="info-container" class="${state2.showInfo ? "" : "hidden"}" style="direction:${textDirection}">
  <div id="modal">
    <div id="modal-header" style="opacity:${state2.showUI === true ? 1 : 0}">
      ${state2.showInfo && langArray.length > 1 ? html$2`<div style="display:flex;flex-wrap:wrap">${langArray.map(([key, val]) => html$2`
        <div class="language-select" onclick=${() => emit2("set language", key)}>${val}</div>
      `)}</div>` : html$2`<div></div>`}
      ${toolbar(state2, emit2)}
    </div>
    <div id="modal-body">
      <div id="modal-content">
        <h1>${t("info.title")}</h1>
        <h3>${t("info.subtitle")}</h3>
          <br> ///////////////////////////////////////////////////////////<br>
          <h4>${t("info.description")}</h4>
        <h4>${t("info.get-started-title")}<ol>
            <li>${t("info.get-started-list.0")}</li>
            <li>${t("info.get-started-list.1")}</li>
            <li>${t("info.get-started-list.2")}</li>
          </ol>
        </h4>

        <p> ///////////////////////////////////////////////////////////<br><br><br>
          ${t("info.description-detailed")}
        </p>
        <p>${t("info.uses")}<ul>
        ${t("info.uses-list", { returnObjects: true }).map((text) => html$2`<li>${text}</li>`)}
        </ul></p>
       
           <p class="align-right">${raw$1(t("info.author", { author: `href=https://ojack.xyz class=olivia target=_blank` }))}</p>
           <p>${raw$1(t("info.more-info", {
    docs: link("https://hydra.ojack.xyz/docs"),
    functions: link("https://hydra.ojack.xyz/api"),
    gallery: link("https://twitter.com/hydra_patterns"),
    repo: link("https://github.com/hydra-synth/hydra"),
    pixeljam: link("http://pixeljam.glitch.me/"),
    garden: link("https://hydra.ojack.xyz/garden"),
    "hydra-book": link("https://hydra-book.glitch.me/"),
    "tutorials": link("https://github.com/ojack/hydra/blob/master/examples/README.md")
  }))}</p>
          <p>${raw$1(t("info.more-info-forums", {
    discord: link("https://discord.gg/ZQjfHkNHXC"),
    facebook: link("https://www.facebook.com/groups/1084288351771117/")
  }))}</p>

        <p>${raw$1(t("info.support", {
    "open-collective": link("https://opencollective.com/hydra-synth")
  }))}</p>
      </div>
    </div>
  </div>
</div>
`;
}
var topLevel = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : {};
var minDoc = require$$3;
var doccy;
if (typeof document !== "undefined") {
  doccy = document;
} else {
  doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
  if (!doccy) {
    doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
  }
}
var document_1 = doccy;
var onLoad = { exports: {} };
var win;
if (typeof window !== "undefined") {
  win = window;
} else if (typeof commonjsGlobal !== "undefined") {
  win = commonjsGlobal;
} else if (typeof self !== "undefined") {
  win = self;
} else {
  win = {};
}
var window_1 = win;
var document$2 = document_1;
var window$1 = window_1;
var watch = /* @__PURE__ */ Object.create(null);
var KEY_ID = "onloadid" + Math.random().toString(36).slice(2);
var KEY_ATTR = "data-" + KEY_ID;
var INDEX = 0;
if (window$1 && window$1.MutationObserver) {
  var observer = new MutationObserver(function(mutations) {
    if (Object.keys(watch).length < 1)
      return;
    for (var i2 = 0; i2 < mutations.length; i2++) {
      if (mutations[i2].attributeName === KEY_ATTR) {
        eachAttr(mutations[i2], turnon, turnoff);
        continue;
      }
      eachMutation(mutations[i2].removedNodes, function(index2, el) {
        if (!document$2.documentElement.contains(el))
          turnoff(index2, el);
      });
      eachMutation(mutations[i2].addedNodes, function(index2, el) {
        if (document$2.documentElement.contains(el))
          turnon(index2, el);
      });
    }
  });
  observer.observe(document$2.documentElement, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: [KEY_ATTR]
  });
}
onLoad.exports = function onload2(el, on2, off, caller) {
  on2 = on2 || function() {
  };
  off = off || function() {
  };
  el.setAttribute(KEY_ATTR, "o" + INDEX);
  watch["o" + INDEX] = [on2, off, 0, caller || onload2.caller];
  INDEX += 1;
  return el;
};
onLoad.exports.KEY_ATTR = KEY_ATTR;
onLoad.exports.KEY_ID = KEY_ID;
function turnon(index2, el) {
  if (watch[index2][0] && watch[index2][2] === 0) {
    watch[index2][0](el);
    watch[index2][2] = 1;
  }
}
function turnoff(index2, el) {
  if (watch[index2][1] && watch[index2][2] === 1) {
    watch[index2][1](el);
    watch[index2][2] = 0;
  }
}
function eachAttr(mutation, on2, off) {
  var newValue = mutation.target.getAttribute(KEY_ATTR);
  if (sameOrigin(mutation.oldValue, newValue)) {
    watch[newValue] = watch[mutation.oldValue];
    return;
  }
  if (watch[mutation.oldValue]) {
    off(mutation.oldValue, mutation.target);
  }
  if (watch[newValue]) {
    on2(newValue, mutation.target);
  }
}
function sameOrigin(oldValue, newValue) {
  if (!oldValue || !newValue)
    return false;
  return watch[oldValue][3] === watch[newValue][3];
}
function eachMutation(nodes, fn) {
  var keys3 = Object.keys(watch);
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2] && nodes[i2].getAttribute && nodes[i2].getAttribute(KEY_ATTR)) {
      var onloadid = nodes[i2].getAttribute(KEY_ATTR);
      keys3.forEach(function(k) {
        if (onloadid === k) {
          fn(k, nodes[i2]);
        }
      });
    }
    if (nodes[i2] && nodes[i2].childNodes.length > 0) {
      eachMutation(nodes[i2].childNodes, fn);
    }
  }
}
var onLoadExports = onLoad.exports;
var nanoassert = assert$1;
class AssertionError extends Error {
}
AssertionError.prototype.name = "AssertionError";
function assert$1(t, m2) {
  if (!t) {
    var err = new AssertionError(m2);
    if (Error.captureStackTrace)
      Error.captureStackTrace(err, assert$1);
    throw err;
  }
}
const document$1 = document_1;
const nanotiming = browser$9;
const morph = nanomorph_1;
const onload = onLoadExports;
const assert = nanoassert;
const OL_KEY_ID = onload.KEY_ID;
const OL_ATTR_ID = onload.KEY_ATTR;
var nanocomponent = Nanocomponent;
function makeID() {
  return "ncid-" + Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
}
Nanocomponent.makeID = makeID;
function Nanocomponent(name) {
  this._hasWindow = typeof window !== "undefined";
  this._id = null;
  this._ncID = null;
  this._olID = null;
  this._proxy = null;
  this._loaded = false;
  this._rootNodeName = null;
  this._name = name || "nanocomponent";
  this._rerender = false;
  this._handleLoad = this._handleLoad.bind(this);
  this._handleUnload = this._handleUnload.bind(this);
  this._arguments = [];
  const self2 = this;
  Object.defineProperty(this, "element", {
    get: function() {
      const el = document$1.getElementById(self2._id);
      if (el)
        return el.dataset.nanocomponent === self2._ncID ? el : void 0;
    }
  });
}
Nanocomponent.prototype.render = function() {
  const renderTiming = nanotiming(this._name + ".render");
  const self2 = this;
  const args = new Array(arguments.length);
  let el;
  for (let i2 = 0; i2 < arguments.length; i2++)
    args[i2] = arguments[i2];
  if (!this._hasWindow) {
    const createTiming = nanotiming(this._name + ".create");
    el = this.createElement.apply(this, args);
    createTiming();
    renderTiming();
    return el;
  } else if (this.element) {
    el = this.element;
    const updateTiming = nanotiming(this._name + ".update");
    const shouldUpdate = this._rerender || this.update.apply(this, args);
    updateTiming();
    if (this._rerender)
      this._rerender = false;
    if (shouldUpdate) {
      const desiredHtml = this._handleRender(args);
      const morphTiming = nanotiming(this._name + ".morph");
      morph(el, desiredHtml);
      morphTiming();
      if (this.afterupdate)
        this.afterupdate(el);
    }
    if (!this._proxy) {
      this._proxy = this._createProxy();
    }
    renderTiming();
    return this._proxy;
  } else {
    this._reset();
    el = this._handleRender(args);
    if (this.beforerender)
      this.beforerender(el);
    if (this.load || this.unload || this.afterreorder) {
      onload(el, self2._handleLoad, self2._handleUnload, self2._ncID);
      this._olID = el.dataset[OL_KEY_ID];
    }
    renderTiming();
    return el;
  }
};
Nanocomponent.prototype.rerender = function() {
  assert(this.element, "nanocomponent: cant rerender on an unmounted dom node");
  this._rerender = true;
  this.render.apply(this, this._arguments);
};
Nanocomponent.prototype._handleRender = function(args) {
  const createElementTiming = nanotiming(this._name + ".createElement");
  const el = this.createElement.apply(this, args);
  createElementTiming();
  if (!this._rootNodeName)
    this._rootNodeName = el.nodeName;
  assert(el instanceof window.Element, "nanocomponent: createElement should return a single DOM node");
  assert(this._rootNodeName === el.nodeName, "nanocomponent: root node types cannot differ between re-renders");
  this._arguments = args;
  return this._brandNode(this._ensureID(el));
};
Nanocomponent.prototype._createProxy = function() {
  const proxy = document$1.createElement(this._rootNodeName);
  const self2 = this;
  this._brandNode(proxy);
  proxy.id = this._id;
  proxy.setAttribute("data-proxy", "");
  proxy.isSameNode = function(el) {
    return el && el.dataset.nanocomponent === self2._ncID;
  };
  return proxy;
};
Nanocomponent.prototype._reset = function() {
  this._ncID = Nanocomponent.makeID();
  this._olID = null;
  this._id = null;
  this._proxy = null;
  this._rootNodeName = null;
};
Nanocomponent.prototype._brandNode = function(node) {
  node.setAttribute("data-nanocomponent", this._ncID);
  if (this._olID)
    node.setAttribute(OL_ATTR_ID, this._olID);
  return node;
};
Nanocomponent.prototype._ensureID = function(node) {
  if (node.id)
    this._id = node.id;
  else
    node.id = this._id = this._ncID;
  if (this._proxy && this._proxy.id !== this._id)
    this._proxy.id = this._id;
  return node;
};
Nanocomponent.prototype._handleLoad = function(el) {
  if (this._loaded) {
    if (this.afterreorder)
      this.afterreorder(el);
    return;
  }
  this._loaded = true;
  if (this.load)
    this.load(el);
};
Nanocomponent.prototype._handleUnload = function(el) {
  if (this.element)
    return;
  this._loaded = false;
  if (this.unload)
    this.unload(el);
};
Nanocomponent.prototype.createElement = function() {
  throw new Error("nanocomponent: createElement should be implemented!");
};
Nanocomponent.prototype.update = function() {
  throw new Error("nanocomponent: update should be implemented!");
};
var component = nanocomponent;
const Component = /* @__PURE__ */ getDefaultExportFromCjs(component);
var ju = (o, c) => () => (c || o((c = { exports: {} }).exports, c), c.exports);
var Vu = ju((exports, module) => {
  var Output = function({ regl: o, precision: c, label: h2 = "", width: w, height: D }) {
    this.regl = o, this.precision = c, this.label = h2, this.positionBuffer = this.regl.buffer([
      [-2, 0],
      [0, -2],
      [2, 2]
    ]), this.draw = () => {
    }, this.init(), this.pingPongIndex = 0, this.fbos = Array(2).fill().map(() => this.regl.framebuffer({
      color: this.regl.texture({
        mag: "nearest",
        width: w,
        height: D,
        format: "rgba"
      }),
      depthStencil: false
    }));
  };
  Output.prototype.resize = function(o, c) {
    this.fbos.forEach((h2) => {
      h2.resize(o, c);
    });
  };
  Output.prototype.getCurrent = function() {
    return this.fbos[this.pingPongIndex];
  };
  Output.prototype.getTexture = function() {
    var o = this.pingPongIndex ? 0 : 1;
    return this.fbos[o];
  };
  Output.prototype.init = function() {
    return this.transformIndex = 0, this.fragHeader = `
  precision ${this.precision} float;

  uniform float time;
  varying vec2 uv;
  `, this.fragBody = "", this.vert = `
  precision ${this.precision} float;
  attribute vec2 position;
  varying vec2 uv;

  void main () {
    uv = position;
    gl_Position = vec4(2.0 * position - 1.0, 0, 1);
  }`, this.attributes = {
      position: this.positionBuffer
    }, this.uniforms = {
      time: this.regl.prop("time"),
      resolution: this.regl.prop("resolution")
    }, this.frag = `
       ${this.fragHeader}

      void main () {
        vec4 c = vec4(0, 0, 0, 0);
        vec2 st = uv;
        ${this.fragBody}
        gl_FragColor = c;
      }
  `, this;
  };
  Output.prototype.render = function(o) {
    let c = o[0];
    var h2 = this, w = Object.assign(c.uniforms, {
      prevBuffer: () => h2.fbos[h2.pingPongIndex]
    });
    h2.draw = h2.regl({
      frag: c.frag,
      vert: h2.vert,
      attributes: h2.attributes,
      uniforms: w,
      count: 3,
      framebuffer: () => (h2.pingPongIndex = h2.pingPongIndex ? 0 : 1, h2.fbos[h2.pingPongIndex])
    });
  };
  Output.prototype.tick = function(o) {
    this.draw(o);
  };
  var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {};
  function getDefaultExportFromCjs(o) {
    return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
  }
  var inherits_browser = { exports: {} };
  typeof Object.create == "function" ? inherits_browser.exports = function(c, h2) {
    h2 && (c.super_ = h2, c.prototype = Object.create(h2.prototype, {
      constructor: {
        value: c,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }));
  } : inherits_browser.exports = function(c, h2) {
    if (h2) {
      c.super_ = h2;
      var w = function() {
      };
      w.prototype = h2.prototype, c.prototype = new w(), c.prototype.constructor = c;
    }
  };
  var inherits_browserExports = inherits_browser.exports;
  function EventEmitter$1() {
    this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
  }
  var events = EventEmitter$1;
  EventEmitter$1.EventEmitter = EventEmitter$1;
  EventEmitter$1.prototype._events = void 0;
  EventEmitter$1.prototype._maxListeners = void 0;
  EventEmitter$1.defaultMaxListeners = 10;
  EventEmitter$1.prototype.setMaxListeners = function(o) {
    if (!isNumber(o) || o < 0 || isNaN(o))
      throw TypeError("n must be a positive number");
    return this._maxListeners = o, this;
  };
  EventEmitter$1.prototype.emit = function(o) {
    var c, h2, w, D, J, Se;
    if (this._events || (this._events = {}), o === "error" && (!this._events.error || isObject(this._events.error) && !this._events.error.length)) {
      if (c = arguments[1], c instanceof Error)
        throw c;
      var he = new Error('Uncaught, unspecified "error" event. (' + c + ")");
      throw he.context = c, he;
    }
    if (h2 = this._events[o], isUndefined(h2))
      return false;
    if (isFunction(h2))
      switch (arguments.length) {
        case 1:
          h2.call(this);
          break;
        case 2:
          h2.call(this, arguments[1]);
          break;
        case 3:
          h2.call(this, arguments[1], arguments[2]);
          break;
        default:
          D = Array.prototype.slice.call(arguments, 1), h2.apply(this, D);
      }
    else if (isObject(h2))
      for (D = Array.prototype.slice.call(arguments, 1), Se = h2.slice(), w = Se.length, J = 0; J < w; J++)
        Se[J].apply(this, D);
    return true;
  };
  EventEmitter$1.prototype.addListener = function(o, c) {
    var h2;
    if (!isFunction(c))
      throw TypeError("listener must be a function");
    return this._events || (this._events = {}), this._events.newListener && this.emit(
      "newListener",
      o,
      isFunction(c.listener) ? c.listener : c
    ), this._events[o] ? isObject(this._events[o]) ? this._events[o].push(c) : this._events[o] = [this._events[o], c] : this._events[o] = c, isObject(this._events[o]) && !this._events[o].warned && (isUndefined(this._maxListeners) ? h2 = EventEmitter$1.defaultMaxListeners : h2 = this._maxListeners, h2 && h2 > 0 && this._events[o].length > h2 && (this._events[o].warned = true, console.error(
      "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
      this._events[o].length
    ), typeof console.trace == "function" && console.trace())), this;
  };
  EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
  EventEmitter$1.prototype.once = function(o, c) {
    if (!isFunction(c))
      throw TypeError("listener must be a function");
    var h2 = false;
    function w() {
      this.removeListener(o, w), h2 || (h2 = true, c.apply(this, arguments));
    }
    return w.listener = c, this.on(o, w), this;
  };
  EventEmitter$1.prototype.removeListener = function(o, c) {
    var h2, w, D, J;
    if (!isFunction(c))
      throw TypeError("listener must be a function");
    if (!this._events || !this._events[o])
      return this;
    if (h2 = this._events[o], D = h2.length, w = -1, h2 === c || isFunction(h2.listener) && h2.listener === c)
      delete this._events[o], this._events.removeListener && this.emit("removeListener", o, c);
    else if (isObject(h2)) {
      for (J = D; J-- > 0; )
        if (h2[J] === c || h2[J].listener && h2[J].listener === c) {
          w = J;
          break;
        }
      if (w < 0)
        return this;
      h2.length === 1 ? (h2.length = 0, delete this._events[o]) : h2.splice(w, 1), this._events.removeListener && this.emit("removeListener", o, c);
    }
    return this;
  };
  EventEmitter$1.prototype.removeAllListeners = function(o) {
    var c, h2;
    if (!this._events)
      return this;
    if (!this._events.removeListener)
      return arguments.length === 0 ? this._events = {} : this._events[o] && delete this._events[o], this;
    if (arguments.length === 0) {
      for (c in this._events)
        c !== "removeListener" && this.removeAllListeners(c);
      return this.removeAllListeners("removeListener"), this._events = {}, this;
    }
    if (h2 = this._events[o], isFunction(h2))
      this.removeListener(o, h2);
    else if (h2)
      for (; h2.length; )
        this.removeListener(o, h2[h2.length - 1]);
    return delete this._events[o], this;
  };
  EventEmitter$1.prototype.listeners = function(o) {
    var c;
    return !this._events || !this._events[o] ? c = [] : isFunction(this._events[o]) ? c = [this._events[o]] : c = this._events[o].slice(), c;
  };
  EventEmitter$1.prototype.listenerCount = function(o) {
    if (this._events) {
      var c = this._events[o];
      if (isFunction(c))
        return 1;
      if (c)
        return c.length;
    }
    return 0;
  };
  EventEmitter$1.listenerCount = function(o, c) {
    return o.listenerCount(c);
  };
  function isFunction(o) {
    return typeof o == "function";
  }
  function isNumber(o) {
    return typeof o == "number";
  }
  function isObject(o) {
    return typeof o == "object" && o !== null;
  }
  function isUndefined(o) {
    return o === void 0;
  }
  var browser = window.performance && window.performance.now ? function() {
    return performance.now();
  } : Date.now || function() {
    return +/* @__PURE__ */ new Date();
  }, raf$2 = { exports: {} }, performanceNow = { exports: {} };
  (function() {
    var o, c, h2, w, D, J;
    typeof performance < "u" && performance !== null && performance.now ? performanceNow.exports = function() {
      return performance.now();
    } : typeof process < "u" && process !== null && process.hrtime ? (performanceNow.exports = function() {
      return (o() - D) / 1e6;
    }, c = process.hrtime, o = function() {
      var Se;
      return Se = c(), Se[0] * 1e9 + Se[1];
    }, w = o(), J = process.uptime() * 1e9, D = w - J) : Date.now ? (performanceNow.exports = function() {
      return Date.now() - h2;
    }, h2 = Date.now()) : (performanceNow.exports = function() {
      return (/* @__PURE__ */ new Date()).getTime() - h2;
    }, h2 = (/* @__PURE__ */ new Date()).getTime());
  }).call(commonjsGlobal);
  var performanceNowExports = performanceNow.exports, now$1 = performanceNowExports, root = window, vendors = ["moz", "webkit"], suffix = "AnimationFrame", raf$1 = root["request" + suffix], caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
  for (var i = 0; !raf$1 && i < vendors.length; i++)
    raf$1 = root[vendors[i] + "Request" + suffix], caf = root[vendors[i] + "Cancel" + suffix] || root[vendors[i] + "CancelRequest" + suffix];
  if (!raf$1 || !caf) {
    var last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
    raf$1 = function(o) {
      if (queue.length === 0) {
        var c = now$1(), h2 = Math.max(0, frameDuration - (c - last));
        last = h2 + c, setTimeout(function() {
          var w = queue.slice(0);
          queue.length = 0;
          for (var D = 0; D < w.length; D++)
            if (!w[D].cancelled)
              try {
                w[D].callback(last);
              } catch (J) {
                setTimeout(function() {
                  throw J;
                }, 0);
              }
        }, Math.round(h2));
      }
      return queue.push({
        handle: ++id,
        callback: o,
        cancelled: false
      }), id;
    }, caf = function(o) {
      for (var c = 0; c < queue.length; c++)
        queue[c].handle === o && (queue[c].cancelled = true);
    };
  }
  raf$2.exports = function(o) {
    return raf$1.call(root, o);
  };
  raf$2.exports.cancel = function() {
    caf.apply(root, arguments);
  };
  raf$2.exports.polyfill = function(o) {
    o || (o = root), o.requestAnimationFrame = raf$1, o.cancelAnimationFrame = caf;
  };
  var rafExports = raf$2.exports, inherits = inherits_browserExports, EventEmitter = events.EventEmitter, now = browser, raf = rafExports, rafLoop = Engine;
  function Engine(o) {
    if (!(this instanceof Engine))
      return new Engine(o);
    this.running = false, this.last = now(), this._frame = 0, this._tick = this.tick.bind(this), o && this.on("tick", o);
  }
  inherits(Engine, EventEmitter);
  Engine.prototype.start = function() {
    if (!this.running)
      return this.running = true, this.last = now(), this._frame = raf(this._tick), this;
  };
  Engine.prototype.stop = function() {
    return this.running = false, this._frame !== 0 && raf.cancel(this._frame), this._frame = 0, this;
  };
  Engine.prototype.tick = function() {
    this._frame = raf(this._tick);
    var o = now(), c = o - this.last;
    this.emit("tick", c), this.last = o;
  };
  const loop = /* @__PURE__ */ getDefaultExportFromCjs(rafLoop);
  function Webcam(o) {
    return navigator.mediaDevices.enumerateDevices().then((c) => c.filter((h2) => h2.kind === "videoinput")).then((c) => {
      let h2 = { audio: false, video: true };
      return c[o] && (h2.video = {
        deviceId: { exact: c[o].deviceId }
      }), window.navigator.mediaDevices.getUserMedia(h2);
    }).then((c) => {
      const h2 = document.createElement("video");
      return h2.setAttribute("autoplay", ""), h2.setAttribute("muted", ""), h2.setAttribute("playsinline", ""), h2.srcObject = c, new Promise((w, D) => {
        h2.addEventListener("loadedmetadata", () => {
          h2.play().then(() => w({ video: h2 }));
        });
      });
    }).catch(console.log.bind(console));
  }
  function Screen(o) {
    return new Promise(function(c, h2) {
      navigator.mediaDevices.getDisplayMedia(o).then((w) => {
        const D = document.createElement("video");
        D.srcObject = w, D.addEventListener("loadedmetadata", () => {
          D.play(), c({ video: D });
        });
      }).catch((w) => h2(w));
    });
  }
  class HydraSource {
    constructor({ regl: c, width: h2, height: w, pb: D, label: J = "" }) {
      this.label = J, this.regl = c, this.src = null, this.dynamic = true, this.width = h2, this.height = w, this.tex = this.regl.texture({
        //  shape: [width, height]
        shape: [1, 1]
      }), this.pb = D;
    }
    init(c, h2) {
      "src" in c && (this.src = c.src, this.tex = this.regl.texture({ data: this.src, ...h2 })), "dynamic" in c && (this.dynamic = c.dynamic);
    }
    initCam(c, h2) {
      const w = this;
      Webcam(c).then((D) => {
        w.src = D.video, w.dynamic = true, w.tex = w.regl.texture({ data: w.src, ...h2 });
      }).catch((D) => console.log("could not get camera", D));
    }
    initVideo(c = "", h2) {
      const w = document.createElement("video");
      w.crossOrigin = "anonymous", w.autoplay = true, w.loop = true, w.muted = true, w.addEventListener("loadeddata", () => {
        this.src = w, w.play(), this.tex = this.regl.texture({ data: this.src, ...h2 }), this.dynamic = true;
      }), w.src = c;
    }
    initImage(c = "", h2) {
      const w = document.createElement("img");
      w.crossOrigin = "anonymous", w.src = c, w.onload = () => {
        this.src = w, this.dynamic = false, this.tex = this.regl.texture({ data: this.src, ...h2 });
      };
    }
    initStream(c, h2) {
      let w = this;
      c && this.pb && (this.pb.initSource(c), this.pb.on("got video", function(D, J) {
        D === c && (w.src = J, w.dynamic = true, w.tex = w.regl.texture({ data: w.src, ...h2 }));
      }));
    }
    // index only relevant in atom-hydra + desktop apps
    initScreen(c = 0, h2) {
      const w = this;
      Screen().then(function(D) {
        w.src = D.video, w.tex = w.regl.texture({ data: w.src, ...h2 }), w.dynamic = true;
      }).catch((D) => console.log("could not get screen", D));
    }
    resize(c, h2) {
      this.width = c, this.height = h2;
    }
    clear() {
      this.src && this.src.srcObject && this.src.srcObject.getTracks && this.src.srcObject.getTracks().forEach((c) => c.stop()), this.src = null, this.tex = this.regl.texture({ shape: [1, 1] });
    }
    tick(c) {
      this.src !== null && this.dynamic === true && (this.src.videoWidth && this.src.videoWidth !== this.tex.width && (console.log(
        this.src.videoWidth,
        this.src.videoHeight,
        this.tex.width,
        this.tex.height
      ), this.tex.resize(this.src.videoWidth, this.src.videoHeight)), this.src.width && this.src.width !== this.tex.width && this.tex.resize(this.src.width, this.src.height), this.tex.subimage(this.src));
    }
    getTexture() {
      return this.tex;
    }
  }
  const mouse = {};
  function mouseButtons(o) {
    if (typeof o == "object") {
      if ("buttons" in o)
        return o.buttons;
      if ("which" in o) {
        var c = o.which;
        if (c === 2)
          return 4;
        if (c === 3)
          return 2;
        if (c > 0)
          return 1 << c - 1;
      } else if ("button" in o) {
        var c = o.button;
        if (c === 1)
          return 4;
        if (c === 2)
          return 2;
        if (c >= 0)
          return 1 << c;
      }
    }
    return 0;
  }
  mouse.buttons = mouseButtons;
  function mouseElement(o) {
    return o.target || o.srcElement || window;
  }
  mouse.element = mouseElement;
  function mouseRelativeX(o) {
    return typeof o == "object" && "pageX" in o ? o.pageX : 0;
  }
  mouse.x = mouseRelativeX;
  function mouseRelativeY(o) {
    return typeof o == "object" && "pageY" in o ? o.pageY : 0;
  }
  mouse.y = mouseRelativeY;
  function mouseListen(o, c) {
    c || (c = o, o = window);
    var h2 = 0, w = 0, D = 0, J = {
      shift: false,
      alt: false,
      control: false,
      meta: false
    }, Se = false;
    function he(Be) {
      var it = false;
      return "altKey" in Be && (it = it || Be.altKey !== J.alt, J.alt = !!Be.altKey), "shiftKey" in Be && (it = it || Be.shiftKey !== J.shift, J.shift = !!Be.shiftKey), "ctrlKey" in Be && (it = it || Be.ctrlKey !== J.control, J.control = !!Be.ctrlKey), "metaKey" in Be && (it = it || Be.metaKey !== J.meta, J.meta = !!Be.metaKey), it;
    }
    function Ie(Be, it) {
      var Yt = mouse.x(it), wt = mouse.y(it);
      "buttons" in it && (Be = it.buttons | 0), (Be !== h2 || Yt !== w || wt !== D || he(it)) && (h2 = Be | 0, w = Yt || 0, D = wt || 0, c && c(h2, w, D, J));
    }
    function be(Be) {
      Ie(0, Be);
    }
    function vt() {
      (h2 || w || D || J.shift || J.alt || J.meta || J.control) && (w = D = 0, h2 = 0, J.shift = J.alt = J.control = J.meta = false, c && c(0, 0, 0, J));
    }
    function He(Be) {
      he(Be) && c && c(h2, w, D, J);
    }
    function We(Be) {
      mouse.buttons(Be) === 0 ? Ie(0, Be) : Ie(h2, Be);
    }
    function mt(Be) {
      Ie(h2 | mouse.buttons(Be), Be);
    }
    function st(Be) {
      Ie(h2 & ~mouse.buttons(Be), Be);
    }
    function yt() {
      Se || (Se = true, o.addEventListener("mousemove", We), o.addEventListener("mousedown", mt), o.addEventListener("mouseup", st), o.addEventListener("mouseleave", be), o.addEventListener("mouseenter", be), o.addEventListener("mouseout", be), o.addEventListener("mouseover", be), o.addEventListener("blur", vt), o.addEventListener("keyup", He), o.addEventListener("keydown", He), o.addEventListener("keypress", He), o !== window && (window.addEventListener("blur", vt), window.addEventListener("keyup", He), window.addEventListener("keydown", He), window.addEventListener("keypress", He)));
    }
    function Wt() {
      Se && (Se = false, o.removeEventListener("mousemove", We), o.removeEventListener("mousedown", mt), o.removeEventListener("mouseup", st), o.removeEventListener("mouseleave", be), o.removeEventListener("mouseenter", be), o.removeEventListener("mouseout", be), o.removeEventListener("mouseover", be), o.removeEventListener("blur", vt), o.removeEventListener("keyup", He), o.removeEventListener("keydown", He), o.removeEventListener("keypress", He), o !== window && (window.removeEventListener("blur", vt), window.removeEventListener("keyup", He), window.removeEventListener("keydown", He), window.removeEventListener("keypress", He)));
    }
    yt();
    var Et = {
      element: o
    };
    return Object.defineProperties(Et, {
      enabled: {
        get: function() {
          return Se;
        },
        set: function(Be) {
          Be ? yt() : Wt();
        },
        enumerable: true
      },
      buttons: {
        get: function() {
          return h2;
        },
        enumerable: true
      },
      x: {
        get: function() {
          return w;
        },
        enumerable: true
      },
      y: {
        get: function() {
          return D;
        },
        enumerable: true
      },
      mods: {
        get: function() {
          return J;
        },
        enumerable: true
      }
    }), Et;
  }
  var meyda_min = { exports: {} };
  (function(o, c) {
    (function(h2, w) {
      o.exports = w();
    })(commonjsGlobal, function() {
      function h2(S, _23, $) {
        if ($ || arguments.length === 2)
          for (var C, ee = 0, ce = _23.length; ee < ce; ee++)
            !C && ee in _23 || (C || (C = Array.prototype.slice.call(_23, 0, ee)), C[ee] = _23[ee]);
        return S.concat(C || Array.prototype.slice.call(_23));
      }
      var w = Object.freeze({ __proto__: null, blackman: function(S) {
        for (var _23 = new Float32Array(S), $ = 2 * Math.PI / (S - 1), C = 2 * $, ee = 0; ee < S / 2; ee++)
          _23[ee] = 0.42 - 0.5 * Math.cos(ee * $) + 0.08 * Math.cos(ee * C);
        for (ee = Math.ceil(S / 2); ee > 0; ee--)
          _23[S - ee] = _23[ee - 1];
        return _23;
      }, sine: function(S) {
        for (var _23 = Math.PI / (S - 1), $ = new Float32Array(S), C = 0; C < S; C++)
          $[C] = Math.sin(_23 * C);
        return $;
      }, hanning: function(S) {
        for (var _23 = new Float32Array(S), $ = 0; $ < S; $++)
          _23[$] = 0.5 - 0.5 * Math.cos(2 * Math.PI * $ / (S - 1));
        return _23;
      }, hamming: function(S) {
        for (var _23 = new Float32Array(S), $ = 0; $ < S; $++)
          _23[$] = 0.54 - 0.46 * Math.cos(2 * Math.PI * ($ / S - 1));
        return _23;
      } }), D = {};
      function J(S) {
        for (; S % 2 == 0 && S > 1; )
          S /= 2;
        return S === 1;
      }
      function Se(S, _23) {
        if (_23 !== "rect") {
          if (_23 !== "" && _23 || (_23 = "hanning"), D[_23] || (D[_23] = {}), !D[_23][S.length])
            try {
              D[_23][S.length] = w[_23](S.length);
            } catch {
              throw new Error("Invalid windowing function");
            }
          S = function($, C) {
            for (var ee = [], ce = 0; ce < Math.min($.length, C.length); ce++)
              ee[ce] = $[ce] * C[ce];
            return ee;
          }(S, D[_23][S.length]);
        }
        return S;
      }
      function he(S, _23, $) {
        for (var C = new Float32Array(S), ee = 0; ee < C.length; ee++)
          C[ee] = ee * _23 / $, C[ee] = 13 * Math.atan(C[ee] / 1315.8) + 3.5 * Math.atan(Math.pow(C[ee] / 7518, 2));
        return C;
      }
      function Ie(S) {
        return Float32Array.from(S);
      }
      function be(S) {
        return 1125 * Math.log(1 + S / 700);
      }
      function vt(S, _23, $) {
        for (var C, ee = new Float32Array(S + 2), ce = new Float32Array(S + 2), we = _23 / 2, ke = be(0), Te = (be(we) - ke) / (S + 1), Ae = new Array(S + 2), Pe = 0; Pe < ee.length; Pe++)
          ee[Pe] = Pe * Te, ce[Pe] = (C = ee[Pe], 700 * (Math.exp(C / 1125) - 1)), Ae[Pe] = Math.floor(($ + 1) * ce[Pe] / _23);
        for (var ut = new Array(S), Ue = 0; Ue < ut.length; Ue++) {
          for (ut[Ue] = new Array($ / 2 + 1).fill(0), Pe = Ae[Ue]; Pe < Ae[Ue + 1]; Pe++)
            ut[Ue][Pe] = (Pe - Ae[Ue]) / (Ae[Ue + 1] - Ae[Ue]);
          for (Pe = Ae[Ue + 1]; Pe < Ae[Ue + 2]; Pe++)
            ut[Ue][Pe] = (Ae[Ue + 2] - Pe) / (Ae[Ue + 2] - Ae[Ue + 1]);
        }
        return ut;
      }
      function He(S, _23, $, C, ee, ce, we) {
        C === void 0 && (C = 5), ee === void 0 && (ee = 2), ce === void 0 && (ce = true), we === void 0 && (we = 440);
        var ke = Math.floor($ / 2) + 1, Te = new Array($).fill(0).map(function(Qe, ct) {
          return S * function(pt, Gt) {
            return Math.log2(16 * pt / Gt);
          }(_23 * ct / $, we);
        });
        Te[0] = Te[1] - 1.5 * S;
        var Ae, Pe, ut, Ue = Te.slice(1).map(function(Qe, ct) {
          return Math.max(Qe - Te[ct]);
        }, 1).concat([1]), Ct = Math.round(S / 2), At = new Array(S).fill(0).map(function(Qe, ct) {
          return Te.map(function(pt) {
            return (10 * S + Ct + pt - ct) % S - Ct;
          });
        }), St = At.map(function(Qe, ct) {
          return Qe.map(function(pt, Gt) {
            return Math.exp(-0.5 * Math.pow(2 * At[ct][Gt] / Ue[Gt], 2));
          });
        });
        if (Pe = (Ae = St)[0].map(function() {
          return 0;
        }), ut = Ae.reduce(function(Qe, ct) {
          return ct.forEach(function(pt, Gt) {
            Qe[Gt] += Math.pow(pt, 2);
          }), Qe;
        }, Pe).map(Math.sqrt), St = Ae.map(function(Qe, ct) {
          return Qe.map(function(pt, Gt) {
            return pt / (ut[Gt] || 1);
          });
        }), ee) {
          var Lr = Te.map(function(Qe) {
            return Math.exp(-0.5 * Math.pow((Qe / S - C) / ee, 2));
          });
          St = St.map(function(Qe) {
            return Qe.map(function(ct, pt) {
              return ct * Lr[pt];
            });
          });
        }
        return ce && (St = h2(h2([], St.slice(3), true), St.slice(0, 3), true)), St.map(function(Qe) {
          return Qe.slice(0, ke);
        });
      }
      function We(S, _23) {
        for (var $ = 0, C = 0, ee = 0; ee < _23.length; ee++)
          $ += Math.pow(ee, S) * Math.abs(_23[ee]), C += _23[ee];
        return $ / C;
      }
      function mt(S) {
        var _23 = S.ampSpectrum, $ = S.barkScale, C = S.numberOfBarkBands, ee = C === void 0 ? 24 : C;
        if (typeof _23 != "object" || typeof $ != "object")
          throw new TypeError();
        var ce = ee, we = new Float32Array(ce), ke = 0, Te = _23, Ae = new Int32Array(ce + 1);
        Ae[0] = 0;
        for (var Pe = $[Te.length - 1] / ce, ut = 1, Ue = 0; Ue < Te.length; Ue++)
          for (; $[Ue] > Pe; )
            Ae[ut++] = Ue, Pe = ut * $[Te.length - 1] / ce;
        for (Ae[ce] = Te.length - 1, Ue = 0; Ue < ce; Ue++) {
          for (var Ct = 0, At = Ae[Ue]; At < Ae[Ue + 1]; At++)
            Ct += Te[At];
          we[Ue] = Math.pow(Ct, 0.23);
        }
        for (Ue = 0; Ue < we.length; Ue++)
          ke += we[Ue];
        return { specific: we, total: ke };
      }
      function st(S) {
        var _23 = S.ampSpectrum;
        if (typeof _23 != "object")
          throw new TypeError();
        for (var $ = new Float32Array(_23.length), C = 0; C < $.length; C++)
          $[C] = Math.pow(_23[C], 2);
        return $;
      }
      function yt(S) {
        var _23 = S.ampSpectrum, $ = S.melFilterBank, C = S.bufferSize;
        if (typeof _23 != "object")
          throw new TypeError("Valid ampSpectrum is required to generate melBands");
        if (typeof $ != "object")
          throw new TypeError("Valid melFilterBank is required to generate melBands");
        for (var ee = st({ ampSpectrum: _23 }), ce = $.length, we = Array(ce), ke = new Float32Array(ce), Te = 0; Te < ke.length; Te++) {
          we[Te] = new Float32Array(C / 2), ke[Te] = 0;
          for (var Ae = 0; Ae < C / 2; Ae++)
            we[Te][Ae] = $[Te][Ae] * ee[Ae], ke[Te] += we[Te][Ae];
          ke[Te] = Math.log(ke[Te] + 1);
        }
        return Array.prototype.slice.call(ke);
      }
      function Wt(S) {
        return S && S.__esModule && Object.prototype.hasOwnProperty.call(S, "default") ? S.default : S;
      }
      var Et = {}, Be = null, it = function(S, _23) {
        var $ = S.length;
        return _23 = _23 || 2, Be && Be[$] || function(C) {
          (Be = Be || {})[C] = new Array(C * C);
          for (var ee = Math.PI / C, ce = 0; ce < C; ce++)
            for (var we = 0; we < C; we++)
              Be[C][we + ce * C] = Math.cos(ee * (we + 0.5) * ce);
        }($), S.map(function() {
          return 0;
        }).map(function(C, ee) {
          return _23 * S.reduce(function(ce, we, ke, Te) {
            return ce + we * Be[$][ke + ee * $];
          }, 0);
        });
      };
      (function(S) {
        S.exports = it;
      })({ get exports() {
        return Et;
      }, set exports(S) {
        Et = S;
      } });
      var Yt = Wt(Et), wt = Object.freeze({ __proto__: null, buffer: function(S) {
        return S.signal;
      }, rms: function(S) {
        var _23 = S.signal;
        if (typeof _23 != "object")
          throw new TypeError();
        for (var $ = 0, C = 0; C < _23.length; C++)
          $ += Math.pow(_23[C], 2);
        return $ /= _23.length, $ = Math.sqrt($);
      }, energy: function(S) {
        var _23 = S.signal;
        if (typeof _23 != "object")
          throw new TypeError();
        for (var $ = 0, C = 0; C < _23.length; C++)
          $ += Math.pow(Math.abs(_23[C]), 2);
        return $;
      }, complexSpectrum: function(S) {
        return S.complexSpectrum;
      }, spectralSlope: function(S) {
        var _23 = S.ampSpectrum, $ = S.sampleRate, C = S.bufferSize;
        if (typeof _23 != "object")
          throw new TypeError();
        for (var ee = 0, ce = 0, we = new Float32Array(_23.length), ke = 0, Te = 0, Ae = 0; Ae < _23.length; Ae++) {
          ee += _23[Ae];
          var Pe = Ae * $ / C;
          we[Ae] = Pe, ke += Pe * Pe, ce += Pe, Te += Pe * _23[Ae];
        }
        return (_23.length * Te - ce * ee) / (ee * (ke - Math.pow(ce, 2)));
      }, spectralCentroid: function(S) {
        var _23 = S.ampSpectrum;
        if (typeof _23 != "object")
          throw new TypeError();
        return We(1, _23);
      }, spectralRolloff: function(S) {
        var _23 = S.ampSpectrum, $ = S.sampleRate;
        if (typeof _23 != "object")
          throw new TypeError();
        for (var C = _23, ee = $ / (2 * (C.length - 1)), ce = 0, we = 0; we < C.length; we++)
          ce += C[we];
        for (var ke = 0.99 * ce, Te = C.length - 1; ce > ke && Te >= 0; )
          ce -= C[Te], --Te;
        return (Te + 1) * ee;
      }, spectralFlatness: function(S) {
        var _23 = S.ampSpectrum;
        if (typeof _23 != "object")
          throw new TypeError();
        for (var $ = 0, C = 0, ee = 0; ee < _23.length; ee++)
          $ += Math.log(_23[ee]), C += _23[ee];
        return Math.exp($ / _23.length) * _23.length / C;
      }, spectralSpread: function(S) {
        var _23 = S.ampSpectrum;
        if (typeof _23 != "object")
          throw new TypeError();
        return Math.sqrt(We(2, _23) - Math.pow(We(1, _23), 2));
      }, spectralSkewness: function(S) {
        var _23 = S.ampSpectrum;
        if (typeof _23 != "object")
          throw new TypeError();
        var $ = We(1, _23), C = We(2, _23), ee = We(3, _23);
        return (2 * Math.pow($, 3) - 3 * $ * C + ee) / Math.pow(Math.sqrt(C - Math.pow($, 2)), 3);
      }, spectralKurtosis: function(S) {
        var _23 = S.ampSpectrum;
        if (typeof _23 != "object")
          throw new TypeError();
        var $ = _23, C = We(1, $), ee = We(2, $), ce = We(3, $), we = We(4, $);
        return (-3 * Math.pow(C, 4) + 6 * C * ee - 4 * C * ce + we) / Math.pow(Math.sqrt(ee - Math.pow(C, 2)), 4);
      }, amplitudeSpectrum: function(S) {
        return S.ampSpectrum;
      }, zcr: function(S) {
        var _23 = S.signal;
        if (typeof _23 != "object")
          throw new TypeError();
        for (var $ = 0, C = 1; C < _23.length; C++)
          (_23[C - 1] >= 0 && _23[C] < 0 || _23[C - 1] < 0 && _23[C] >= 0) && $++;
        return $;
      }, loudness: mt, perceptualSpread: function(S) {
        for (var _23 = mt({ ampSpectrum: S.ampSpectrum, barkScale: S.barkScale }), $ = 0, C = 0; C < _23.specific.length; C++)
          _23.specific[C] > $ && ($ = _23.specific[C]);
        return Math.pow((_23.total - $) / _23.total, 2);
      }, perceptualSharpness: function(S) {
        for (var _23 = mt({ ampSpectrum: S.ampSpectrum, barkScale: S.barkScale }), $ = _23.specific, C = 0, ee = 0; ee < $.length; ee++)
          C += ee < 15 ? (ee + 1) * $[ee + 1] : 0.066 * Math.exp(0.171 * (ee + 1));
        return C *= 0.11 / _23.total;
      }, powerSpectrum: st, mfcc: function(S) {
        var _23 = S.ampSpectrum, $ = S.melFilterBank, C = S.numberOfMFCCCoefficients, ee = S.bufferSize, ce = Math.min(40, Math.max(1, C || 13));
        if ($.length < ce)
          throw new Error("Insufficient filter bank for requested number of coefficients");
        var we = yt({ ampSpectrum: _23, melFilterBank: $, bufferSize: ee });
        return Yt(we).slice(0, ce);
      }, chroma: function(S) {
        var _23 = S.ampSpectrum, $ = S.chromaFilterBank;
        if (typeof _23 != "object")
          throw new TypeError("Valid ampSpectrum is required to generate chroma");
        if (typeof $ != "object")
          throw new TypeError("Valid chromaFilterBank is required to generate chroma");
        var C = $.map(function(ce, we) {
          return _23.reduce(function(ke, Te, Ae) {
            return ke + Te * ce[Ae];
          }, 0);
        }), ee = Math.max.apply(Math, C);
        return ee ? C.map(function(ce) {
          return ce / ee;
        }) : C;
      }, spectralFlux: function(S) {
        var _23 = S.signal, $ = S.previousSignal, C = S.bufferSize;
        if (typeof _23 != "object" || typeof $ != "object")
          throw new TypeError();
        for (var ee = 0, ce = -C / 2; ce < _23.length / 2 - 1; ce++)
          x = Math.abs(_23[ce]) - Math.abs($[ce]), ee += (x + Math.abs(x)) / 2;
        return ee;
      }, spectralCrest: function(S) {
        var _23 = S.ampSpectrum;
        if (typeof _23 != "object")
          throw new TypeError();
        var $ = 0, C = -1 / 0;
        return _23.forEach(function(ee) {
          $ += Math.pow(ee, 2), C = ee > C ? ee : C;
        }), $ /= _23.length, $ = Math.sqrt($), C / $;
      }, melBands: yt });
      function Hr(S) {
        if (Array.isArray(S)) {
          for (var _23 = 0, $ = Array(S.length); _23 < S.length; _23++)
            $[_23] = S[_23];
          return $;
        }
        return Array.from(S);
      }
      var qt = {}, Sr = {}, $t = { bitReverseArray: function(S) {
        if (qt[S] === void 0) {
          for (var _23 = (S - 1).toString(2).length, $ = "0".repeat(_23), C = {}, ee = 0; ee < S; ee++) {
            var ce = ee.toString(2);
            ce = $.substr(ce.length) + ce, ce = [].concat(Hr(ce)).reverse().join(""), C[ee] = parseInt(ce, 2);
          }
          qt[S] = C;
        }
        return qt[S];
      }, multiply: function(S, _23) {
        return { real: S.real * _23.real - S.imag * _23.imag, imag: S.real * _23.imag + S.imag * _23.real };
      }, add: function(S, _23) {
        return { real: S.real + _23.real, imag: S.imag + _23.imag };
      }, subtract: function(S, _23) {
        return { real: S.real - _23.real, imag: S.imag - _23.imag };
      }, euler: function(S, _23) {
        var $ = -2 * Math.PI * S / _23;
        return { real: Math.cos($), imag: Math.sin($) };
      }, conj: function(S) {
        return S.imag *= -1, S;
      }, constructComplexArray: function(S) {
        var _23 = {};
        _23.real = S.real === void 0 ? S.slice() : S.real.slice();
        var $ = _23.real.length;
        return Sr[$] === void 0 && (Sr[$] = Array.apply(null, Array($)).map(Number.prototype.valueOf, 0)), _23.imag = Sr[$].slice(), _23;
      } }, Sn = function(S) {
        var _23 = {};
        S.real === void 0 || S.imag === void 0 ? _23 = $t.constructComplexArray(S) : (_23.real = S.real.slice(), _23.imag = S.imag.slice());
        var $ = _23.real.length, C = Math.log2($);
        if (Math.round(C) != C)
          throw new Error("Input size must be a power of 2.");
        if (_23.real.length != _23.imag.length)
          throw new Error("Real and imaginary components must have the same length.");
        for (var ee = $t.bitReverseArray($), ce = { real: [], imag: [] }, we = 0; we < $; we++)
          ce.real[ee[we]] = _23.real[we], ce.imag[ee[we]] = _23.imag[we];
        for (var ke = 0; ke < $; ke++)
          _23.real[ke] = ce.real[ke], _23.imag[ke] = ce.imag[ke];
        for (var Te = 1; Te <= C; Te++)
          for (var Ae = Math.pow(2, Te), Pe = 0; Pe < Ae / 2; Pe++)
            for (var ut = $t.euler(Pe, Ae), Ue = 0; Ue < $ / Ae; Ue++) {
              var Ct = Ae * Ue + Pe, At = Ae * Ue + Pe + Ae / 2, St = { real: _23.real[Ct], imag: _23.imag[Ct] }, Lr = { real: _23.real[At], imag: _23.imag[At] }, Qe = $t.multiply(ut, Lr), ct = $t.subtract(St, Qe);
              _23.real[At] = ct.real, _23.imag[At] = ct.imag;
              var pt = $t.add(Qe, St);
              _23.real[Ct] = pt.real, _23.imag[Ct] = pt.imag;
            }
        return _23;
      }, Tn = Sn, Wr = function() {
        function S(_23, $) {
          var C = this;
          if (this._m = $, !_23.audioContext)
            throw this._m.errors.noAC;
          if (_23.bufferSize && !J(_23.bufferSize))
            throw this._m._errors.notPow2;
          if (!_23.source)
            throw this._m._errors.noSource;
          this._m.audioContext = _23.audioContext, this._m.bufferSize = _23.bufferSize || this._m.bufferSize || 256, this._m.hopSize = _23.hopSize || this._m.hopSize || this._m.bufferSize, this._m.sampleRate = _23.sampleRate || this._m.audioContext.sampleRate || 44100, this._m.callback = _23.callback, this._m.windowingFunction = _23.windowingFunction || "hanning", this._m.featureExtractors = wt, this._m.EXTRACTION_STARTED = _23.startImmediately || false, this._m.channel = typeof _23.channel == "number" ? _23.channel : 0, this._m.inputs = _23.inputs || 1, this._m.outputs = _23.outputs || 1, this._m.numberOfMFCCCoefficients = _23.numberOfMFCCCoefficients || this._m.numberOfMFCCCoefficients || 13, this._m.numberOfBarkBands = _23.numberOfBarkBands || this._m.numberOfBarkBands || 24, this._m.spn = this._m.audioContext.createScriptProcessor(this._m.bufferSize, this._m.inputs, this._m.outputs), this._m.spn.connect(this._m.audioContext.destination), this._m._featuresToExtract = _23.featureExtractors || [], this._m.barkScale = he(this._m.bufferSize, this._m.sampleRate, this._m.bufferSize), this._m.melFilterBank = vt(Math.max(this._m.melBands, this._m.numberOfMFCCCoefficients), this._m.sampleRate, this._m.bufferSize), this._m.inputData = null, this._m.previousInputData = null, this._m.frame = null, this._m.previousFrame = null, this.setSource(_23.source), this._m.spn.onaudioprocess = function(ee) {
            var ce;
            C._m.inputData !== null && (C._m.previousInputData = C._m.inputData), C._m.inputData = ee.inputBuffer.getChannelData(C._m.channel), C._m.previousInputData ? ((ce = new Float32Array(C._m.previousInputData.length + C._m.inputData.length - C._m.hopSize)).set(C._m.previousInputData.slice(C._m.hopSize)), ce.set(C._m.inputData, C._m.previousInputData.length - C._m.hopSize)) : ce = C._m.inputData, function(we, ke, Te) {
              if (we.length < ke)
                throw new Error("Buffer is too short for frame length");
              if (Te < 1)
                throw new Error("Hop length cannot be less that 1");
              if (ke < 1)
                throw new Error("Frame length cannot be less that 1");
              var Ae = 1 + Math.floor((we.length - ke) / Te);
              return new Array(Ae).fill(0).map(function(Pe, ut) {
                return we.slice(ut * Te, ut * Te + ke);
              });
            }(ce, C._m.bufferSize, C._m.hopSize).forEach(function(we) {
              C._m.frame = we;
              var ke = C._m.extract(C._m._featuresToExtract, C._m.frame, C._m.previousFrame);
              typeof C._m.callback == "function" && C._m.EXTRACTION_STARTED && C._m.callback(ke), C._m.previousFrame = C._m.frame;
            });
          };
        }
        return S.prototype.start = function(_23) {
          this._m._featuresToExtract = _23 || this._m._featuresToExtract, this._m.EXTRACTION_STARTED = true;
        }, S.prototype.stop = function() {
          this._m.EXTRACTION_STARTED = false;
        }, S.prototype.setSource = function(_23) {
          this._m.source && this._m.source.disconnect(this._m.spn), this._m.source = _23, this._m.source.connect(this._m.spn);
        }, S.prototype.setChannel = function(_23) {
          _23 <= this._m.inputs ? this._m.channel = _23 : console.error("Channel ".concat(_23, " does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(_23, " when instantiating the MeydaAnalyzer"));
        }, S.prototype.get = function(_23) {
          return this._m.inputData ? this._m.extract(_23 || this._m._featuresToExtract, this._m.inputData, this._m.previousInputData) : null;
        }, S;
      }(), Tr = { audioContext: null, spn: null, bufferSize: 512, sampleRate: 44100, melBands: 26, chromaBands: 12, callback: null, windowingFunction: "hanning", featureExtractors: wt, EXTRACTION_STARTED: false, numberOfMFCCCoefficients: 13, numberOfBarkBands: 24, _featuresToExtract: [], windowing: Se, _errors: { notPow2: new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"), featureUndef: new Error("Meyda: No features defined."), invalidFeatureFmt: new Error("Meyda: Invalid feature format"), invalidInput: new Error("Meyda: Invalid input."), noAC: new Error("Meyda: No AudioContext specified."), noSource: new Error("Meyda: No source node specified.") }, createMeydaAnalyzer: function(S) {
        return new Wr(S, Object.assign({}, Tr));
      }, listAvailableFeatureExtractors: function() {
        return Object.keys(this.featureExtractors);
      }, extract: function(S, _23, $) {
        var C = this;
        if (!_23)
          throw this._errors.invalidInput;
        if (typeof _23 != "object")
          throw this._errors.invalidInput;
        if (!S)
          throw this._errors.featureUndef;
        if (!J(_23.length))
          throw this._errors.notPow2;
        this.barkScale !== void 0 && this.barkScale.length == this.bufferSize || (this.barkScale = he(this.bufferSize, this.sampleRate, this.bufferSize)), this.melFilterBank !== void 0 && this.barkScale.length == this.bufferSize && this.melFilterBank.length == this.melBands || (this.melFilterBank = vt(Math.max(this.melBands, this.numberOfMFCCCoefficients), this.sampleRate, this.bufferSize)), this.chromaFilterBank !== void 0 && this.chromaFilterBank.length == this.chromaBands || (this.chromaFilterBank = He(this.chromaBands, this.sampleRate, this.bufferSize)), "buffer" in _23 && _23.buffer === void 0 ? this.signal = Ie(_23) : this.signal = _23;
        var ee = Kt(_23, this.windowingFunction, this.bufferSize);
        if (this.signal = ee.windowedSignal, this.complexSpectrum = ee.complexSpectrum, this.ampSpectrum = ee.ampSpectrum, $) {
          var ce = Kt($, this.windowingFunction, this.bufferSize);
          this.previousSignal = ce.windowedSignal, this.previousComplexSpectrum = ce.complexSpectrum, this.previousAmpSpectrum = ce.ampSpectrum;
        }
        var we = function(ke) {
          return C.featureExtractors[ke]({ ampSpectrum: C.ampSpectrum, chromaFilterBank: C.chromaFilterBank, complexSpectrum: C.complexSpectrum, signal: C.signal, bufferSize: C.bufferSize, sampleRate: C.sampleRate, barkScale: C.barkScale, melFilterBank: C.melFilterBank, previousSignal: C.previousSignal, previousAmpSpectrum: C.previousAmpSpectrum, previousComplexSpectrum: C.previousComplexSpectrum, numberOfMFCCCoefficients: C.numberOfMFCCCoefficients, numberOfBarkBands: C.numberOfBarkBands });
        };
        if (typeof S == "object")
          return S.reduce(function(ke, Te) {
            var Ae;
            return Object.assign({}, ke, ((Ae = {})[Te] = we(Te), Ae));
          }, {});
        if (typeof S == "string")
          return we(S);
        throw this._errors.invalidFeatureFmt;
      } }, Kt = function(S, _23, $) {
        var C = {};
        S.buffer === void 0 ? C.signal = Ie(S) : C.signal = S, C.windowedSignal = Se(C.signal, _23), C.complexSpectrum = Tn(C.windowedSignal), C.ampSpectrum = new Float32Array($ / 2);
        for (var ee = 0; ee < $ / 2; ee++)
          C.ampSpectrum[ee] = Math.sqrt(Math.pow(C.complexSpectrum.real[ee], 2) + Math.pow(C.complexSpectrum.imag[ee], 2));
        return C;
      };
      return typeof window < "u" && (window.Meyda = Tr), Tr;
    });
  })(meyda_min);
  var meyda_minExports = meyda_min.exports;
  const Meyda = /* @__PURE__ */ getDefaultExportFromCjs(meyda_minExports);
  class Audio {
    constructor({
      numBins: c = 4,
      cutoff: h2 = 2,
      smooth: w = 0.4,
      max: D = 15,
      scale: J = 10,
      isDrawing: Se = false,
      parentEl: he = document.body
    }) {
      this.vol = 0, this.scale = J, this.max = D, this.cutoff = h2, this.smooth = w, this.setBins(c), this.beat = {
        holdFrames: 20,
        threshold: 40,
        _cutoff: 0,
        // adaptive based on sound state
        decay: 0.98,
        _framesSinceBeat: 0
        // keeps track of frames
      }, this.onBeat = () => {
      }, this.canvas = document.createElement("canvas"), this.canvas.width = 100, this.canvas.height = 80, this.canvas.style.width = "100px", this.canvas.style.height = "80px", this.canvas.style.position = "absolute", this.canvas.style.right = "0px", this.canvas.style.bottom = "0px", he.appendChild(this.canvas), this.isDrawing = Se, this.ctx = this.canvas.getContext("2d"), this.ctx.fillStyle = "#DFFFFF", this.ctx.strokeStyle = "#0ff", this.ctx.lineWidth = 0.5, window.navigator.mediaDevices && window.navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then((Ie) => {
        this.stream = Ie, this.context = new AudioContext();
        let be = this.context.createMediaStreamSource(Ie);
        this.meyda = Meyda.createMeydaAnalyzer({
          audioContext: this.context,
          source: be,
          featureExtractors: [
            "loudness"
            //  'perceptualSpread',
            //  'perceptualSharpness',
            //  'spectralCentroid'
          ]
        });
      }).catch((Ie) => console.log("ERROR", Ie));
    }
    detectBeat(c) {
      c > this.beat._cutoff && c > this.beat.threshold ? (this.onBeat(), this.beat._cutoff = c * 1.2, this.beat._framesSinceBeat = 0) : this.beat._framesSinceBeat <= this.beat.holdFrames ? this.beat._framesSinceBeat++ : (this.beat._cutoff *= this.beat.decay, this.beat._cutoff = Math.max(this.beat._cutoff, this.beat.threshold));
    }
    tick() {
      if (this.meyda) {
        var c = this.meyda.get();
        if (c && c !== null) {
          this.vol = c.loudness.total, this.detectBeat(this.vol);
          const h2 = (D, J) => D + J;
          let w = Math.floor(c.loudness.specific.length / this.bins.length);
          this.prevBins = this.bins.slice(0), this.bins = this.bins.map((D, J) => c.loudness.specific.slice(J * w, (J + 1) * w).reduce(h2)).map((D, J) => D * (1 - this.settings[J].smooth) + this.prevBins[J] * this.settings[J].smooth), this.fft = this.bins.map((D, J) => (
            // Math.max(0, (bin - this.cutoff) / (this.max - this.cutoff))
            Math.max(0, (D - this.settings[J].cutoff) / this.settings[J].scale)
          )), this.isDrawing && this.draw();
        }
      }
    }
    setCutoff(c) {
      this.cutoff = c, this.settings = this.settings.map((h2) => (h2.cutoff = c, h2));
    }
    setSmooth(c) {
      this.smooth = c, this.settings = this.settings.map((h2) => (h2.smooth = c, h2));
    }
    setBins(c) {
      this.bins = Array(c).fill(0), this.prevBins = Array(c).fill(0), this.fft = Array(c).fill(0), this.settings = Array(c).fill(0).map(() => ({
        cutoff: this.cutoff,
        scale: this.scale,
        smooth: this.smooth
      })), this.bins.forEach((h2, w) => {
        window["a" + w] = (D = 1, J = 0) => () => a.fft[w] * D + J;
      });
    }
    setScale(c) {
      this.scale = c, this.settings = this.settings.map((h2) => (h2.scale = c, h2));
    }
    setMax(c) {
      this.max = c, console.log("set max is deprecated");
    }
    hide() {
      this.isDrawing = false, this.canvas.style.display = "none";
    }
    show() {
      this.isDrawing = true, this.canvas.style.display = "block";
    }
    draw() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      var c = this.canvas.width / this.bins.length, h2 = this.canvas.height / (this.max * 2);
      this.bins.forEach((w, D) => {
        var J = w * h2;
        this.ctx.fillRect(D * c, this.canvas.height - J, c, J);
        var Se = this.canvas.height - h2 * this.settings[D].cutoff;
        this.ctx.beginPath(), this.ctx.moveTo(D * c, Se), this.ctx.lineTo((D + 1) * c, Se), this.ctx.stroke();
        var he = this.canvas.height - h2 * (this.settings[D].scale + this.settings[D].cutoff);
        this.ctx.beginPath(), this.ctx.moveTo(D * c, he), this.ctx.lineTo((D + 1) * c, he), this.ctx.stroke();
      });
    }
  }
  class VideoRecorder {
    constructor(c) {
      this.mediaSource = new MediaSource(), this.stream = c, this.output = document.createElement("video"), this.output.autoplay = true, this.output.loop = true;
      let h2 = this;
      this.mediaSource.addEventListener("sourceopen", () => {
        console.log("MediaSource opened"), h2.sourceBuffer = h2.mediaSource.addSourceBuffer('video/webm; codecs="vp8"'), console.log("Source buffer: ", sourceBuffer);
      });
    }
    start() {
      let c = { mimeType: "video/webm;codecs=vp9" };
      this.recordedBlobs = [];
      try {
        this.mediaRecorder = new MediaRecorder(this.stream, c);
      } catch (h2) {
        console.log("Unable to create MediaRecorder with options Object: ", h2);
        try {
          c = { mimeType: "video/webm,codecs=vp9" }, this.mediaRecorder = new MediaRecorder(this.stream, c);
        } catch (w) {
          console.log("Unable to create MediaRecorder with options Object: ", w);
          try {
            c = "video/vp8", this.mediaRecorder = new MediaRecorder(this.stream, c);
          } catch (D) {
            alert(`MediaRecorder is not supported by this browser.

Try Firefox 29 or later, or Chrome 47 or later, with Enable experimental Web Platform features enabled from chrome://flags.`), console.error("Exception while creating MediaRecorder:", D);
            return;
          }
        }
      }
      console.log("Created MediaRecorder", this.mediaRecorder, "with options", c), this.mediaRecorder.onstop = this._handleStop.bind(this), this.mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this), this.mediaRecorder.start(100), console.log("MediaRecorder started", this.mediaRecorder);
    }
    stop() {
      this.mediaRecorder.stop();
    }
    _handleStop() {
      const c = new Blob(this.recordedBlobs, { type: this.mediaRecorder.mimeType }), h2 = window.URL.createObjectURL(c);
      this.output.src = h2;
      const w = document.createElement("a");
      w.style.display = "none", w.href = h2;
      let D = /* @__PURE__ */ new Date();
      w.download = `hydra-${D.getFullYear()}-${D.getMonth() + 1}-${D.getDate()}-${D.getHours()}.${D.getMinutes()}.${D.getSeconds()}.webm`, document.body.appendChild(w), w.click(), setTimeout(() => {
        document.body.removeChild(w), window.URL.revokeObjectURL(h2);
      }, 300);
    }
    _handleDataAvailable(c) {
      c.data && c.data.size > 0 && this.recordedBlobs.push(c.data);
    }
  }
  const easing = {
    // no easing, no acceleration
    linear: function(o) {
      return o;
    },
    // accelerating from zero velocity
    easeInQuad: function(o) {
      return o * o;
    },
    // decelerating to zero velocity
    easeOutQuad: function(o) {
      return o * (2 - o);
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad: function(o) {
      return o < 0.5 ? 2 * o * o : -1 + (4 - 2 * o) * o;
    },
    // accelerating from zero velocity
    easeInCubic: function(o) {
      return o * o * o;
    },
    // decelerating to zero velocity
    easeOutCubic: function(o) {
      return --o * o * o + 1;
    },
    // acceleration until halfway, then deceleration
    easeInOutCubic: function(o) {
      return o < 0.5 ? 4 * o * o * o : (o - 1) * (2 * o - 2) * (2 * o - 2) + 1;
    },
    // accelerating from zero velocity
    easeInQuart: function(o) {
      return o * o * o * o;
    },
    // decelerating to zero velocity
    easeOutQuart: function(o) {
      return 1 - --o * o * o * o;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart: function(o) {
      return o < 0.5 ? 8 * o * o * o * o : 1 - 8 * --o * o * o * o;
    },
    // accelerating from zero velocity
    easeInQuint: function(o) {
      return o * o * o * o * o;
    },
    // decelerating to zero velocity
    easeOutQuint: function(o) {
      return 1 + --o * o * o * o * o;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuint: function(o) {
      return o < 0.5 ? 16 * o * o * o * o * o : 1 + 16 * --o * o * o * o * o;
    },
    // sin shape
    sin: function(o) {
      return (1 + Math.sin(Math.PI * o - Math.PI / 2)) / 2;
    }
  };
  var map = (o, c, h2, w, D) => (o - c) * (D - w) / (h2 - c) + w;
  const ArrayUtils = {
    init: () => {
      Array.prototype.fast = function(o = 1) {
        return this._speed = o, this;
      }, Array.prototype.smooth = function(o = 1) {
        return this._smooth = o, this;
      }, Array.prototype.ease = function(o = "linear") {
        return typeof o == "function" ? (this._smooth = 1, this._ease = o) : easing[o] && (this._smooth = 1, this._ease = easing[o]), this;
      }, Array.prototype.offset = function(o = 0.5) {
        return this._offset = o % 1, this;
      }, Array.prototype.fit = function(o = 0, c = 1) {
        let h2 = Math.min(...this), w = Math.max(...this);
        var D = this.map((J) => map(J, h2, w, o, c));
        return D._speed = this._speed, D._smooth = this._smooth, D._ease = this._ease, D;
      };
    },
    getValue: (o = []) => ({ time: c, bpm: h2 }) => {
      let w = o._speed ? o._speed : 1, D = o._smooth ? o._smooth : 0, J = c * w * (h2 / 60) + (o._offset || 0);
      if (D !== 0) {
        let Se = o._ease ? o._ease : easing.linear, he = J - D / 2, Ie = o[Math.floor(he % o.length)], be = o[Math.floor((he + 1) % o.length)], vt = Math.min(he % 1 / D, 1);
        return Se(vt) * (be - Ie) + Ie;
      } else
        return o[Math.floor(J % o.length)], o[Math.floor(J % o.length)];
    }
  }, Sandbox = (parent) => {
    var initialCode = "", sandbox = createSandbox(initialCode), addToContext = (o, c) => {
      initialCode += `
      var ${o} = ${c}
    `, sandbox = createSandbox(initialCode);
    };
    return {
      addToContext,
      eval: (o) => sandbox.eval(o)
    };
    function createSandbox(initial) {
      eval(initial);
      var localEval = function(code) {
        eval(code);
      };
      return {
        eval: localEval
      };
    }
  };
  class EvalSandbox {
    constructor(c, h2, w = []) {
      this.makeGlobal = h2, this.sandbox = Sandbox(), this.parent = c;
      var D = Object.keys(c);
      D.forEach((J) => this.add(J)), this.userProps = w;
    }
    add(c) {
      this.makeGlobal && (window[c] = this.parent[c]), this.sandbox.addToContext(c, `parent.${c}`);
    }
    // sets on window as well as synth object if window (not needed for objects, which can be set directly)
    set(c, h2) {
      this.makeGlobal && (window[c] = h2), this.parent[c] = h2;
    }
    tick() {
      this.makeGlobal && this.userProps.forEach((c) => {
        this.parent[c] = window[c];
      });
    }
    eval(c) {
      this.sandbox.eval(c);
    }
  }
  const DEFAULT_CONVERSIONS = {
    float: {
      vec4: { name: "sum", args: [[1, 1, 1, 1]] },
      vec2: { name: "sum", args: [[1, 1]] }
    }
  }, ensure_decimal_dot = (o) => (o = o.toString(), o.indexOf(".") < 0 && (o += "."), o);
  function formatArguments(o, c, h2) {
    const w = o.transform.inputs, D = o.userArgs, { generators: J } = o.synth, { src: Se } = J;
    return w.map((he, Ie) => {
      const be = {
        value: he.default,
        type: he.type,
        //
        isUniform: false,
        name: he.name,
        vecLen: 0
        //  generateGlsl: null // function for creating glsl
      };
      if (be.type === "float" && (be.value = ensure_decimal_dot(he.default)), he.type.startsWith("vec"))
        try {
          be.vecLen = Number.parseInt(he.type.substr(3));
        } catch {
          console.log(`Error determining length of vector input type ${he.type} (${he.name})`);
        }
      if (D.length > Ie && (be.value = D[Ie], typeof D[Ie] == "function" ? (be.value = (We, mt, st) => {
        try {
          const yt = D[Ie](mt);
          return typeof yt == "number" ? yt : (console.warn("function does not return a number", D[Ie]), he.default);
        } catch (yt) {
          return console.warn("ERROR", yt), he.default;
        }
      }, be.isUniform = true) : D[Ie].constructor === Array && (be.value = (We, mt, st) => ArrayUtils.getValue(D[Ie])(mt), be.isUniform = true)), !(c < 0)) {
        if (be.value && be.value.transforms) {
          const We = be.value.transforms[be.value.transforms.length - 1];
          if (We.transform.glsl_return_type !== he.type) {
            const mt = DEFAULT_CONVERSIONS[he.type];
            if (typeof mt < "u") {
              const st = mt[We.transform.glsl_return_type];
              if (typeof st < "u") {
                const { name: yt, args: Wt } = st;
                be.value = be.value[yt](...Wt);
              }
            }
          }
          be.isUniform = false;
        } else if (be.type === "float" && typeof be.value == "number")
          be.value = ensure_decimal_dot(be.value);
        else if (be.type.startsWith("vec") && typeof be.value == "object" && Array.isArray(be.value))
          be.isUniform = false, be.value = `${be.type}(${be.value.map(ensure_decimal_dot).join(", ")})`;
        else if (he.type === "sampler2D") {
          var vt = be.value;
          be.value = () => vt.getTexture(), be.isUniform = true;
        } else if (be.value.getTexture && he.type === "vec4") {
          var He = be.value;
          be.value = Se(He), be.isUniform = false;
        }
        be.isUniform && (be.name += c);
      }
      return be;
    });
  }
  function generateGlsl(o) {
    var c = {
      uniforms: [],
      // list of uniforms used in shader
      glslFunctions: [],
      // list of functions used in shader
      fragColor: ""
    }, h2 = generateGlsl$1(o, c)("st");
    c.fragColor = h2;
    let w = {};
    return c.uniforms.forEach((D) => w[D.name] = D), c.uniforms = Object.values(w), c;
  }
  function generateGlsl$1(o, c) {
    var h2 = () => "";
    return o.forEach((w) => {
      var D = formatArguments(w, c.uniforms.length);
      D.forEach((he) => {
        he.isUniform && c.uniforms.push(he);
      }), contains(w, c.glslFunctions) || c.glslFunctions.push(w);
      var J = h2;
      if (w.transform.type === "src")
        h2 = (he) => `${shaderString(he, w.name, D, c)}`;
      else if (w.transform.type === "coord")
        h2 = (he) => `${J(`${shaderString(he, w.name, D, c)}`)}`;
      else if (w.transform.type === "color")
        h2 = (he) => `${shaderString(`${J(he)}`, w.name, D, c)}`;
      else if (w.transform.type === "combine") {
        var Se = D[0].value && D[0].value.transforms ? (he) => `${generateGlsl$1(D[0].value.transforms, c)(he)}` : D[0].isUniform ? () => D[0].name : () => D[0].value;
        h2 = (he) => `${shaderString(`${J(he)}, ${Se(he)}`, w.name, D.slice(1), c)}`;
      } else if (w.transform.type === "combineCoord") {
        var Se = D[0].value && D[0].value.transforms ? (Ie) => `${generateGlsl$1(D[0].value.transforms, c)(Ie)}` : D[0].isUniform ? () => D[0].name : () => D[0].value;
        h2 = (Ie) => `${J(`${shaderString(`${Ie}, ${Se(Ie)}`, w.name, D.slice(1), c)}`)}`;
      }
    }), h2;
  }
  function shaderString(o, c, h2, w) {
    const D = h2.map((J) => J.isUniform ? J.name : J.value && J.value.transforms ? `${generateGlsl$1(J.value.transforms, w)("st")}` : J.value).reduce((J, Se) => `${J}, ${Se}`, "");
    return `${c}(${o}${D})`;
  }
  function contains(o, c) {
    for (var h2 = 0; h2 < c.length; h2++)
      if (o.name == c[h2].name)
        return true;
    return false;
  }
  const utilityGlsl = {
    _luminance: {
      type: "util",
      glsl: `float _luminance(vec3 rgb){
      const vec3 W = vec3(0.2125, 0.7154, 0.0721);
      return dot(rgb, W);
    }`
    },
    _noise: {
      type: "util",
      glsl: `
    //	Simplex 3D Noise
    //	by Ian McEwan, Ashima Arts
    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
  vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

  float _noise(vec3 v){
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    //  x0 = x0 - 0. + 0.0 * C
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
    i = mod(i, 289.0 );
    vec4 p = permute( permute( permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
    float n_ = 1.0/7.0; // N=7
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

  //Normalise gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

  // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
  }
    `
    },
    _rgbToHsv: {
      type: "util",
      glsl: `vec3 _rgbToHsv(vec3 c){
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }`
    },
    _hsvToRgb: {
      type: "util",
      glsl: `vec3 _hsvToRgb(vec3 c){
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }`
    }
  };
  var GlslSource = function(o) {
    return this.transforms = [], this.transforms.push(o), this.defaultOutput = o.defaultOutput, this.synth = o.synth, this.type = "GlslSource", this.defaultUniforms = o.defaultUniforms, this;
  };
  GlslSource.prototype.addTransform = function(o) {
    this.transforms.push(o);
  };
  GlslSource.prototype.out = function(o) {
    var c = o || this.defaultOutput, h2 = this.glsl(c);
    if (this.synth.currentFunctions = [], c)
      try {
        c.render(h2);
      } catch (w) {
        console.log("shader could not compile", w);
      }
  };
  GlslSource.prototype.glsl = function() {
    var o = [], c = [];
    return this.transforms.forEach((h2) => {
      h2.transform.type === "renderpass" ? console.warn("no support for renderpass") : c.push(h2);
    }), c.length > 0 && o.push(this.compile(c)), o;
  };
  GlslSource.prototype.compile = function(o) {
    var c = generateGlsl(o, this.synth), h2 = {};
    c.uniforms.forEach((D) => {
      h2[D.name] = D.value;
    });
    var w = `
  precision ${this.defaultOutput.precision} float;
  ${Object.values(c.uniforms).map((D) => {
      let J = D.type;
      switch (D.type) {
        case "texture":
          J = "sampler2D";
          break;
      }
      return `
      uniform ${J} ${D.name};`;
    }).join("")}
  uniform float time;
  uniform vec2 resolution;
  varying vec2 uv;
  uniform sampler2D prevBuffer;

  ${Object.values(utilityGlsl).map((D) => `
            ${D.glsl}
          `).join("")}

  ${c.glslFunctions.map((D) => `
            ${D.transform.glsl}
          `).join("")}

  void main () {
    vec4 c = vec4(1, 0, 0, 1);
    vec2 st = gl_FragCoord.xy/resolution.xy;
    gl_FragColor = ${c.fragColor};
  }
  `;
    return {
      frag: w,
      uniforms: Object.assign({}, this.defaultUniforms, h2)
    };
  };
  const glslFunctions = () => [
    {
      name: "noise",
      type: "src",
      inputs: [
        {
          type: "float",
          name: "scale",
          default: 10
        },
        {
          type: "float",
          name: "offset",
          default: 0.1
        }
      ],
      glsl: "   return vec4(vec3(_noise(vec3(_st*scale, offset*time))), 1.0);"
    },
    {
      name: "voronoi",
      type: "src",
      inputs: [
        {
          type: "float",
          name: "scale",
          default: 5
        },
        {
          type: "float",
          name: "speed",
          default: 0.3
        },
        {
          type: "float",
          name: "blending",
          default: 0.3
        }
      ],
      glsl: `   vec3 color = vec3(.0);
   // Scale
   _st *= scale;
   // Tile the space
   vec2 i_st = floor(_st);
   vec2 f_st = fract(_st);
   float m_dist = 10.;  // minimun distance
   vec2 m_point;        // minimum point
   for (int j=-1; j<=1; j++ ) {
   for (int i=-1; i<=1; i++ ) {
   vec2 neighbor = vec2(float(i),float(j));
   vec2 p = i_st + neighbor;
   vec2 point = fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
   point = 0.5 + 0.5*sin(time*speed + 6.2831*point);
   vec2 diff = neighbor + point - f_st;
   float dist = length(diff);
   if( dist < m_dist ) {
   m_dist = dist;
   m_point = point;
   }
   }
   }
   // Assign a color using the closest point position
   color += dot(m_point,vec2(.3,.6));
   color *= 1.0 - blending*m_dist;
   return vec4(color, 1.0);`
    },
    {
      name: "osc",
      type: "src",
      inputs: [
        {
          type: "float",
          name: "frequency",
          default: 60
        },
        {
          type: "float",
          name: "sync",
          default: 0.1
        },
        {
          type: "float",
          name: "offset",
          default: 0
        }
      ],
      glsl: `   vec2 st = _st;
   float r = sin((st.x-offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   float g = sin((st.x+time*sync)*frequency)*0.5 + 0.5;
   float b = sin((st.x+offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   return vec4(r, g, b, 1.0);`
    },
    {
      name: "shape",
      type: "src",
      inputs: [
        {
          type: "float",
          name: "sides",
          default: 3
        },
        {
          type: "float",
          name: "radius",
          default: 0.3
        },
        {
          type: "float",
          name: "smoothing",
          default: 0.01
        }
      ],
      glsl: `   vec2 st = _st * 2. - 1.;
   // Angle and radius from the current pixel
   float a = atan(st.x,st.y)+3.1416;
   float r = (2.*3.1416)/sides;
   float d = cos(floor(.5+a/r)*r-a)*length(st);
   return vec4(vec3(1.0-smoothstep(radius,radius + smoothing + 0.0000001,d)), 1.0);`
    },
    {
      name: "gradient",
      type: "src",
      inputs: [
        {
          type: "float",
          name: "speed",
          default: 0
        }
      ],
      glsl: "   return vec4(_st, sin(time*speed), 1.0);"
    },
    {
      name: "src",
      type: "src",
      inputs: [
        {
          type: "sampler2D",
          name: "tex",
          default: NaN
        }
      ],
      glsl: `   //  vec2 uv = gl_FragCoord.xy/vec2(1280., 720.);
   return texture2D(tex, fract(_st));`
    },
    {
      name: "solid",
      type: "src",
      inputs: [
        {
          type: "float",
          name: "r",
          default: 0
        },
        {
          type: "float",
          name: "g",
          default: 0
        },
        {
          type: "float",
          name: "b",
          default: 0
        },
        {
          type: "float",
          name: "a",
          default: 1
        }
      ],
      glsl: "   return vec4(r, g, b, a);"
    },
    {
      name: "rotate",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "angle",
          default: 10
        },
        {
          type: "float",
          name: "speed",
          default: 0
        }
      ],
      glsl: `   vec2 xy = _st - vec2(0.5);
   float ang = angle + speed *time;
   xy = mat2(cos(ang),-sin(ang), sin(ang),cos(ang))*xy;
   xy += 0.5;
   return xy;`
    },
    {
      name: "scale",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 1.5
        },
        {
          type: "float",
          name: "xMult",
          default: 1
        },
        {
          type: "float",
          name: "yMult",
          default: 1
        },
        {
          type: "float",
          name: "offsetX",
          default: 0.5
        },
        {
          type: "float",
          name: "offsetY",
          default: 0.5
        }
      ],
      glsl: `   vec2 xy = _st - vec2(offsetX, offsetY);
   xy*=(1.0/vec2(amount*xMult, amount*yMult));
   xy+=vec2(offsetX, offsetY);
   return xy;
   `
    },
    {
      name: "pixelate",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "pixelX",
          default: 20
        },
        {
          type: "float",
          name: "pixelY",
          default: 20
        }
      ],
      glsl: `   vec2 xy = vec2(pixelX, pixelY);
   return (floor(_st * xy) + 0.5)/xy;`
    },
    {
      name: "posterize",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "bins",
          default: 3
        },
        {
          type: "float",
          name: "gamma",
          default: 0.6
        }
      ],
      glsl: `   vec4 c2 = pow(_c0, vec4(gamma));
   c2 *= vec4(bins);
   c2 = floor(c2);
   c2/= vec4(bins);
   c2 = pow(c2, vec4(1.0/gamma));
   return vec4(c2.xyz, _c0.a);`
    },
    {
      name: "shift",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "r",
          default: 0.5
        },
        {
          type: "float",
          name: "g",
          default: 0
        },
        {
          type: "float",
          name: "b",
          default: 0
        },
        {
          type: "float",
          name: "a",
          default: 0
        }
      ],
      glsl: `   vec4 c2 = vec4(_c0);
   c2.r = fract(c2.r + r);
   c2.g = fract(c2.g + g);
   c2.b = fract(c2.b + b);
   c2.a = fract(c2.a + a);
   return vec4(c2.rgba);`
    },
    {
      name: "repeat",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "repeatX",
          default: 3
        },
        {
          type: "float",
          name: "repeatY",
          default: 3
        },
        {
          type: "float",
          name: "offsetX",
          default: 0
        },
        {
          type: "float",
          name: "offsetY",
          default: 0
        }
      ],
      glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) * offsetX;
   st.y += step(1., mod(st.x,2.0)) * offsetY;
   return fract(st);`
    },
    {
      name: "modulateRepeat",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "repeatX",
          default: 3
        },
        {
          type: "float",
          name: "repeatY",
          default: 3
        },
        {
          type: "float",
          name: "offsetX",
          default: 0.5
        },
        {
          type: "float",
          name: "offsetY",
          default: 0.5
        }
      ],
      glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offsetX;
   st.y += step(1., mod(st.x,2.0)) + _c0.g * offsetY;
   return fract(st);`
    },
    {
      name: "repeatX",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "reps",
          default: 3
        },
        {
          type: "float",
          name: "offset",
          default: 0
        }
      ],
      glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0))* offset;
   return fract(st);`
    },
    {
      name: "modulateRepeatX",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "reps",
          default: 3
        },
        {
          type: "float",
          name: "offset",
          default: 0.5
        }
      ],
      glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0)) + _c0.r * offset;
   return fract(st);`
    },
    {
      name: "repeatY",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "reps",
          default: 3
        },
        {
          type: "float",
          name: "offset",
          default: 0
        }
      ],
      glsl: `   vec2 st = _st * vec2(1.0, reps);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0))* offset;
   return fract(st);`
    },
    {
      name: "modulateRepeatY",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "reps",
          default: 3
        },
        {
          type: "float",
          name: "offset",
          default: 0.5
        }
      ],
      glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offset;
   return fract(st);`
    },
    {
      name: "kaleid",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "nSides",
          default: 4
        }
      ],
      glsl: `   vec2 st = _st;
   st -= 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return r*vec2(cos(a), sin(a));`
    },
    {
      name: "modulateKaleid",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "nSides",
          default: 4
        }
      ],
      glsl: `   vec2 st = _st - 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return (_c0.r+r)*vec2(cos(a), sin(a));`
    },
    {
      name: "scroll",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "scrollX",
          default: 0.5
        },
        {
          type: "float",
          name: "scrollY",
          default: 0.5
        },
        {
          type: "float",
          name: "speedX",
          default: 0
        },
        {
          type: "float",
          name: "speedY",
          default: 0
        }
      ],
      glsl: `
   _st.x += scrollX + time*speedX;
   _st.y += scrollY + time*speedY;
   return fract(_st);`
    },
    {
      name: "scrollX",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "scrollX",
          default: 0.5
        },
        {
          type: "float",
          name: "speed",
          default: 0
        }
      ],
      glsl: `   _st.x += scrollX + time*speed;
   return fract(_st);`
    },
    {
      name: "modulateScrollX",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "scrollX",
          default: 0.5
        },
        {
          type: "float",
          name: "speed",
          default: 0
        }
      ],
      glsl: `   _st.x += _c0.r*scrollX + time*speed;
   return fract(_st);`
    },
    {
      name: "scrollY",
      type: "coord",
      inputs: [
        {
          type: "float",
          name: "scrollY",
          default: 0.5
        },
        {
          type: "float",
          name: "speed",
          default: 0
        }
      ],
      glsl: `   _st.y += scrollY + time*speed;
   return fract(_st);`
    },
    {
      name: "modulateScrollY",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "scrollY",
          default: 0.5
        },
        {
          type: "float",
          name: "speed",
          default: 0
        }
      ],
      glsl: `   _st.y += _c0.r*scrollY + time*speed;
   return fract(_st);`
    },
    {
      name: "add",
      type: "combine",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 1
        }
      ],
      glsl: "   return (_c0+_c1)*amount + _c0*(1.0-amount);"
    },
    {
      name: "sub",
      type: "combine",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 1
        }
      ],
      glsl: "   return (_c0-_c1)*amount + _c0*(1.0-amount);"
    },
    {
      name: "layer",
      type: "combine",
      inputs: [],
      glsl: "   return vec4(mix(_c0.rgb, _c1.rgb, _c1.a), clamp(_c0.a + _c1.a, 0.0, 1.0));"
    },
    {
      name: "blend",
      type: "combine",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 0.5
        }
      ],
      glsl: "   return _c0*(1.0-amount)+_c1*amount;"
    },
    {
      name: "mult",
      type: "combine",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 1
        }
      ],
      glsl: "   return _c0*(1.0-amount)+(_c0*_c1)*amount;"
    },
    {
      name: "diff",
      type: "combine",
      inputs: [],
      glsl: "   return vec4(abs(_c0.rgb-_c1.rgb), max(_c0.a, _c1.a));"
    },
    {
      name: "modulate",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 0.1
        }
      ],
      glsl: `   //  return fract(st+(_c0.xy-0.5)*amount);
   return _st + _c0.xy*amount;`
    },
    {
      name: "modulateScale",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "multiple",
          default: 1
        },
        {
          type: "float",
          name: "offset",
          default: 1
        }
      ],
      glsl: `   vec2 xy = _st - vec2(0.5);
   xy*=(1.0/vec2(offset + multiple*_c0.r, offset + multiple*_c0.g));
   xy+=vec2(0.5);
   return xy;`
    },
    {
      name: "modulatePixelate",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "multiple",
          default: 10
        },
        {
          type: "float",
          name: "offset",
          default: 3
        }
      ],
      glsl: `   vec2 xy = vec2(offset + _c0.x*multiple, offset + _c0.y*multiple);
   return (floor(_st * xy) + 0.5)/xy;`
    },
    {
      name: "modulateRotate",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "multiple",
          default: 1
        },
        {
          type: "float",
          name: "offset",
          default: 0
        }
      ],
      glsl: `   vec2 xy = _st - vec2(0.5);
   float angle = offset + _c0.x * multiple;
   xy = mat2(cos(angle),-sin(angle), sin(angle),cos(angle))*xy;
   xy += 0.5;
   return xy;`
    },
    {
      name: "modulateHue",
      type: "combineCoord",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 1
        }
      ],
      glsl: "   return _st + (vec2(_c0.g - _c0.r, _c0.b - _c0.g) * amount * 1.0/resolution);"
    },
    {
      name: "invert",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 1
        }
      ],
      glsl: "   return vec4((1.0-_c0.rgb)*amount + _c0.rgb*(1.0-amount), _c0.a);"
    },
    {
      name: "contrast",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 1.6
        }
      ],
      glsl: `   vec4 c = (_c0-vec4(0.5))*vec4(amount) + vec4(0.5);
   return vec4(c.rgb, _c0.a);`
    },
    {
      name: "brightness",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 0.4
        }
      ],
      glsl: "   return vec4(_c0.rgb + vec3(amount), _c0.a);"
    },
    {
      name: "mask",
      type: "combine",
      inputs: [],
      glsl: `   float a = _luminance(_c1.rgb);
  return vec4(_c0.rgb*a, a*_c0.a);`
    },
    {
      name: "luma",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "threshold",
          default: 0.5
        },
        {
          type: "float",
          name: "tolerance",
          default: 0.1
        }
      ],
      glsl: `   float a = smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb));
   return vec4(_c0.rgb*a, a);`
    },
    {
      name: "thresh",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "threshold",
          default: 0.5
        },
        {
          type: "float",
          name: "tolerance",
          default: 0.04
        }
      ],
      glsl: "   return vec4(vec3(smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb))), _c0.a);"
    },
    {
      name: "color",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "r",
          default: 1
        },
        {
          type: "float",
          name: "g",
          default: 1
        },
        {
          type: "float",
          name: "b",
          default: 1
        },
        {
          type: "float",
          name: "a",
          default: 1
        }
      ],
      glsl: `   vec4 c = vec4(r, g, b, a);
   vec4 pos = step(0.0, c); // detect whether negative
   // if > 0, return r * _c0
   // if < 0 return (1.0-r) * _c0
   return vec4(mix((1.0-_c0)*abs(c), c*_c0, pos));`
    },
    {
      name: "saturate",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 2
        }
      ],
      glsl: `   const vec3 W = vec3(0.2125, 0.7154, 0.0721);
   vec3 intensity = vec3(dot(_c0.rgb, W));
   return vec4(mix(intensity, _c0.rgb, amount), _c0.a);`
    },
    {
      name: "hue",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "hue",
          default: 0.4
        }
      ],
      glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c.r += hue;
   //  c.r = fract(c.r);
   return vec4(_hsvToRgb(c), _c0.a);`
    },
    {
      name: "colorama",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "amount",
          default: 5e-3
        }
      ],
      glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c += vec3(amount);
   c = _hsvToRgb(c);
   c = fract(c);
   return vec4(c, _c0.a);`
    },
    {
      name: "prev",
      type: "src",
      inputs: [],
      glsl: "   return texture2D(prevBuffer, fract(_st));"
    },
    {
      name: "sum",
      type: "color",
      inputs: [
        {
          type: "vec4",
          name: "scale",
          default: 1
        }
      ],
      glsl: `   vec4 v = _c0 * s;
   return v.r + v.g + v.b + v.a;
   }
   float sum(vec2 _st, vec4 s) { // vec4 is not a typo, because argument type is not overloaded
   vec2 v = _st.xy * s.xy;
   return v.x + v.y;`
    },
    {
      name: "r",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "scale",
          default: 1
        },
        {
          type: "float",
          name: "offset",
          default: 0
        }
      ],
      glsl: "   return vec4(_c0.r * scale + offset);"
    },
    {
      name: "g",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "scale",
          default: 1
        },
        {
          type: "float",
          name: "offset",
          default: 0
        }
      ],
      glsl: "   return vec4(_c0.g * scale + offset);"
    },
    {
      name: "b",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "scale",
          default: 1
        },
        {
          type: "float",
          name: "offset",
          default: 0
        }
      ],
      glsl: "   return vec4(_c0.b * scale + offset);"
    },
    {
      name: "a",
      type: "color",
      inputs: [
        {
          type: "float",
          name: "scale",
          default: 1
        },
        {
          type: "float",
          name: "offset",
          default: 0
        }
      ],
      glsl: "   return vec4(_c0.a * scale + offset);"
    }
  ];
  class GeneratorFactory {
    constructor({
      defaultUniforms: c,
      defaultOutput: h2,
      extendTransforms: w = [],
      changeListener: D = () => {
      }
    } = {}) {
      this.defaultOutput = h2, this.defaultUniforms = c, this.changeListener = D, this.extendTransforms = w, this.generators = {}, this.init();
    }
    init() {
      const c = glslFunctions();
      return this.glslTransforms = {}, this.generators = Object.entries(this.generators).reduce((h2, [w, D]) => (this.changeListener({ type: "remove", synth: this, method: w }), h2), {}), this.sourceClass = (() => class extends GlslSource {
      })(), Array.isArray(this.extendTransforms) ? c.concat(this.extendTransforms) : typeof this.extendTransforms == "object" && this.extendTransforms.type && c.push(this.extendTransforms), c.map((h2) => this.setFunction(h2));
    }
    _addMethod(c, h2) {
      const w = this;
      if (this.glslTransforms[c] = h2, h2.type === "src") {
        const D = (...J) => new this.sourceClass({
          name: c,
          transform: h2,
          userArgs: J,
          defaultOutput: this.defaultOutput,
          defaultUniforms: this.defaultUniforms,
          synth: w
        });
        return this.generators[c] = D, this.changeListener({ type: "add", synth: this, method: c }), D;
      } else
        this.sourceClass.prototype[c] = function(...D) {
          return this.transforms.push({ name: c, transform: h2, userArgs: D, synth: w }), this;
        };
    }
    setFunction(c) {
      var h2 = processGlsl(c);
      h2 && this._addMethod(c.name, h2);
    }
  }
  const typeLookup = {
    src: {
      returnType: "vec4",
      args: ["vec2 _st"]
    },
    coord: {
      returnType: "vec2",
      args: ["vec2 _st"]
    },
    color: {
      returnType: "vec4",
      args: ["vec4 _c0"]
    },
    combine: {
      returnType: "vec4",
      args: ["vec4 _c0", "vec4 _c1"]
    },
    combineCoord: {
      returnType: "vec2",
      args: ["vec2 _st", "vec4 _c0"]
    }
  };
  function processGlsl(o) {
    let c = typeLookup[o.type];
    if (c) {
      let h2 = c.args.map((Se) => Se).join(", "), w = o.inputs.map((Se) => `${Se.type} ${Se.name}`).join(", "), D = `${h2}${w.length > 0 ? ", " + w : ""}`, J = `
  ${c.returnType} ${o.name}(${D}) {
      ${o.glsl}
  }
`;
      return (o.type === "combine" || o.type === "combineCoord") && o.inputs.unshift({
        name: "color",
        type: "vec4"
      }), Object.assign({}, o, { glsl: J });
    } else
      console.warn(`type ${o.type} not recognized`, o);
  }
  var regl$1 = { exports: {} };
  (function(o, c) {
    (function(h2, w) {
      o.exports = w();
    })(commonjsGlobal, function() {
      var h2 = function(e) {
        return e instanceof Uint8Array || e instanceof Uint16Array || e instanceof Uint32Array || e instanceof Int8Array || e instanceof Int16Array || e instanceof Int32Array || e instanceof Float32Array || e instanceof Float64Array || e instanceof Uint8ClampedArray;
      }, w = function(e, r) {
        for (var d2 = Object.keys(r), F = 0; F < d2.length; ++F)
          e[d2[F]] = r[d2[F]];
        return e;
      }, D = `
`;
      function J(e) {
        return typeof atob < "u" ? atob(e) : "base64:" + e;
      }
      function Se(e) {
        var r = new Error("(regl) " + e);
        throw console.error(r), r;
      }
      function he(e, r) {
        e || Se(r);
      }
      function Ie(e) {
        return e ? ": " + e : "";
      }
      function be(e, r, d2) {
        e in r || Se("unknown parameter (" + e + ")" + Ie(d2) + ". possible values: " + Object.keys(r).join());
      }
      function vt(e, r) {
        h2(e) || Se(
          "invalid parameter type" + Ie(r) + ". must be a typed array"
        );
      }
      function He(e, r) {
        switch (r) {
          case "number":
            return typeof e == "number";
          case "object":
            return typeof e == "object";
          case "string":
            return typeof e == "string";
          case "boolean":
            return typeof e == "boolean";
          case "function":
            return typeof e == "function";
          case "undefined":
            return typeof e > "u";
          case "symbol":
            return typeof e == "symbol";
        }
      }
      function We(e, r, d2) {
        He(e, r) || Se(
          "invalid parameter type" + Ie(d2) + ". expected " + r + ", got " + typeof e
        );
      }
      function mt(e, r) {
        e >= 0 && (e | 0) === e || Se("invalid parameter type, (" + e + ")" + Ie(r) + ". must be a nonnegative integer");
      }
      function st(e, r, d2) {
        r.indexOf(e) < 0 && Se("invalid value" + Ie(d2) + ". must be one of: " + r);
      }
      var yt = [
        "gl",
        "canvas",
        "container",
        "attributes",
        "pixelRatio",
        "extensions",
        "optionalExtensions",
        "profile",
        "onDone"
      ];
      function Wt(e) {
        Object.keys(e).forEach(function(r) {
          yt.indexOf(r) < 0 && Se('invalid regl constructor argument "' + r + '". must be one of ' + yt);
        });
      }
      function Et(e, r) {
        for (e = e + ""; e.length < r; )
          e = " " + e;
        return e;
      }
      function Be() {
        this.name = "unknown", this.lines = [], this.index = {}, this.hasErrors = false;
      }
      function it(e, r) {
        this.number = e, this.line = r, this.errors = [];
      }
      function Yt(e, r, d2) {
        this.file = e, this.line = r, this.message = d2;
      }
      function wt() {
        var e = new Error(), r = (e.stack || e).toString(), d2 = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(r);
        if (d2)
          return d2[1];
        var F = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(r);
        return F ? F[1] : "unknown";
      }
      function Hr() {
        var e = new Error(), r = (e.stack || e).toString(), d2 = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(r);
        if (d2)
          return d2[1];
        var F = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(r);
        return F ? F[1] : "unknown";
      }
      function qt(e, r) {
        var d2 = e.split(`
`), F = 1, N = 0, O = {
          unknown: new Be(),
          0: new Be()
        };
        O.unknown.name = O[0].name = r || wt(), O.unknown.lines.push(new it(0, ""));
        for (var M = 0; M < d2.length; ++M) {
          var X = d2[M], W = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(X);
          if (W)
            switch (W[1]) {
              case "line":
                var Q = /(\d+)(\s+\d+)?/.exec(W[2]);
                Q && (F = Q[1] | 0, Q[2] && (N = Q[2] | 0, N in O || (O[N] = new Be())));
                break;
              case "define":
                var Y = /SHADER_NAME(_B64)?\s+(.*)$/.exec(W[2]);
                Y && (O[N].name = Y[1] ? J(Y[2]) : Y[2]);
                break;
            }
          O[N].lines.push(new it(F++, X));
        }
        return Object.keys(O).forEach(function(te) {
          var ie = O[te];
          ie.lines.forEach(function(H) {
            ie.index[H.number] = H;
          });
        }), O;
      }
      function Sr(e) {
        var r = [];
        return e.split(`
`).forEach(function(d2) {
          if (!(d2.length < 5)) {
            var F = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(d2);
            F ? r.push(new Yt(
              F[1] | 0,
              F[2] | 0,
              F[3].trim()
            )) : d2.length > 0 && r.push(new Yt("unknown", 0, d2));
          }
        }), r;
      }
      function $t(e, r) {
        r.forEach(function(d2) {
          var F = e[d2.file];
          if (F) {
            var N = F.index[d2.line];
            if (N) {
              N.errors.push(d2), F.hasErrors = true;
              return;
            }
          }
          e.unknown.hasErrors = true, e.unknown.lines[0].errors.push(d2);
        });
      }
      function Sn(e, r, d2, F, N) {
        if (!e.getShaderParameter(r, e.COMPILE_STATUS)) {
          var O = e.getShaderInfoLog(r), M = F === e.FRAGMENT_SHADER ? "fragment" : "vertex";
          $(d2, "string", M + " shader source must be a string", N);
          var X = qt(d2, N), W = Sr(O);
          $t(X, W), Object.keys(X).forEach(function(Q) {
            var Y = X[Q];
            if (!Y.hasErrors)
              return;
            var te = [""], ie = [""];
            function H(re2, A) {
              te.push(re2), ie.push(A || "");
            }
            H("file number " + Q + ": " + Y.name + `
`, "color:red;text-decoration:underline;font-weight:bold"), Y.lines.forEach(function(re2) {
              if (re2.errors.length > 0) {
                H(Et(re2.number, 4) + "|  ", "background-color:yellow; font-weight:bold"), H(re2.line + D, "color:red; background-color:yellow; font-weight:bold");
                var A = 0;
                re2.errors.forEach(function(B) {
                  var K = B.message, se = /^\s*'(.*)'\s*:\s*(.*)$/.exec(K);
                  if (se) {
                    var z = se[1];
                    switch (K = se[2], z) {
                      case "assign":
                        z = "=";
                        break;
                    }
                    A = Math.max(re2.line.indexOf(z, A), 0);
                  } else
                    A = 0;
                  H(Et("| ", 6)), H(Et("^^^", A + 3) + D, "font-weight:bold"), H(Et("| ", 6)), H(K + D, "font-weight:bold");
                }), H(Et("| ", 6) + D);
              } else
                H(Et(re2.number, 4) + "|  "), H(re2.line + D, "color:red");
            }), typeof document < "u" && !window.chrome ? (ie[0] = te.join("%c"), console.log.apply(console, ie)) : console.log(te.join(""));
          }), he.raise("Error compiling " + M + " shader, " + X[0].name);
        }
      }
      function Tn(e, r, d2, F, N) {
        if (!e.getProgramParameter(r, e.LINK_STATUS)) {
          var O = e.getProgramInfoLog(r), M = qt(d2, N), X = qt(F, N), W = 'Error linking program with vertex shader, "' + X[0].name + '", and fragment shader "' + M[0].name + '"';
          typeof document < "u" ? console.log(
            "%c" + W + D + "%c" + O,
            "color:red;text-decoration:underline;font-weight:bold",
            "color:red"
          ) : console.log(W + D + O), he.raise(W);
        }
      }
      function Wr(e) {
        e._commandRef = wt();
      }
      function Tr(e, r, d2, F) {
        Wr(e);
        function N(W) {
          return W ? F.id(W) : 0;
        }
        e._fragId = N(e.static.frag), e._vertId = N(e.static.vert);
        function O(W, Q) {
          Object.keys(Q).forEach(function(Y) {
            W[F.id(Y)] = true;
          });
        }
        var M = e._uniformSet = {};
        O(M, r.static), O(M, r.dynamic);
        var X = e._attributeSet = {};
        O(X, d2.static), O(X, d2.dynamic), e._hasCount = "count" in e.static || "count" in e.dynamic || "elements" in e.static || "elements" in e.dynamic;
      }
      function Kt(e, r) {
        var d2 = Hr();
        Se(e + " in command " + (r || wt()) + (d2 === "unknown" ? "" : " called from " + d2));
      }
      function S(e, r, d2) {
        e || Kt(r, d2 || wt());
      }
      function _23(e, r, d2, F) {
        e in r || Kt(
          "unknown parameter (" + e + ")" + Ie(d2) + ". possible values: " + Object.keys(r).join(),
          F || wt()
        );
      }
      function $(e, r, d2, F) {
        He(e, r) || Kt(
          "invalid parameter type" + Ie(d2) + ". expected " + r + ", got " + typeof e,
          F || wt()
        );
      }
      function C(e) {
        e();
      }
      function ee(e, r, d2) {
        e.texture ? st(
          e.texture._texture.internalformat,
          r,
          "unsupported texture format for attachment"
        ) : st(
          e.renderbuffer._renderbuffer.format,
          d2,
          "unsupported renderbuffer format for attachment"
        );
      }
      var ce = 33071, we = 9728, ke = 9984, Te = 9985, Ae = 9986, Pe = 9987, ut = 5120, Ue = 5121, Ct = 5122, At = 5123, St = 5124, Lr = 5125, Qe = 5126, ct = 32819, pt = 32820, Gt = 33635, wa = 34042, Ao = 36193, Tt = {};
      Tt[ut] = Tt[Ue] = 1, Tt[Ct] = Tt[At] = Tt[Ao] = Tt[Gt] = Tt[ct] = Tt[pt] = 2, Tt[St] = Tt[Lr] = Tt[Qe] = Tt[wa] = 4;
      function Aa(e, r) {
        return e === pt || e === ct || e === Gt ? 2 : e === wa ? 4 : Tt[e] * r;
      }
      function Yr(e) {
        return !(e & e - 1) && !!e;
      }
      function So(e, r, d2) {
        var F, N = r.width, O = r.height, M = r.channels;
        he(
          N > 0 && N <= d2.maxTextureSize && O > 0 && O <= d2.maxTextureSize,
          "invalid texture shape"
        ), (e.wrapS !== ce || e.wrapT !== ce) && he(
          Yr(N) && Yr(O),
          "incompatible wrap mode for texture, both width and height must be power of 2"
        ), r.mipmask === 1 ? N !== 1 && O !== 1 && he(
          e.minFilter !== ke && e.minFilter !== Ae && e.minFilter !== Te && e.minFilter !== Pe,
          "min filter requires mipmap"
        ) : (he(
          Yr(N) && Yr(O),
          "texture must be a square power of 2 to support mipmapping"
        ), he(
          r.mipmask === (N << 1) - 1,
          "missing or incomplete mipmap data"
        )), r.type === Qe && (d2.extensions.indexOf("oes_texture_float_linear") < 0 && he(
          e.minFilter === we && e.magFilter === we,
          "filter not supported, must enable oes_texture_float_linear"
        ), he(
          !e.genMipmaps,
          "mipmap generation not supported with float textures"
        ));
        var X = r.images;
        for (F = 0; F < 16; ++F)
          if (X[F]) {
            var W = N >> F, Q = O >> F;
            he(r.mipmask & 1 << F, "missing mipmap data");
            var Y = X[F];
            if (he(
              Y.width === W && Y.height === Q,
              "invalid shape for mip images"
            ), he(
              Y.format === r.format && Y.internalformat === r.internalformat && Y.type === r.type,
              "incompatible type for mip image"
            ), !Y.compressed)
              if (Y.data) {
                var te = Math.ceil(Aa(Y.type, M) * W / Y.unpackAlignment) * Y.unpackAlignment;
                he(
                  Y.data.byteLength === te * Q,
                  "invalid data for image, buffer size is inconsistent with image format"
                );
              } else
                Y.element || Y.copy;
          } else
            e.genMipmaps || he((r.mipmask & 1 << F) === 0, "extra mipmap data");
        r.compressed && he(
          !e.genMipmaps,
          "mipmap generation for compressed images not supported"
        );
      }
      function To(e, r, d2, F) {
        var N = e.width, O = e.height, M = e.channels;
        he(
          N > 0 && N <= F.maxTextureSize && O > 0 && O <= F.maxTextureSize,
          "invalid texture shape"
        ), he(
          N === O,
          "cube map must be square"
        ), he(
          r.wrapS === ce && r.wrapT === ce,
          "wrap mode not supported by cube map"
        );
        for (var X = 0; X < d2.length; ++X) {
          var W = d2[X];
          he(
            W.width === N && W.height === O,
            "inconsistent cube map face shape"
          ), r.genMipmaps && (he(
            !W.compressed,
            "can not generate mipmap for compressed textures"
          ), he(
            W.mipmask === 1,
            "can not specify mipmaps and generate mipmaps"
          ));
          for (var Q = W.images, Y = 0; Y < 16; ++Y) {
            var te = Q[Y];
            if (te) {
              var ie = N >> Y, H = O >> Y;
              he(W.mipmask & 1 << Y, "missing mipmap data"), he(
                te.width === ie && te.height === H,
                "invalid shape for mip images"
              ), he(
                te.format === e.format && te.internalformat === e.internalformat && te.type === e.type,
                "incompatible type for mip image"
              ), te.compressed || (te.data ? he(
                te.data.byteLength === ie * H * Math.max(Aa(te.type, M), te.unpackAlignment),
                "invalid data for image, buffer size is inconsistent with image format"
              ) : te.element || te.copy);
            }
          }
        }
      }
      var u = w(he, {
        optional: C,
        raise: Se,
        commandRaise: Kt,
        command: S,
        parameter: be,
        commandParameter: _23,
        constructor: Wt,
        type: We,
        commandType: $,
        isTypedArray: vt,
        nni: mt,
        oneOf: st,
        shaderError: Sn,
        linkError: Tn,
        callSite: Hr,
        saveCommandRef: Wr,
        saveDrawInfo: Tr,
        framebufferFormat: ee,
        guessCommand: wt,
        texture2D: So,
        textureCube: To
      }), Lo = 0, Ro = 0, Co = 5, Oo = 6;
      function Qt(e, r) {
        this.id = Lo++, this.type = e, this.data = r;
      }
      function Sa(e) {
        return e.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      }
      function Rr(e) {
        if (e.length === 0)
          return [];
        var r = e.charAt(0), d2 = e.charAt(e.length - 1);
        if (e.length > 1 && r === d2 && (r === '"' || r === "'"))
          return ['"' + Sa(e.substr(1, e.length - 2)) + '"'];
        var F = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(e);
        if (F)
          return Rr(e.substr(0, F.index)).concat(Rr(F[1])).concat(Rr(e.substr(F.index + F[0].length)));
        var N = e.split(".");
        if (N.length === 1)
          return ['"' + Sa(e) + '"'];
        for (var O = [], M = 0; M < N.length; ++M)
          O = O.concat(Rr(N[M]));
        return O;
      }
      function Ta(e) {
        return "[" + Rr(e).join("][") + "]";
      }
      function Fo(e, r) {
        return new Qt(e, Ta(r + ""));
      }
      function Go(e) {
        return typeof e == "function" && !e._reglType || e instanceof Qt;
      }
      function La(e, r) {
        if (typeof e == "function")
          return new Qt(Ro, e);
        if (typeof e == "number" || typeof e == "boolean")
          return new Qt(Co, e);
        if (Array.isArray(e))
          return new Qt(Oo, e.map((d2, F) => La(d2, r + "[" + F + "]")));
        if (e instanceof Qt)
          return e;
        u(false, "invalid option type in uniform " + r);
      }
      var Lt = {
        DynamicVariable: Qt,
        define: Fo,
        isDynamic: Go,
        unbox: La,
        accessor: Ta
      }, Ln = {
        next: typeof requestAnimationFrame == "function" ? function(e) {
          return requestAnimationFrame(e);
        } : function(e) {
          return setTimeout(e, 16);
        },
        cancel: typeof cancelAnimationFrame == "function" ? function(e) {
          return cancelAnimationFrame(e);
        } : clearTimeout
      }, Ra = typeof performance < "u" && performance.now ? function() {
        return performance.now();
      } : function() {
        return +/* @__PURE__ */ new Date();
      };
      function Do() {
        var e = { "": 0 }, r = [""];
        return {
          id: function(d2) {
            var F = e[d2];
            return F || (F = e[d2] = r.length, r.push(d2), F);
          },
          str: function(d2) {
            return r[d2];
          }
        };
      }
      function Mo(e, r, d2) {
        var F = document.createElement("canvas");
        w(F.style, {
          border: 0,
          margin: 0,
          padding: 0,
          top: 0,
          left: 0
        }), e.appendChild(F), e === document.body && (F.style.position = "absolute", w(e.style, {
          margin: 0,
          padding: 0
        }));
        function N() {
          var X = window.innerWidth, W = window.innerHeight;
          if (e !== document.body) {
            var Q = e.getBoundingClientRect();
            X = Q.right - Q.left, W = Q.bottom - Q.top;
          }
          F.width = d2 * X, F.height = d2 * W, w(F.style, {
            width: X + "px",
            height: W + "px"
          });
        }
        var O;
        e !== document.body && typeof ResizeObserver == "function" ? (O = new ResizeObserver(function() {
          setTimeout(N);
        }), O.observe(e)) : window.addEventListener("resize", N, false);
        function M() {
          O ? O.disconnect() : window.removeEventListener("resize", N), e.removeChild(F);
        }
        return N(), {
          canvas: F,
          onDestroy: M
        };
      }
      function Bo(e, r) {
        function d2(F) {
          try {
            return e.getContext(F, r);
          } catch {
            return null;
          }
        }
        return d2("webgl") || d2("experimental-webgl") || d2("webgl-experimental");
      }
      function ko(e) {
        return typeof e.nodeName == "string" && typeof e.appendChild == "function" && typeof e.getBoundingClientRect == "function";
      }
      function Io(e) {
        return typeof e.drawArrays == "function" || typeof e.drawElements == "function";
      }
      function Ca(e) {
        return typeof e == "string" ? e.split() : (u(Array.isArray(e), "invalid extension array"), e);
      }
      function Oa(e) {
        return typeof e == "string" ? (u(typeof document < "u", "not supported outside of DOM"), document.querySelector(e)) : e;
      }
      function No(e) {
        var r = e || {}, d2, F, N, O, M = {}, X = [], W = [], Q = typeof window > "u" ? 1 : window.devicePixelRatio, Y = false, te = function(re2) {
          re2 && u.raise(re2);
        }, ie = function() {
        };
        if (typeof r == "string" ? (u(
          typeof document < "u",
          "selector queries only supported in DOM enviroments"
        ), d2 = document.querySelector(r), u(d2, "invalid query string for element")) : typeof r == "object" ? ko(r) ? d2 = r : Io(r) ? (O = r, N = O.canvas) : (u.constructor(r), "gl" in r ? O = r.gl : "canvas" in r ? N = Oa(r.canvas) : "container" in r && (F = Oa(r.container)), "attributes" in r && (M = r.attributes, u.type(M, "object", "invalid context attributes")), "extensions" in r && (X = Ca(r.extensions)), "optionalExtensions" in r && (W = Ca(r.optionalExtensions)), "onDone" in r && (u.type(
          r.onDone,
          "function",
          "invalid or missing onDone callback"
        ), te = r.onDone), "profile" in r && (Y = !!r.profile), "pixelRatio" in r && (Q = +r.pixelRatio, u(Q > 0, "invalid pixel ratio"))) : u.raise("invalid arguments to regl"), d2 && (d2.nodeName.toLowerCase() === "canvas" ? N = d2 : F = d2), !O) {
          if (!N) {
            u(
              typeof document < "u",
              "must manually specify webgl context outside of DOM environments"
            );
            var H = Mo(F || document.body, te, Q);
            if (!H)
              return null;
            N = H.canvas, ie = H.onDestroy;
          }
          M.premultipliedAlpha === void 0 && (M.premultipliedAlpha = true), O = Bo(N, M);
        }
        return O ? {
          gl: O,
          canvas: N,
          container: F,
          extensions: X,
          optionalExtensions: W,
          pixelRatio: Q,
          profile: Y,
          onDone: te,
          onDestroy: ie
        } : (ie(), te("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"), null);
      }
      function Po(e, r) {
        var d2 = {};
        function F(M) {
          u.type(M, "string", "extension name must be string");
          var X = M.toLowerCase(), W;
          try {
            W = d2[X] = e.getExtension(X);
          } catch {
          }
          return !!W;
        }
        for (var N = 0; N < r.extensions.length; ++N) {
          var O = r.extensions[N];
          if (!F(O))
            return r.onDestroy(), r.onDone('"' + O + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser'), null;
        }
        return r.optionalExtensions.forEach(F), {
          extensions: d2,
          restore: function() {
            Object.keys(d2).forEach(function(M) {
              if (d2[M] && !F(M))
                throw new Error("(regl): error restoring extension " + M);
            });
          }
        };
      }
      function gt(e, r) {
        for (var d2 = Array(e), F = 0; F < e; ++F)
          d2[F] = r(F);
        return d2;
      }
      var Uo = 5120, $o = 5121, zo = 5122, jo = 5123, Vo = 5124, Xo = 5125, Ho = 5126;
      function Wo(e) {
        for (var r = 16; r <= 1 << 28; r *= 16)
          if (e <= r)
            return r;
        return 0;
      }
      function Fa(e) {
        var r, d2;
        return r = (e > 65535) << 4, e >>>= r, d2 = (e > 255) << 3, e >>>= d2, r |= d2, d2 = (e > 15) << 2, e >>>= d2, r |= d2, d2 = (e > 3) << 1, e >>>= d2, r |= d2, r | e >> 1;
      }
      function Ga() {
        var e = gt(8, function() {
          return [];
        });
        function r(O) {
          var M = Wo(O), X = e[Fa(M) >> 2];
          return X.length > 0 ? X.pop() : new ArrayBuffer(M);
        }
        function d2(O) {
          e[Fa(O.byteLength) >> 2].push(O);
        }
        function F(O, M) {
          var X = null;
          switch (O) {
            case Uo:
              X = new Int8Array(r(M), 0, M);
              break;
            case $o:
              X = new Uint8Array(r(M), 0, M);
              break;
            case zo:
              X = new Int16Array(r(2 * M), 0, M);
              break;
            case jo:
              X = new Uint16Array(r(2 * M), 0, M);
              break;
            case Vo:
              X = new Int32Array(r(4 * M), 0, M);
              break;
            case Xo:
              X = new Uint32Array(r(4 * M), 0, M);
              break;
            case Ho:
              X = new Float32Array(r(4 * M), 0, M);
              break;
            default:
              return null;
          }
          return X.length !== M ? X.subarray(0, M) : X;
        }
        function N(O) {
          d2(O.buffer);
        }
        return {
          alloc: r,
          free: d2,
          allocType: F,
          freeType: N
        };
      }
      var Ze = Ga();
      Ze.zero = Ga();
      var Yo = 3408, qo = 3410, Ko = 3411, Qo = 3412, Zo = 3413, Jo = 3414, es = 3415, ts = 33901, rs = 33902, ns = 3379, as = 3386, is = 34921, os = 36347, ss = 36348, fs = 35661, us = 35660, cs = 34930, ls = 36349, ds = 34076, hs = 34024, ms2 = 7936, ps = 7937, vs = 7938, ys = 35724, _s = 34047, bs = 36063, gs = 34852, qr = 3553, Da = 34067, xs = 34069, Es = 33984, Cr = 6408, Rn = 5126, Ma = 5121, Cn = 36160, ws = 36053, As = 36064, Ss = 16384, Ts = function(e, r) {
        var d2 = 1;
        r.ext_texture_filter_anisotropic && (d2 = e.getParameter(_s));
        var F = 1, N = 1;
        r.webgl_draw_buffers && (F = e.getParameter(gs), N = e.getParameter(bs));
        var O = !!r.oes_texture_float;
        if (O) {
          var M = e.createTexture();
          e.bindTexture(qr, M), e.texImage2D(qr, 0, Cr, 1, 1, 0, Cr, Rn, null);
          var X = e.createFramebuffer();
          if (e.bindFramebuffer(Cn, X), e.framebufferTexture2D(Cn, As, qr, M, 0), e.bindTexture(qr, null), e.checkFramebufferStatus(Cn) !== ws)
            O = false;
          else {
            e.viewport(0, 0, 1, 1), e.clearColor(1, 0, 0, 1), e.clear(Ss);
            var W = Ze.allocType(Rn, 4);
            e.readPixels(0, 0, 1, 1, Cr, Rn, W), e.getError() ? O = false : (e.deleteFramebuffer(X), e.deleteTexture(M), O = W[0] === 1), Ze.freeType(W);
          }
        }
        var Q = typeof navigator < "u" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent)), Y = true;
        if (!Q) {
          var te = e.createTexture(), ie = Ze.allocType(Ma, 36);
          e.activeTexture(Es), e.bindTexture(Da, te), e.texImage2D(xs, 0, Cr, 3, 3, 0, Cr, Ma, ie), Ze.freeType(ie), e.bindTexture(Da, null), e.deleteTexture(te), Y = !e.getError();
        }
        return {
          // drawing buffer bit depth
          colorBits: [
            e.getParameter(qo),
            e.getParameter(Ko),
            e.getParameter(Qo),
            e.getParameter(Zo)
          ],
          depthBits: e.getParameter(Jo),
          stencilBits: e.getParameter(es),
          subpixelBits: e.getParameter(Yo),
          // supported extensions
          extensions: Object.keys(r).filter(function(H) {
            return !!r[H];
          }),
          // max aniso samples
          maxAnisotropic: d2,
          // max draw buffers
          maxDrawbuffers: F,
          maxColorAttachments: N,
          // point and line size ranges
          pointSizeDims: e.getParameter(ts),
          lineWidthDims: e.getParameter(rs),
          maxViewportDims: e.getParameter(as),
          maxCombinedTextureUnits: e.getParameter(fs),
          maxCubeMapSize: e.getParameter(ds),
          maxRenderbufferSize: e.getParameter(hs),
          maxTextureUnits: e.getParameter(cs),
          maxTextureSize: e.getParameter(ns),
          maxAttributes: e.getParameter(is),
          maxVertexUniforms: e.getParameter(os),
          maxVertexTextureUnits: e.getParameter(us),
          maxVaryingVectors: e.getParameter(ss),
          maxFragmentUniforms: e.getParameter(ls),
          // vendor info
          glsl: e.getParameter(ys),
          renderer: e.getParameter(ps),
          vendor: e.getParameter(ms2),
          version: e.getParameter(vs),
          // quirks
          readFloat: O,
          npotTextureCube: Y
        };
      };
      function Dt(e) {
        return !!e && typeof e == "object" && Array.isArray(e.shape) && Array.isArray(e.stride) && typeof e.offset == "number" && e.shape.length === e.stride.length && (Array.isArray(e.data) || h2(e.data));
      }
      var Rt = function(e) {
        return Object.keys(e).map(function(r) {
          return e[r];
        });
      }, Kr = {
        shape: Os,
        flatten: Cs
      };
      function Ls(e, r, d2) {
        for (var F = 0; F < r; ++F)
          d2[F] = e[F];
      }
      function Rs(e, r, d2, F) {
        for (var N = 0, O = 0; O < r; ++O)
          for (var M = e[O], X = 0; X < d2; ++X)
            F[N++] = M[X];
      }
      function Ba(e, r, d2, F, N, O) {
        for (var M = O, X = 0; X < r; ++X)
          for (var W = e[X], Q = 0; Q < d2; ++Q)
            for (var Y = W[Q], te = 0; te < F; ++te)
              N[M++] = Y[te];
      }
      function ka(e, r, d2, F, N) {
        for (var O = 1, M = d2 + 1; M < r.length; ++M)
          O *= r[M];
        var X = r[d2];
        if (r.length - d2 === 4) {
          var W = r[d2 + 1], Q = r[d2 + 2], Y = r[d2 + 3];
          for (M = 0; M < X; ++M)
            Ba(e[M], W, Q, Y, F, N), N += O;
        } else
          for (M = 0; M < X; ++M)
            ka(e[M], r, d2 + 1, F, N), N += O;
      }
      function Cs(e, r, d2, F) {
        var N = 1;
        if (r.length)
          for (var O = 0; O < r.length; ++O)
            N *= r[O];
        else
          N = 0;
        var M = F || Ze.allocType(d2, N);
        switch (r.length) {
          case 0:
            break;
          case 1:
            Ls(e, r[0], M);
            break;
          case 2:
            Rs(e, r[0], r[1], M);
            break;
          case 3:
            Ba(e, r[0], r[1], r[2], M, 0);
            break;
          default:
            ka(e, r, 0, M, 0);
        }
        return M;
      }
      function Os(e) {
        for (var r = [], d2 = e; d2.length; d2 = d2[0])
          r.push(d2.length);
        return r;
      }
      var On = {
        "[object Int8Array]": 5120,
        "[object Int16Array]": 5122,
        "[object Int32Array]": 5124,
        "[object Uint8Array]": 5121,
        "[object Uint8ClampedArray]": 5121,
        "[object Uint16Array]": 5123,
        "[object Uint32Array]": 5125,
        "[object Float32Array]": 5126,
        "[object Float64Array]": 5121,
        "[object ArrayBuffer]": 5121
      }, Fs = 5120, Gs = 5122, Ds = 5124, Ms = 5121, Bs = 5123, ks = 5125, Is = 5126, Ns = 5126, Zt = {
        int8: Fs,
        int16: Gs,
        int32: Ds,
        uint8: Ms,
        uint16: Bs,
        uint32: ks,
        float: Is,
        float32: Ns
      }, Ps = 35048, Us = 35040, Qr = {
        dynamic: Ps,
        stream: Us,
        static: 35044
      }, Fn = Kr.flatten, Ia = Kr.shape, Na = 35044, $s = 35040, Gn = 5121, Dn = 5126, zt = [];
      zt[5120] = 1, zt[5122] = 2, zt[5124] = 4, zt[5121] = 1, zt[5123] = 2, zt[5125] = 4, zt[5126] = 4;
      function Zr(e) {
        return On[Object.prototype.toString.call(e)] | 0;
      }
      function Pa(e, r) {
        for (var d2 = 0; d2 < r.length; ++d2)
          e[d2] = r[d2];
      }
      function Ua(e, r, d2, F, N, O, M) {
        for (var X = 0, W = 0; W < d2; ++W)
          for (var Q = 0; Q < F; ++Q)
            e[X++] = r[N * W + O * Q + M];
      }
      function zs(e, r, d2, F) {
        var N = 0, O = {};
        function M(A) {
          this.id = N++, this.buffer = e.createBuffer(), this.type = A, this.usage = Na, this.byteLength = 0, this.dimension = 1, this.dtype = Gn, this.persistentData = null, d2.profile && (this.stats = { size: 0 });
        }
        M.prototype.bind = function() {
          e.bindBuffer(this.type, this.buffer);
        }, M.prototype.destroy = function() {
          ie(this);
        };
        var X = [];
        function W(A, B) {
          var K = X.pop();
          return K || (K = new M(A)), K.bind(), te(K, B, $s, 0, 1, false), K;
        }
        function Q(A) {
          X.push(A);
        }
        function Y(A, B, K) {
          A.byteLength = B.byteLength, e.bufferData(A.type, B, K);
        }
        function te(A, B, K, se, z, fe) {
          var V;
          if (A.usage = K, Array.isArray(B)) {
            if (A.dtype = se || Dn, B.length > 0) {
              var ne;
              if (Array.isArray(B[0])) {
                V = Ia(B);
                for (var j = 1, ae = 1; ae < V.length; ++ae)
                  j *= V[ae];
                A.dimension = j, ne = Fn(B, V, A.dtype), Y(A, ne, K), fe ? A.persistentData = ne : Ze.freeType(ne);
              } else if (typeof B[0] == "number") {
                A.dimension = z;
                var pe = Ze.allocType(A.dtype, B.length);
                Pa(pe, B), Y(A, pe, K), fe ? A.persistentData = pe : Ze.freeType(pe);
              } else
                h2(B[0]) ? (A.dimension = B[0].length, A.dtype = se || Zr(B[0]) || Dn, ne = Fn(
                  B,
                  [B.length, B[0].length],
                  A.dtype
                ), Y(A, ne, K), fe ? A.persistentData = ne : Ze.freeType(ne)) : u.raise("invalid buffer data");
            }
          } else if (h2(B))
            A.dtype = se || Zr(B), A.dimension = z, Y(A, B, K), fe && (A.persistentData = new Uint8Array(new Uint8Array(B.buffer)));
          else if (Dt(B)) {
            V = B.shape;
            var ge = B.stride, oe = B.offset, Z = 0, U = 0, _e = 0, Le = 0;
            V.length === 1 ? (Z = V[0], U = 1, _e = ge[0], Le = 0) : V.length === 2 ? (Z = V[0], U = V[1], _e = ge[0], Le = ge[1]) : u.raise("invalid shape"), A.dtype = se || Zr(B.data) || Dn, A.dimension = U;
            var le = Ze.allocType(A.dtype, Z * U);
            Ua(
              le,
              B.data,
              Z,
              U,
              _e,
              Le,
              oe
            ), Y(A, le, K), fe ? A.persistentData = le : Ze.freeType(le);
          } else
            B instanceof ArrayBuffer ? (A.dtype = Gn, A.dimension = z, Y(A, B, K), fe && (A.persistentData = new Uint8Array(new Uint8Array(B)))) : u.raise("invalid buffer data");
        }
        function ie(A) {
          r.bufferCount--, F(A);
          var B = A.buffer;
          u(B, "buffer must not be deleted already"), e.deleteBuffer(B), A.buffer = null, delete O[A.id];
        }
        function H(A, B, K, se) {
          r.bufferCount++;
          var z = new M(B);
          O[z.id] = z;
          function fe(j) {
            var ae = Na, pe = null, ge = 0, oe = 0, Z = 1;
            return Array.isArray(j) || h2(j) || Dt(j) || j instanceof ArrayBuffer ? pe = j : typeof j == "number" ? ge = j | 0 : j && (u.type(
              j,
              "object",
              "buffer arguments must be an object, a number or an array"
            ), "data" in j && (u(
              pe === null || Array.isArray(pe) || h2(pe) || Dt(pe),
              "invalid data for buffer"
            ), pe = j.data), "usage" in j && (u.parameter(j.usage, Qr, "invalid buffer usage"), ae = Qr[j.usage]), "type" in j && (u.parameter(j.type, Zt, "invalid buffer type"), oe = Zt[j.type]), "dimension" in j && (u.type(j.dimension, "number", "invalid dimension"), Z = j.dimension | 0), "length" in j && (u.nni(ge, "buffer length must be a nonnegative integer"), ge = j.length | 0)), z.bind(), pe ? te(z, pe, ae, oe, Z, se) : (ge && e.bufferData(z.type, ge, ae), z.dtype = oe || Gn, z.usage = ae, z.dimension = Z, z.byteLength = ge), d2.profile && (z.stats.size = z.byteLength * zt[z.dtype]), fe;
          }
          function V(j, ae) {
            u(
              ae + j.byteLength <= z.byteLength,
              "invalid buffer subdata call, buffer is too small.  Can't write data of size " + j.byteLength + " starting from offset " + ae + " to a buffer of size " + z.byteLength
            ), e.bufferSubData(z.type, ae, j);
          }
          function ne(j, ae) {
            var pe = (ae || 0) | 0, ge;
            if (z.bind(), h2(j) || j instanceof ArrayBuffer)
              V(j, pe);
            else if (Array.isArray(j)) {
              if (j.length > 0)
                if (typeof j[0] == "number") {
                  var oe = Ze.allocType(z.dtype, j.length);
                  Pa(oe, j), V(oe, pe), Ze.freeType(oe);
                } else if (Array.isArray(j[0]) || h2(j[0])) {
                  ge = Ia(j);
                  var Z = Fn(j, ge, z.dtype);
                  V(Z, pe), Ze.freeType(Z);
                } else
                  u.raise("invalid buffer data");
            } else if (Dt(j)) {
              ge = j.shape;
              var U = j.stride, _e = 0, Le = 0, le = 0, Fe = 0;
              ge.length === 1 ? (_e = ge[0], Le = 1, le = U[0], Fe = 0) : ge.length === 2 ? (_e = ge[0], Le = ge[1], le = U[0], Fe = U[1]) : u.raise("invalid shape");
              var xe = Array.isArray(j.data) ? z.dtype : Zr(j.data), Oe = Ze.allocType(xe, _e * Le);
              Ua(
                Oe,
                j.data,
                _e,
                Le,
                le,
                Fe,
                j.offset
              ), V(Oe, pe), Ze.freeType(Oe);
            } else
              u.raise("invalid data for buffer subdata");
            return fe;
          }
          return K || fe(A), fe._reglType = "buffer", fe._buffer = z, fe.subdata = ne, d2.profile && (fe.stats = z.stats), fe.destroy = function() {
            ie(z);
          }, fe;
        }
        function re2() {
          Rt(O).forEach(function(A) {
            A.buffer = e.createBuffer(), e.bindBuffer(A.type, A.buffer), e.bufferData(
              A.type,
              A.persistentData || A.byteLength,
              A.usage
            );
          });
        }
        return d2.profile && (r.getTotalBufferSize = function() {
          var A = 0;
          return Object.keys(O).forEach(function(B) {
            A += O[B].stats.size;
          }), A;
        }), {
          create: H,
          createStream: W,
          destroyStream: Q,
          clear: function() {
            Rt(O).forEach(ie), X.forEach(ie);
          },
          getBuffer: function(A) {
            return A && A._buffer instanceof M ? A._buffer : null;
          },
          restore: re2,
          _initBuffer: te
        };
      }
      var js2 = 0, Vs = 0, Xs = 1, Hs = 1, Ws = 4, Ys = 4, ur = {
        points: js2,
        point: Vs,
        lines: Xs,
        line: Hs,
        triangles: Ws,
        triangle: Ys,
        "line loop": 2,
        "line strip": 3,
        "triangle strip": 5,
        "triangle fan": 6
      }, qs2 = 0, Ks = 1, Or = 4, Qs = 5120, cr = 5121, $a = 5122, lr = 5123, za = 5124, Jt = 5125, Mn = 34963, Zs = 35040, Js = 35044;
      function ef(e, r, d2, F) {
        var N = {}, O = 0, M = {
          uint8: cr,
          uint16: lr
        };
        r.oes_element_index_uint && (M.uint32 = Jt);
        function X(re2) {
          this.id = O++, N[this.id] = this, this.buffer = re2, this.primType = Or, this.vertCount = 0, this.type = 0;
        }
        X.prototype.bind = function() {
          this.buffer.bind();
        };
        var W = [];
        function Q(re2) {
          var A = W.pop();
          return A || (A = new X(d2.create(
            null,
            Mn,
            true,
            false
          )._buffer)), te(A, re2, Zs, -1, -1, 0, 0), A;
        }
        function Y(re2) {
          W.push(re2);
        }
        function te(re2, A, B, K, se, z, fe) {
          re2.buffer.bind();
          var V;
          if (A) {
            var ne = fe;
            !fe && (!h2(A) || Dt(A) && !h2(A.data)) && (ne = r.oes_element_index_uint ? Jt : lr), d2._initBuffer(
              re2.buffer,
              A,
              B,
              ne,
              3
            );
          } else
            e.bufferData(Mn, z, B), re2.buffer.dtype = V || cr, re2.buffer.usage = B, re2.buffer.dimension = 3, re2.buffer.byteLength = z;
          if (V = fe, !fe) {
            switch (re2.buffer.dtype) {
              case cr:
              case Qs:
                V = cr;
                break;
              case lr:
              case $a:
                V = lr;
                break;
              case Jt:
              case za:
                V = Jt;
                break;
              default:
                u.raise("unsupported type for element array");
            }
            re2.buffer.dtype = V;
          }
          re2.type = V, u(
            V !== Jt || !!r.oes_element_index_uint,
            "32 bit element buffers not supported, enable oes_element_index_uint first"
          );
          var j = se;
          j < 0 && (j = re2.buffer.byteLength, V === lr ? j >>= 1 : V === Jt && (j >>= 2)), re2.vertCount = j;
          var ae = K;
          if (K < 0) {
            ae = Or;
            var pe = re2.buffer.dimension;
            pe === 1 && (ae = qs2), pe === 2 && (ae = Ks), pe === 3 && (ae = Or);
          }
          re2.primType = ae;
        }
        function ie(re2) {
          F.elementsCount--, u(re2.buffer !== null, "must not double destroy elements"), delete N[re2.id], re2.buffer.destroy(), re2.buffer = null;
        }
        function H(re2, A) {
          var B = d2.create(null, Mn, true), K = new X(B._buffer);
          F.elementsCount++;
          function se(z) {
            if (!z)
              B(), K.primType = Or, K.vertCount = 0, K.type = cr;
            else if (typeof z == "number")
              B(z), K.primType = Or, K.vertCount = z | 0, K.type = cr;
            else {
              var fe = null, V = Js, ne = -1, j = -1, ae = 0, pe = 0;
              Array.isArray(z) || h2(z) || Dt(z) ? fe = z : (u.type(z, "object", "invalid arguments for elements"), "data" in z && (fe = z.data, u(
                Array.isArray(fe) || h2(fe) || Dt(fe),
                "invalid data for element buffer"
              )), "usage" in z && (u.parameter(
                z.usage,
                Qr,
                "invalid element buffer usage"
              ), V = Qr[z.usage]), "primitive" in z && (u.parameter(
                z.primitive,
                ur,
                "invalid element buffer primitive"
              ), ne = ur[z.primitive]), "count" in z && (u(
                typeof z.count == "number" && z.count >= 0,
                "invalid vertex count for elements"
              ), j = z.count | 0), "type" in z && (u.parameter(
                z.type,
                M,
                "invalid buffer type"
              ), pe = M[z.type]), "length" in z ? ae = z.length | 0 : (ae = j, pe === lr || pe === $a ? ae *= 2 : (pe === Jt || pe === za) && (ae *= 4))), te(
                K,
                fe,
                V,
                ne,
                j,
                ae,
                pe
              );
            }
            return se;
          }
          return se(re2), se._reglType = "elements", se._elements = K, se.subdata = function(z, fe) {
            return B.subdata(z, fe), se;
          }, se.destroy = function() {
            ie(K);
          }, se;
        }
        return {
          create: H,
          createStream: Q,
          destroyStream: Y,
          getElements: function(re2) {
            return typeof re2 == "function" && re2._elements instanceof X ? re2._elements : null;
          },
          clear: function() {
            Rt(N).forEach(ie);
          }
        };
      }
      var ja = new Float32Array(1), tf = new Uint32Array(ja.buffer), rf = 5123;
      function Va(e) {
        for (var r = Ze.allocType(rf, e.length), d2 = 0; d2 < e.length; ++d2)
          if (isNaN(e[d2]))
            r[d2] = 65535;
          else if (e[d2] === 1 / 0)
            r[d2] = 31744;
          else if (e[d2] === -1 / 0)
            r[d2] = 64512;
          else {
            ja[0] = e[d2];
            var F = tf[0], N = F >>> 31 << 15, O = (F << 1 >>> 24) - 127, M = F >> 13 & 1024 - 1;
            if (O < -24)
              r[d2] = N;
            else if (O < -14) {
              var X = -14 - O;
              r[d2] = N + (M + 1024 >> X);
            } else
              O > 15 ? r[d2] = N + 31744 : r[d2] = N + (O + 15 << 10) + M;
          }
        return r;
      }
      function Ye(e) {
        return Array.isArray(e) || h2(e);
      }
      var Xa = function(e) {
        return !(e & e - 1) && !!e;
      }, nf = 34467, kt = 3553, Bn = 34067, Jr = 34069, er = 6408, kn = 6406, en = 6407, Fr = 6409, tn = 6410, Ha = 32854, In = 32855, Wa = 36194, af = 32819, of = 32820, sf = 33635, ff = 34042, Nn = 6402, rn = 34041, Pn = 35904, Un = 35906, dr = 36193, $n = 33776, zn = 33777, jn = 33778, Vn = 33779, Ya = 35986, qa = 35987, Ka = 34798, Qa = 35840, Za = 35841, Ja = 35842, ei = 35843, ti = 36196, hr = 5121, Xn = 5123, Hn = 5125, Gr = 5126, uf = 10242, cf = 10243, lf = 10497, Wn = 33071, df = 33648, hf = 10240, mf = 10241, Yn = 9728, pf = 9729, qn = 9984, ri = 9985, ni = 9986, Kn = 9987, vf = 33170, nn = 4352, yf = 4353, _f = 4354, bf = 34046, gf = 3317, xf = 37440, Ef = 37441, wf = 37443, ai = 37444, Dr = 33984, Af = [
        qn,
        ni,
        ri,
        Kn
      ], an = [
        0,
        Fr,
        tn,
        en,
        er
      ], Ot = {};
      Ot[Fr] = Ot[kn] = Ot[Nn] = 1, Ot[rn] = Ot[tn] = 2, Ot[en] = Ot[Pn] = 3, Ot[er] = Ot[Un] = 4;
      function mr(e) {
        return "[object " + e + "]";
      }
      var ii = mr("HTMLCanvasElement"), oi = mr("OffscreenCanvas"), si = mr("CanvasRenderingContext2D"), fi = mr("ImageBitmap"), ui = mr("HTMLImageElement"), ci = mr("HTMLVideoElement"), Sf = Object.keys(On).concat([
        ii,
        oi,
        si,
        fi,
        ui,
        ci
      ]), pr = [];
      pr[hr] = 1, pr[Gr] = 4, pr[dr] = 2, pr[Xn] = 2, pr[Hn] = 4;
      var lt = [];
      lt[Ha] = 2, lt[In] = 2, lt[Wa] = 2, lt[rn] = 4, lt[$n] = 0.5, lt[zn] = 0.5, lt[jn] = 1, lt[Vn] = 1, lt[Ya] = 0.5, lt[qa] = 1, lt[Ka] = 1, lt[Qa] = 0.5, lt[Za] = 0.25, lt[Ja] = 0.5, lt[ei] = 0.25, lt[ti] = 0.5;
      function li(e) {
        return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
      }
      function di(e) {
        if (!Array.isArray(e))
          return false;
        var r = e.length;
        return !(r === 0 || !Ye(e[0]));
      }
      function tr(e) {
        return Object.prototype.toString.call(e);
      }
      function hi(e) {
        return tr(e) === ii;
      }
      function mi(e) {
        return tr(e) === oi;
      }
      function Tf(e) {
        return tr(e) === si;
      }
      function Lf(e) {
        return tr(e) === fi;
      }
      function Rf(e) {
        return tr(e) === ui;
      }
      function Cf(e) {
        return tr(e) === ci;
      }
      function Qn(e) {
        if (!e)
          return false;
        var r = tr(e);
        return Sf.indexOf(r) >= 0 ? true : li(e) || di(e) || Dt(e);
      }
      function pi(e) {
        return On[Object.prototype.toString.call(e)] | 0;
      }
      function Of(e, r) {
        var d2 = r.length;
        switch (e.type) {
          case hr:
          case Xn:
          case Hn:
          case Gr:
            var F = Ze.allocType(e.type, d2);
            F.set(r), e.data = F;
            break;
          case dr:
            e.data = Va(r);
            break;
          default:
            u.raise("unsupported texture type, must specify a typed array");
        }
      }
      function vi(e, r) {
        return Ze.allocType(
          e.type === dr ? Gr : e.type,
          r
        );
      }
      function yi(e, r) {
        e.type === dr ? (e.data = Va(r), Ze.freeType(r)) : e.data = r;
      }
      function Ff(e, r, d2, F, N, O) {
        for (var M = e.width, X = e.height, W = e.channels, Q = M * X * W, Y = vi(e, Q), te = 0, ie = 0; ie < X; ++ie)
          for (var H = 0; H < M; ++H)
            for (var re2 = 0; re2 < W; ++re2)
              Y[te++] = r[d2 * H + F * ie + N * re2 + O];
        yi(e, Y);
      }
      function on2(e, r, d2, F, N, O) {
        var M;
        if (typeof lt[e] < "u" ? M = lt[e] : M = Ot[e] * pr[r], O && (M *= 6), N) {
          for (var X = 0, W = d2; W >= 1; )
            X += M * W * W, W /= 2;
          return X;
        } else
          return M * d2 * F;
      }
      function Gf(e, r, d2, F, N, O, M) {
        var X = {
          "don't care": nn,
          "dont care": nn,
          nice: _f,
          fast: yf
        }, W = {
          repeat: lf,
          clamp: Wn,
          mirror: df
        }, Q = {
          nearest: Yn,
          linear: pf
        }, Y = w({
          mipmap: Kn,
          "nearest mipmap nearest": qn,
          "linear mipmap nearest": ri,
          "nearest mipmap linear": ni,
          "linear mipmap linear": Kn
        }, Q), te = {
          none: 0,
          browser: ai
        }, ie = {
          uint8: hr,
          rgba4: af,
          rgb565: sf,
          "rgb5 a1": of
        }, H = {
          alpha: kn,
          luminance: Fr,
          "luminance alpha": tn,
          rgb: en,
          rgba: er,
          rgba4: Ha,
          "rgb5 a1": In,
          rgb565: Wa
        }, re2 = {};
        r.ext_srgb && (H.srgb = Pn, H.srgba = Un), r.oes_texture_float && (ie.float32 = ie.float = Gr), r.oes_texture_half_float && (ie.float16 = ie["half float"] = dr), r.webgl_depth_texture && (w(H, {
          depth: Nn,
          "depth stencil": rn
        }), w(ie, {
          uint16: Xn,
          uint32: Hn,
          "depth stencil": ff
        })), r.webgl_compressed_texture_s3tc && w(re2, {
          "rgb s3tc dxt1": $n,
          "rgba s3tc dxt1": zn,
          "rgba s3tc dxt3": jn,
          "rgba s3tc dxt5": Vn
        }), r.webgl_compressed_texture_atc && w(re2, {
          "rgb atc": Ya,
          "rgba atc explicit alpha": qa,
          "rgba atc interpolated alpha": Ka
        }), r.webgl_compressed_texture_pvrtc && w(re2, {
          "rgb pvrtc 4bppv1": Qa,
          "rgb pvrtc 2bppv1": Za,
          "rgba pvrtc 4bppv1": Ja,
          "rgba pvrtc 2bppv1": ei
        }), r.webgl_compressed_texture_etc1 && (re2["rgb etc1"] = ti);
        var A = Array.prototype.slice.call(
          e.getParameter(nf)
        );
        Object.keys(re2).forEach(function(l) {
          var G = re2[l];
          A.indexOf(G) >= 0 && (H[l] = G);
        });
        var B = Object.keys(H);
        d2.textureFormats = B;
        var K = [];
        Object.keys(H).forEach(function(l) {
          var G = H[l];
          K[G] = l;
        });
        var se = [];
        Object.keys(ie).forEach(function(l) {
          var G = ie[l];
          se[G] = l;
        });
        var z = [];
        Object.keys(Q).forEach(function(l) {
          var G = Q[l];
          z[G] = l;
        });
        var fe = [];
        Object.keys(Y).forEach(function(l) {
          var G = Y[l];
          fe[G] = l;
        });
        var V = [];
        Object.keys(W).forEach(function(l) {
          var G = W[l];
          V[G] = l;
        });
        var ne = B.reduce(function(l, G) {
          var R2 = H[G];
          return R2 === Fr || R2 === kn || R2 === Fr || R2 === tn || R2 === Nn || R2 === rn || r.ext_srgb && (R2 === Pn || R2 === Un) ? l[R2] = R2 : R2 === In || G.indexOf("rgba") >= 0 ? l[R2] = er : l[R2] = en, l;
        }, {});
        function j() {
          this.internalformat = er, this.format = er, this.type = hr, this.compressed = false, this.premultiplyAlpha = false, this.flipY = false, this.unpackAlignment = 1, this.colorSpace = ai, this.width = 0, this.height = 0, this.channels = 0;
        }
        function ae(l, G) {
          l.internalformat = G.internalformat, l.format = G.format, l.type = G.type, l.compressed = G.compressed, l.premultiplyAlpha = G.premultiplyAlpha, l.flipY = G.flipY, l.unpackAlignment = G.unpackAlignment, l.colorSpace = G.colorSpace, l.width = G.width, l.height = G.height, l.channels = G.channels;
        }
        function pe(l, G) {
          if (!(typeof G != "object" || !G)) {
            if ("premultiplyAlpha" in G && (u.type(
              G.premultiplyAlpha,
              "boolean",
              "invalid premultiplyAlpha"
            ), l.premultiplyAlpha = G.premultiplyAlpha), "flipY" in G && (u.type(
              G.flipY,
              "boolean",
              "invalid texture flip"
            ), l.flipY = G.flipY), "alignment" in G && (u.oneOf(
              G.alignment,
              [1, 2, 4, 8],
              "invalid texture unpack alignment"
            ), l.unpackAlignment = G.alignment), "colorSpace" in G && (u.parameter(
              G.colorSpace,
              te,
              "invalid colorSpace"
            ), l.colorSpace = te[G.colorSpace]), "type" in G) {
              var R2 = G.type;
              u(
                r.oes_texture_float || !(R2 === "float" || R2 === "float32"),
                "you must enable the OES_texture_float extension in order to use floating point textures."
              ), u(
                r.oes_texture_half_float || !(R2 === "half float" || R2 === "float16"),
                "you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."
              ), u(
                r.webgl_depth_texture || !(R2 === "uint16" || R2 === "uint32" || R2 === "depth stencil"),
                "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
              ), u.parameter(
                R2,
                ie,
                "invalid texture type"
              ), l.type = ie[R2];
            }
            var ue = l.width, Ge = l.height, s2 = l.channels, t = false;
            "shape" in G ? (u(
              Array.isArray(G.shape) && G.shape.length >= 2,
              "shape must be an array"
            ), ue = G.shape[0], Ge = G.shape[1], G.shape.length === 3 && (s2 = G.shape[2], u(s2 > 0 && s2 <= 4, "invalid number of channels"), t = true), u(ue >= 0 && ue <= d2.maxTextureSize, "invalid width"), u(Ge >= 0 && Ge <= d2.maxTextureSize, "invalid height")) : ("radius" in G && (ue = Ge = G.radius, u(ue >= 0 && ue <= d2.maxTextureSize, "invalid radius")), "width" in G && (ue = G.width, u(ue >= 0 && ue <= d2.maxTextureSize, "invalid width")), "height" in G && (Ge = G.height, u(Ge >= 0 && Ge <= d2.maxTextureSize, "invalid height")), "channels" in G && (s2 = G.channels, u(s2 > 0 && s2 <= 4, "invalid number of channels"), t = true)), l.width = ue | 0, l.height = Ge | 0, l.channels = s2 | 0;
            var v = false;
            if ("format" in G) {
              var g = G.format;
              u(
                r.webgl_depth_texture || !(g === "depth" || g === "depth stencil"),
                "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
              ), u.parameter(
                g,
                H,
                "invalid texture format"
              );
              var T = l.internalformat = H[g];
              l.format = ne[T], g in ie && ("type" in G || (l.type = ie[g])), g in re2 && (l.compressed = true), v = true;
            }
            !t && v ? l.channels = Ot[l.format] : t && !v ? l.channels !== an[l.format] && (l.format = l.internalformat = an[l.channels]) : v && t && u(
              l.channels === Ot[l.format],
              "number of channels inconsistent with specified format"
            );
          }
        }
        function ge(l) {
          e.pixelStorei(xf, l.flipY), e.pixelStorei(Ef, l.premultiplyAlpha), e.pixelStorei(wf, l.colorSpace), e.pixelStorei(gf, l.unpackAlignment);
        }
        function oe() {
          j.call(this), this.xOffset = 0, this.yOffset = 0, this.data = null, this.needsFree = false, this.element = null, this.needsCopy = false;
        }
        function Z(l, G) {
          var R2 = null;
          if (Qn(G) ? R2 = G : G && (u.type(G, "object", "invalid pixel data type"), pe(l, G), "x" in G && (l.xOffset = G.x | 0), "y" in G && (l.yOffset = G.y | 0), Qn(G.data) && (R2 = G.data)), u(
            !l.compressed || R2 instanceof Uint8Array,
            "compressed texture data must be stored in a uint8array"
          ), G.copy) {
            u(!R2, "can not specify copy and data field for the same texture");
            var ue = N.viewportWidth, Ge = N.viewportHeight;
            l.width = l.width || ue - l.xOffset, l.height = l.height || Ge - l.yOffset, l.needsCopy = true, u(
              l.xOffset >= 0 && l.xOffset < ue && l.yOffset >= 0 && l.yOffset < Ge && l.width > 0 && l.width <= ue && l.height > 0 && l.height <= Ge,
              "copy texture read out of bounds"
            );
          } else if (!R2)
            l.width = l.width || 1, l.height = l.height || 1, l.channels = l.channels || 4;
          else if (h2(R2))
            l.channels = l.channels || 4, l.data = R2, !("type" in G) && l.type === hr && (l.type = pi(R2));
          else if (li(R2))
            l.channels = l.channels || 4, Of(l, R2), l.alignment = 1, l.needsFree = true;
          else if (Dt(R2)) {
            var s2 = R2.data;
            !Array.isArray(s2) && l.type === hr && (l.type = pi(s2));
            var t = R2.shape, v = R2.stride, g, T, y2, p, b, n;
            t.length === 3 ? (y2 = t[2], n = v[2]) : (u(t.length === 2, "invalid ndarray pixel data, must be 2 or 3D"), y2 = 1, n = 1), g = t[0], T = t[1], p = v[0], b = v[1], l.alignment = 1, l.width = g, l.height = T, l.channels = y2, l.format = l.internalformat = an[y2], l.needsFree = true, Ff(l, s2, p, b, n, R2.offset);
          } else if (hi(R2) || mi(R2) || Tf(R2))
            hi(R2) || mi(R2) ? l.element = R2 : l.element = R2.canvas, l.width = l.element.width, l.height = l.element.height, l.channels = 4;
          else if (Lf(R2))
            l.element = R2, l.width = R2.width, l.height = R2.height, l.channels = 4;
          else if (Rf(R2))
            l.element = R2, l.width = R2.naturalWidth, l.height = R2.naturalHeight, l.channels = 4;
          else if (Cf(R2))
            l.element = R2, l.width = R2.videoWidth, l.height = R2.videoHeight, l.channels = 4;
          else if (di(R2)) {
            var m2 = l.width || R2[0].length, f = l.height || R2.length, E = l.channels;
            Ye(R2[0][0]) ? E = E || R2[0][0].length : E = E || 1;
            for (var L = Kr.shape(R2), I = 1, P = 0; P < L.length; ++P)
              I *= L[P];
            var k = vi(l, I);
            Kr.flatten(R2, L, "", k), yi(l, k), l.alignment = 1, l.width = m2, l.height = f, l.channels = E, l.format = l.internalformat = an[E], l.needsFree = true;
          }
          l.type === Gr ? u(
            d2.extensions.indexOf("oes_texture_float") >= 0,
            "oes_texture_float extension not enabled"
          ) : l.type === dr && u(
            d2.extensions.indexOf("oes_texture_half_float") >= 0,
            "oes_texture_half_float extension not enabled"
          );
        }
        function U(l, G, R2) {
          var ue = l.element, Ge = l.data, s2 = l.internalformat, t = l.format, v = l.type, g = l.width, T = l.height;
          ge(l), ue ? e.texImage2D(G, R2, t, t, v, ue) : l.compressed ? e.compressedTexImage2D(G, R2, s2, g, T, 0, Ge) : l.needsCopy ? (F(), e.copyTexImage2D(
            G,
            R2,
            t,
            l.xOffset,
            l.yOffset,
            g,
            T,
            0
          )) : e.texImage2D(G, R2, t, g, T, 0, t, v, Ge || null);
        }
        function _e(l, G, R2, ue, Ge) {
          var s2 = l.element, t = l.data, v = l.internalformat, g = l.format, T = l.type, y2 = l.width, p = l.height;
          ge(l), s2 ? e.texSubImage2D(
            G,
            Ge,
            R2,
            ue,
            g,
            T,
            s2
          ) : l.compressed ? e.compressedTexSubImage2D(
            G,
            Ge,
            R2,
            ue,
            v,
            y2,
            p,
            t
          ) : l.needsCopy ? (F(), e.copyTexSubImage2D(
            G,
            Ge,
            R2,
            ue,
            l.xOffset,
            l.yOffset,
            y2,
            p
          )) : e.texSubImage2D(
            G,
            Ge,
            R2,
            ue,
            y2,
            p,
            g,
            T,
            t
          );
        }
        var Le = [];
        function le() {
          return Le.pop() || new oe();
        }
        function Fe(l) {
          l.needsFree && Ze.freeType(l.data), oe.call(l), Le.push(l);
        }
        function xe() {
          j.call(this), this.genMipmaps = false, this.mipmapHint = nn, this.mipmask = 0, this.images = Array(16);
        }
        function Oe(l, G, R2) {
          var ue = l.images[0] = le();
          l.mipmask = 1, ue.width = l.width = G, ue.height = l.height = R2, ue.channels = l.channels = 4;
        }
        function $e(l, G) {
          var R2 = null;
          if (Qn(G))
            R2 = l.images[0] = le(), ae(R2, l), Z(R2, G), l.mipmask = 1;
          else if (pe(l, G), Array.isArray(G.mipmap))
            for (var ue = G.mipmap, Ge = 0; Ge < ue.length; ++Ge)
              R2 = l.images[Ge] = le(), ae(R2, l), R2.width >>= Ge, R2.height >>= Ge, Z(R2, ue[Ge]), l.mipmask |= 1 << Ge;
          else
            R2 = l.images[0] = le(), ae(R2, l), Z(R2, G), l.mipmask = 1;
          ae(l, l.images[0]), l.compressed && (l.internalformat === $n || l.internalformat === zn || l.internalformat === jn || l.internalformat === Vn) && u(
            l.width % 4 === 0 && l.height % 4 === 0,
            "for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4"
          );
        }
        function et(l, G) {
          for (var R2 = l.images, ue = 0; ue < R2.length; ++ue) {
            if (!R2[ue])
              return;
            U(R2[ue], G, ue);
          }
        }
        var ot = [];
        function Me() {
          var l = ot.pop() || new xe();
          j.call(l), l.mipmask = 0;
          for (var G = 0; G < 16; ++G)
            l.images[G] = null;
          return l;
        }
        function rt(l) {
          for (var G = l.images, R2 = 0; R2 < G.length; ++R2)
            G[R2] && Fe(G[R2]), G[R2] = null;
          ot.push(l);
        }
        function Ve() {
          this.minFilter = Yn, this.magFilter = Yn, this.wrapS = Wn, this.wrapT = Wn, this.anisotropic = 1, this.genMipmaps = false, this.mipmapHint = nn;
        }
        function tt(l, G) {
          if ("min" in G) {
            var R2 = G.min;
            u.parameter(R2, Y), l.minFilter = Y[R2], Af.indexOf(l.minFilter) >= 0 && !("faces" in G) && (l.genMipmaps = true);
          }
          if ("mag" in G) {
            var ue = G.mag;
            u.parameter(ue, Q), l.magFilter = Q[ue];
          }
          var Ge = l.wrapS, s2 = l.wrapT;
          if ("wrap" in G) {
            var t = G.wrap;
            typeof t == "string" ? (u.parameter(t, W), Ge = s2 = W[t]) : Array.isArray(t) && (u.parameter(t[0], W), u.parameter(t[1], W), Ge = W[t[0]], s2 = W[t[1]]);
          } else {
            if ("wrapS" in G) {
              var v = G.wrapS;
              u.parameter(v, W), Ge = W[v];
            }
            if ("wrapT" in G) {
              var g = G.wrapT;
              u.parameter(g, W), s2 = W[g];
            }
          }
          if (l.wrapS = Ge, l.wrapT = s2, "anisotropic" in G) {
            var T = G.anisotropic;
            u(
              typeof T == "number" && T >= 1 && T <= d2.maxAnisotropic,
              "aniso samples must be between 1 and "
            ), l.anisotropic = G.anisotropic;
          }
          if ("mipmap" in G) {
            var y2 = false;
            switch (typeof G.mipmap) {
              case "string":
                u.parameter(
                  G.mipmap,
                  X,
                  "invalid mipmap hint"
                ), l.mipmapHint = X[G.mipmap], l.genMipmaps = true, y2 = true;
                break;
              case "boolean":
                y2 = l.genMipmaps = G.mipmap;
                break;
              case "object":
                u(Array.isArray(G.mipmap), "invalid mipmap type"), l.genMipmaps = false, y2 = true;
                break;
              default:
                u.raise("invalid mipmap type");
            }
            y2 && !("min" in G) && (l.minFilter = qn);
          }
        }
        function nt(l, G) {
          e.texParameteri(G, mf, l.minFilter), e.texParameteri(G, hf, l.magFilter), e.texParameteri(G, uf, l.wrapS), e.texParameteri(G, cf, l.wrapT), r.ext_texture_filter_anisotropic && e.texParameteri(G, bf, l.anisotropic), l.genMipmaps && (e.hint(vf, l.mipmapHint), e.generateMipmap(G));
        }
        var at2 = 0, ft = {}, dt = d2.maxTextureUnits, qe = Array(dt).map(function() {
          return null;
        });
        function Re(l) {
          j.call(this), this.mipmask = 0, this.internalformat = er, this.id = at2++, this.refCount = 1, this.target = l, this.texture = e.createTexture(), this.unit = -1, this.bindCount = 0, this.texInfo = new Ve(), M.profile && (this.stats = { size: 0 });
        }
        function ht(l) {
          e.activeTexture(Dr), e.bindTexture(l.target, l.texture);
        }
        function je() {
          var l = qe[0];
          l ? e.bindTexture(l.target, l.texture) : e.bindTexture(kt, null);
        }
        function ve(l) {
          var G = l.texture;
          u(G, "must not double destroy texture");
          var R2 = l.unit, ue = l.target;
          R2 >= 0 && (e.activeTexture(Dr + R2), e.bindTexture(ue, null), qe[R2] = null), e.deleteTexture(G), l.texture = null, l.params = null, l.pixels = null, l.refCount = 0, delete ft[l.id], O.textureCount--;
        }
        w(Re.prototype, {
          bind: function() {
            var l = this;
            l.bindCount += 1;
            var G = l.unit;
            if (G < 0) {
              for (var R2 = 0; R2 < dt; ++R2) {
                var ue = qe[R2];
                if (ue) {
                  if (ue.bindCount > 0)
                    continue;
                  ue.unit = -1;
                }
                qe[R2] = l, G = R2;
                break;
              }
              G >= dt && u.raise("insufficient number of texture units"), M.profile && O.maxTextureUnits < G + 1 && (O.maxTextureUnits = G + 1), l.unit = G, e.activeTexture(Dr + G), e.bindTexture(l.target, l.texture);
            }
            return G;
          },
          unbind: function() {
            this.bindCount -= 1;
          },
          decRef: function() {
            --this.refCount <= 0 && ve(this);
          }
        });
        function De(l, G) {
          var R2 = new Re(kt);
          ft[R2.id] = R2, O.textureCount++;
          function ue(t, v) {
            var g = R2.texInfo;
            Ve.call(g);
            var T = Me();
            return typeof t == "number" ? typeof v == "number" ? Oe(T, t | 0, v | 0) : Oe(T, t | 0, t | 0) : t ? (u.type(t, "object", "invalid arguments to regl.texture"), tt(g, t), $e(T, t)) : Oe(T, 1, 1), g.genMipmaps && (T.mipmask = (T.width << 1) - 1), R2.mipmask = T.mipmask, ae(R2, T), u.texture2D(g, T, d2), R2.internalformat = T.internalformat, ue.width = T.width, ue.height = T.height, ht(R2), et(T, kt), nt(g, kt), je(), rt(T), M.profile && (R2.stats.size = on2(
              R2.internalformat,
              R2.type,
              T.width,
              T.height,
              g.genMipmaps,
              false
            )), ue.format = K[R2.internalformat], ue.type = se[R2.type], ue.mag = z[g.magFilter], ue.min = fe[g.minFilter], ue.wrapS = V[g.wrapS], ue.wrapT = V[g.wrapT], ue;
          }
          function Ge(t, v, g, T) {
            u(!!t, "must specify image data");
            var y2 = v | 0, p = g | 0, b = T | 0, n = le();
            return ae(n, R2), n.width = 0, n.height = 0, Z(n, t), n.width = n.width || (R2.width >> b) - y2, n.height = n.height || (R2.height >> b) - p, u(
              R2.type === n.type && R2.format === n.format && R2.internalformat === n.internalformat,
              "incompatible format for texture.subimage"
            ), u(
              y2 >= 0 && p >= 0 && y2 + n.width <= R2.width && p + n.height <= R2.height,
              "texture.subimage write out of bounds"
            ), u(
              R2.mipmask & 1 << b,
              "missing mipmap data"
            ), u(
              n.data || n.element || n.needsCopy,
              "missing image data"
            ), ht(R2), _e(n, kt, y2, p, b), je(), Fe(n), ue;
          }
          function s2(t, v) {
            var g = t | 0, T = v | 0 || g;
            if (g === R2.width && T === R2.height)
              return ue;
            ue.width = R2.width = g, ue.height = R2.height = T, ht(R2);
            for (var y2 = 0; R2.mipmask >> y2; ++y2) {
              var p = g >> y2, b = T >> y2;
              if (!p || !b)
                break;
              e.texImage2D(
                kt,
                y2,
                R2.format,
                p,
                b,
                0,
                R2.format,
                R2.type,
                null
              );
            }
            return je(), M.profile && (R2.stats.size = on2(
              R2.internalformat,
              R2.type,
              g,
              T,
              false,
              false
            )), ue;
          }
          return ue(l, G), ue.subimage = Ge, ue.resize = s2, ue._reglType = "texture2d", ue._texture = R2, M.profile && (ue.stats = R2.stats), ue.destroy = function() {
            R2.decRef();
          }, ue;
        }
        function Ne(l, G, R2, ue, Ge, s2) {
          var t = new Re(Bn);
          ft[t.id] = t, O.cubeCount++;
          var v = new Array(6);
          function g(p, b, n, m2, f, E) {
            var L, I = t.texInfo;
            for (Ve.call(I), L = 0; L < 6; ++L)
              v[L] = Me();
            if (typeof p == "number" || !p) {
              var P = p | 0 || 1;
              for (L = 0; L < 6; ++L)
                Oe(v[L], P, P);
            } else if (typeof p == "object")
              if (b)
                $e(v[0], p), $e(v[1], b), $e(v[2], n), $e(v[3], m2), $e(v[4], f), $e(v[5], E);
              else if (tt(I, p), pe(t, p), "faces" in p) {
                var k = p.faces;
                for (u(
                  Array.isArray(k) && k.length === 6,
                  "cube faces must be a length 6 array"
                ), L = 0; L < 6; ++L)
                  u(
                    typeof k[L] == "object" && !!k[L],
                    "invalid input for cube map face"
                  ), ae(v[L], t), $e(v[L], k[L]);
              } else
                for (L = 0; L < 6; ++L)
                  $e(v[L], p);
            else
              u.raise("invalid arguments to cube map");
            for (ae(t, v[0]), d2.npotTextureCube || u(Xa(t.width) && Xa(t.height), "your browser does not support non power or two texture dimensions"), I.genMipmaps ? t.mipmask = (v[0].width << 1) - 1 : t.mipmask = v[0].mipmask, u.textureCube(t, I, v, d2), t.internalformat = v[0].internalformat, g.width = v[0].width, g.height = v[0].height, ht(t), L = 0; L < 6; ++L)
              et(v[L], Jr + L);
            for (nt(I, Bn), je(), M.profile && (t.stats.size = on2(
              t.internalformat,
              t.type,
              g.width,
              g.height,
              I.genMipmaps,
              true
            )), g.format = K[t.internalformat], g.type = se[t.type], g.mag = z[I.magFilter], g.min = fe[I.minFilter], g.wrapS = V[I.wrapS], g.wrapT = V[I.wrapT], L = 0; L < 6; ++L)
              rt(v[L]);
            return g;
          }
          function T(p, b, n, m2, f) {
            u(!!b, "must specify image data"), u(typeof p == "number" && p === (p | 0) && p >= 0 && p < 6, "invalid face");
            var E = n | 0, L = m2 | 0, I = f | 0, P = le();
            return ae(P, t), P.width = 0, P.height = 0, Z(P, b), P.width = P.width || (t.width >> I) - E, P.height = P.height || (t.height >> I) - L, u(
              t.type === P.type && t.format === P.format && t.internalformat === P.internalformat,
              "incompatible format for texture.subimage"
            ), u(
              E >= 0 && L >= 0 && E + P.width <= t.width && L + P.height <= t.height,
              "texture.subimage write out of bounds"
            ), u(
              t.mipmask & 1 << I,
              "missing mipmap data"
            ), u(
              P.data || P.element || P.needsCopy,
              "missing image data"
            ), ht(t), _e(P, Jr + p, E, L, I), je(), Fe(P), g;
          }
          function y2(p) {
            var b = p | 0;
            if (b !== t.width) {
              g.width = t.width = b, g.height = t.height = b, ht(t);
              for (var n = 0; n < 6; ++n)
                for (var m2 = 0; t.mipmask >> m2; ++m2)
                  e.texImage2D(
                    Jr + n,
                    m2,
                    t.format,
                    b >> m2,
                    b >> m2,
                    0,
                    t.format,
                    t.type,
                    null
                  );
              return je(), M.profile && (t.stats.size = on2(
                t.internalformat,
                t.type,
                g.width,
                g.height,
                false,
                true
              )), g;
            }
          }
          return g(l, G, R2, ue, Ge, s2), g.subimage = T, g.resize = y2, g._reglType = "textureCube", g._texture = t, M.profile && (g.stats = t.stats), g.destroy = function() {
            t.decRef();
          }, g;
        }
        function Ke() {
          for (var l = 0; l < dt; ++l)
            e.activeTexture(Dr + l), e.bindTexture(kt, null), qe[l] = null;
          Rt(ft).forEach(ve), O.cubeCount = 0, O.textureCount = 0;
        }
        M.profile && (O.getTotalTextureSize = function() {
          var l = 0;
          return Object.keys(ft).forEach(function(G) {
            l += ft[G].stats.size;
          }), l;
        });
        function Nt() {
          for (var l = 0; l < dt; ++l) {
            var G = qe[l];
            G && (G.bindCount = 0, G.unit = -1, qe[l] = null);
          }
          Rt(ft).forEach(function(R2) {
            R2.texture = e.createTexture(), e.bindTexture(R2.target, R2.texture);
            for (var ue = 0; ue < 32; ++ue)
              if (R2.mipmask & 1 << ue)
                if (R2.target === kt)
                  e.texImage2D(
                    kt,
                    ue,
                    R2.internalformat,
                    R2.width >> ue,
                    R2.height >> ue,
                    0,
                    R2.internalformat,
                    R2.type,
                    null
                  );
                else
                  for (var Ge = 0; Ge < 6; ++Ge)
                    e.texImage2D(
                      Jr + Ge,
                      ue,
                      R2.internalformat,
                      R2.width >> ue,
                      R2.height >> ue,
                      0,
                      R2.internalformat,
                      R2.type,
                      null
                    );
            nt(R2.texInfo, R2.target);
          });
        }
        function fr() {
          for (var l = 0; l < dt; ++l) {
            var G = qe[l];
            G && (G.bindCount = 0, G.unit = -1, qe[l] = null), e.activeTexture(Dr + l), e.bindTexture(kt, null), e.bindTexture(Bn, null);
          }
        }
        return {
          create2D: De,
          createCube: Ne,
          clear: Ke,
          getTexture: function(l) {
            return null;
          },
          restore: Nt,
          refresh: fr
        };
      }
      var jt = 36161, sn = 32854, _i2 = 32855, bi = 36194, gi = 33189, xi = 36168, Ei = 34041, wi = 35907, Ai = 34836, Si = 34842, Ti = 34843, Mt = [];
      Mt[sn] = 2, Mt[_i2] = 2, Mt[bi] = 2, Mt[gi] = 2, Mt[xi] = 1, Mt[Ei] = 4, Mt[wi] = 4, Mt[Ai] = 16, Mt[Si] = 8, Mt[Ti] = 6;
      function Li(e, r, d2) {
        return Mt[e] * r * d2;
      }
      var Df = function(e, r, d2, F, N) {
        var O = {
          rgba4: sn,
          rgb565: bi,
          "rgb5 a1": _i2,
          depth: gi,
          stencil: xi,
          "depth stencil": Ei
        };
        r.ext_srgb && (O.srgba = wi), r.ext_color_buffer_half_float && (O.rgba16f = Si, O.rgb16f = Ti), r.webgl_color_buffer_float && (O.rgba32f = Ai);
        var M = [];
        Object.keys(O).forEach(function(H) {
          var re2 = O[H];
          M[re2] = H;
        });
        var X = 0, W = {};
        function Q(H) {
          this.id = X++, this.refCount = 1, this.renderbuffer = H, this.format = sn, this.width = 0, this.height = 0, N.profile && (this.stats = { size: 0 });
        }
        Q.prototype.decRef = function() {
          --this.refCount <= 0 && Y(this);
        };
        function Y(H) {
          var re2 = H.renderbuffer;
          u(re2, "must not double destroy renderbuffer"), e.bindRenderbuffer(jt, null), e.deleteRenderbuffer(re2), H.renderbuffer = null, H.refCount = 0, delete W[H.id], F.renderbufferCount--;
        }
        function te(H, re2) {
          var A = new Q(e.createRenderbuffer());
          W[A.id] = A, F.renderbufferCount++;
          function B(se, z) {
            var fe = 0, V = 0, ne = sn;
            if (typeof se == "object" && se) {
              var j = se;
              if ("shape" in j) {
                var ae = j.shape;
                u(
                  Array.isArray(ae) && ae.length >= 2,
                  "invalid renderbuffer shape"
                ), fe = ae[0] | 0, V = ae[1] | 0;
              } else
                "radius" in j && (fe = V = j.radius | 0), "width" in j && (fe = j.width | 0), "height" in j && (V = j.height | 0);
              "format" in j && (u.parameter(
                j.format,
                O,
                "invalid renderbuffer format"
              ), ne = O[j.format]);
            } else
              typeof se == "number" ? (fe = se | 0, typeof z == "number" ? V = z | 0 : V = fe) : se ? u.raise("invalid arguments to renderbuffer constructor") : fe = V = 1;
            if (u(
              fe > 0 && V > 0 && fe <= d2.maxRenderbufferSize && V <= d2.maxRenderbufferSize,
              "invalid renderbuffer size"
            ), !(fe === A.width && V === A.height && ne === A.format))
              return B.width = A.width = fe, B.height = A.height = V, A.format = ne, e.bindRenderbuffer(jt, A.renderbuffer), e.renderbufferStorage(jt, ne, fe, V), u(
                e.getError() === 0,
                "invalid render buffer format"
              ), N.profile && (A.stats.size = Li(A.format, A.width, A.height)), B.format = M[A.format], B;
          }
          function K(se, z) {
            var fe = se | 0, V = z | 0 || fe;
            return fe === A.width && V === A.height || (u(
              fe > 0 && V > 0 && fe <= d2.maxRenderbufferSize && V <= d2.maxRenderbufferSize,
              "invalid renderbuffer size"
            ), B.width = A.width = fe, B.height = A.height = V, e.bindRenderbuffer(jt, A.renderbuffer), e.renderbufferStorage(jt, A.format, fe, V), u(
              e.getError() === 0,
              "invalid render buffer format"
            ), N.profile && (A.stats.size = Li(
              A.format,
              A.width,
              A.height
            ))), B;
          }
          return B(H, re2), B.resize = K, B._reglType = "renderbuffer", B._renderbuffer = A, N.profile && (B.stats = A.stats), B.destroy = function() {
            A.decRef();
          }, B;
        }
        N.profile && (F.getTotalRenderbufferSize = function() {
          var H = 0;
          return Object.keys(W).forEach(function(re2) {
            H += W[re2].stats.size;
          }), H;
        });
        function ie() {
          Rt(W).forEach(function(H) {
            H.renderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(jt, H.renderbuffer), e.renderbufferStorage(jt, H.format, H.width, H.height);
          }), e.bindRenderbuffer(jt, null);
        }
        return {
          create: te,
          clear: function() {
            Rt(W).forEach(Y);
          },
          restore: ie
        };
      }, Pt = 36160, Zn = 36161, rr = 3553, fn = 34069, Ri = 36064, Ci = 36096, Oi = 36128, Fi = 33306, Gi = 36053, Mf = 36054, Bf = 36055, kf = 36057, If = 36061, Nf = 36193, Pf = 5121, Uf = 5126, Di = 6407, Mi = 6408, $f = 6402, zf = [
        Di,
        Mi
      ], Jn = [];
      Jn[Mi] = 4, Jn[Di] = 3;
      var un = [];
      un[Pf] = 1, un[Uf] = 4, un[Nf] = 2;
      var jf = 32854, Vf = 32855, Xf = 36194, Hf = 33189, Wf = 36168, Bi = 34041, Yf = 35907, qf = 34836, Kf = 34842, Qf = 34843, Zf = [
        jf,
        Vf,
        Xf,
        Yf,
        Kf,
        Qf,
        qf
      ], vr = {};
      vr[Gi] = "complete", vr[Mf] = "incomplete attachment", vr[kf] = "incomplete dimensions", vr[Bf] = "incomplete, missing attachment", vr[If] = "unsupported";
      function Jf(e, r, d2, F, N, O) {
        var M = {
          cur: null,
          next: null,
          dirty: false,
          setFBO: null
        }, X = ["rgba"], W = ["rgba4", "rgb565", "rgb5 a1"];
        r.ext_srgb && W.push("srgba"), r.ext_color_buffer_half_float && W.push("rgba16f", "rgb16f"), r.webgl_color_buffer_float && W.push("rgba32f");
        var Q = ["uint8"];
        r.oes_texture_half_float && Q.push("half float", "float16"), r.oes_texture_float && Q.push("float", "float32");
        function Y(oe, Z, U) {
          this.target = oe, this.texture = Z, this.renderbuffer = U;
          var _e = 0, Le = 0;
          Z ? (_e = Z.width, Le = Z.height) : U && (_e = U.width, Le = U.height), this.width = _e, this.height = Le;
        }
        function te(oe) {
          oe && (oe.texture && oe.texture._texture.decRef(), oe.renderbuffer && oe.renderbuffer._renderbuffer.decRef());
        }
        function ie(oe, Z, U) {
          if (oe)
            if (oe.texture) {
              var _e = oe.texture._texture, Le = Math.max(1, _e.width), le = Math.max(1, _e.height);
              u(
                Le === Z && le === U,
                "inconsistent width/height for supplied texture"
              ), _e.refCount += 1;
            } else {
              var Fe = oe.renderbuffer._renderbuffer;
              u(
                Fe.width === Z && Fe.height === U,
                "inconsistent width/height for renderbuffer"
              ), Fe.refCount += 1;
            }
        }
        function H(oe, Z) {
          Z && (Z.texture ? e.framebufferTexture2D(
            Pt,
            oe,
            Z.target,
            Z.texture._texture.texture,
            0
          ) : e.framebufferRenderbuffer(
            Pt,
            oe,
            Zn,
            Z.renderbuffer._renderbuffer.renderbuffer
          ));
        }
        function re2(oe) {
          var Z = rr, U = null, _e = null, Le = oe;
          typeof oe == "object" && (Le = oe.data, "target" in oe && (Z = oe.target | 0)), u.type(Le, "function", "invalid attachment data");
          var le = Le._reglType;
          return le === "texture2d" ? (U = Le, u(Z === rr)) : le === "textureCube" ? (U = Le, u(
            Z >= fn && Z < fn + 6,
            "invalid cube map target"
          )) : le === "renderbuffer" ? (_e = Le, Z = Zn) : u.raise("invalid regl object for attachment"), new Y(Z, U, _e);
        }
        function A(oe, Z, U, _e, Le) {
          if (U) {
            var le = F.create2D({
              width: oe,
              height: Z,
              format: _e,
              type: Le
            });
            return le._texture.refCount = 0, new Y(rr, le, null);
          } else {
            var Fe = N.create({
              width: oe,
              height: Z,
              format: _e
            });
            return Fe._renderbuffer.refCount = 0, new Y(Zn, null, Fe);
          }
        }
        function B(oe) {
          return oe && (oe.texture || oe.renderbuffer);
        }
        function K(oe, Z, U) {
          oe && (oe.texture ? oe.texture.resize(Z, U) : oe.renderbuffer && oe.renderbuffer.resize(Z, U), oe.width = Z, oe.height = U);
        }
        var se = 0, z = {};
        function fe() {
          this.id = se++, z[this.id] = this, this.framebuffer = e.createFramebuffer(), this.width = 0, this.height = 0, this.colorAttachments = [], this.depthAttachment = null, this.stencilAttachment = null, this.depthStencilAttachment = null;
        }
        function V(oe) {
          oe.colorAttachments.forEach(te), te(oe.depthAttachment), te(oe.stencilAttachment), te(oe.depthStencilAttachment);
        }
        function ne(oe) {
          var Z = oe.framebuffer;
          u(Z, "must not double destroy framebuffer"), e.deleteFramebuffer(Z), oe.framebuffer = null, O.framebufferCount--, delete z[oe.id];
        }
        function j(oe) {
          var Z;
          e.bindFramebuffer(Pt, oe.framebuffer);
          var U = oe.colorAttachments;
          for (Z = 0; Z < U.length; ++Z)
            H(Ri + Z, U[Z]);
          for (Z = U.length; Z < d2.maxColorAttachments; ++Z)
            e.framebufferTexture2D(
              Pt,
              Ri + Z,
              rr,
              null,
              0
            );
          e.framebufferTexture2D(
            Pt,
            Fi,
            rr,
            null,
            0
          ), e.framebufferTexture2D(
            Pt,
            Ci,
            rr,
            null,
            0
          ), e.framebufferTexture2D(
            Pt,
            Oi,
            rr,
            null,
            0
          ), H(Ci, oe.depthAttachment), H(Oi, oe.stencilAttachment), H(Fi, oe.depthStencilAttachment);
          var _e = e.checkFramebufferStatus(Pt);
          !e.isContextLost() && _e !== Gi && u.raise("framebuffer configuration not supported, status = " + vr[_e]), e.bindFramebuffer(Pt, M.next ? M.next.framebuffer : null), M.cur = M.next, e.getError();
        }
        function ae(oe, Z) {
          var U = new fe();
          O.framebufferCount++;
          function _e(le, Fe) {
            var xe;
            u(
              M.next !== U,
              "can not update framebuffer which is currently in use"
            );
            var Oe = 0, $e = 0, et = true, ot = true, Me = null, rt = true, Ve = "rgba", tt = "uint8", nt = 1, at2 = null, ft = null, dt = null, qe = false;
            if (typeof le == "number")
              Oe = le | 0, $e = Fe | 0 || Oe;
            else if (!le)
              Oe = $e = 1;
            else {
              u.type(le, "object", "invalid arguments for framebuffer");
              var Re = le;
              if ("shape" in Re) {
                var ht = Re.shape;
                u(
                  Array.isArray(ht) && ht.length >= 2,
                  "invalid shape for framebuffer"
                ), Oe = ht[0], $e = ht[1];
              } else
                "radius" in Re && (Oe = $e = Re.radius), "width" in Re && (Oe = Re.width), "height" in Re && ($e = Re.height);
              ("color" in Re || "colors" in Re) && (Me = Re.color || Re.colors, Array.isArray(Me) && u(
                Me.length === 1 || r.webgl_draw_buffers,
                "multiple render targets not supported"
              )), Me || ("colorCount" in Re && (nt = Re.colorCount | 0, u(nt > 0, "invalid color buffer count")), "colorTexture" in Re && (rt = !!Re.colorTexture, Ve = "rgba4"), "colorType" in Re && (tt = Re.colorType, rt ? (u(
                r.oes_texture_float || !(tt === "float" || tt === "float32"),
                "you must enable OES_texture_float in order to use floating point framebuffer objects"
              ), u(
                r.oes_texture_half_float || !(tt === "half float" || tt === "float16"),
                "you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects"
              )) : tt === "half float" || tt === "float16" ? (u(
                r.ext_color_buffer_half_float,
                "you must enable EXT_color_buffer_half_float to use 16-bit render buffers"
              ), Ve = "rgba16f") : (tt === "float" || tt === "float32") && (u(
                r.webgl_color_buffer_float,
                "you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"
              ), Ve = "rgba32f"), u.oneOf(tt, Q, "invalid color type")), "colorFormat" in Re && (Ve = Re.colorFormat, X.indexOf(Ve) >= 0 ? rt = true : W.indexOf(Ve) >= 0 ? rt = false : rt ? u.oneOf(
                Re.colorFormat,
                X,
                "invalid color format for texture"
              ) : u.oneOf(
                Re.colorFormat,
                W,
                "invalid color format for renderbuffer"
              ))), ("depthTexture" in Re || "depthStencilTexture" in Re) && (qe = !!(Re.depthTexture || Re.depthStencilTexture), u(
                !qe || r.webgl_depth_texture,
                "webgl_depth_texture extension not supported"
              )), "depth" in Re && (typeof Re.depth == "boolean" ? et = Re.depth : (at2 = Re.depth, ot = false)), "stencil" in Re && (typeof Re.stencil == "boolean" ? ot = Re.stencil : (ft = Re.stencil, et = false)), "depthStencil" in Re && (typeof Re.depthStencil == "boolean" ? et = ot = Re.depthStencil : (dt = Re.depthStencil, et = false, ot = false));
            }
            var je = null, ve = null, De = null, Ne = null;
            if (Array.isArray(Me))
              je = Me.map(re2);
            else if (Me)
              je = [re2(Me)];
            else
              for (je = new Array(nt), xe = 0; xe < nt; ++xe)
                je[xe] = A(
                  Oe,
                  $e,
                  rt,
                  Ve,
                  tt
                );
            u(
              r.webgl_draw_buffers || je.length <= 1,
              "you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."
            ), u(
              je.length <= d2.maxColorAttachments,
              "too many color attachments, not supported"
            ), Oe = Oe || je[0].width, $e = $e || je[0].height, at2 ? ve = re2(at2) : et && !ot && (ve = A(
              Oe,
              $e,
              qe,
              "depth",
              "uint32"
            )), ft ? De = re2(ft) : ot && !et && (De = A(
              Oe,
              $e,
              false,
              "stencil",
              "uint8"
            )), dt ? Ne = re2(dt) : !at2 && !ft && ot && et && (Ne = A(
              Oe,
              $e,
              qe,
              "depth stencil",
              "depth stencil"
            )), u(
              !!at2 + !!ft + !!dt <= 1,
              "invalid framebuffer configuration, can specify exactly one depth/stencil attachment"
            );
            var Ke = null;
            for (xe = 0; xe < je.length; ++xe)
              if (ie(je[xe], Oe, $e), u(
                !je[xe] || je[xe].texture && zf.indexOf(je[xe].texture._texture.format) >= 0 || je[xe].renderbuffer && Zf.indexOf(je[xe].renderbuffer._renderbuffer.format) >= 0,
                "framebuffer color attachment " + xe + " is invalid"
              ), je[xe] && je[xe].texture) {
                var Nt = Jn[je[xe].texture._texture.format] * un[je[xe].texture._texture.type];
                Ke === null ? Ke = Nt : u(
                  Ke === Nt,
                  "all color attachments much have the same number of bits per pixel."
                );
              }
            return ie(ve, Oe, $e), u(
              !ve || ve.texture && ve.texture._texture.format === $f || ve.renderbuffer && ve.renderbuffer._renderbuffer.format === Hf,
              "invalid depth attachment for framebuffer object"
            ), ie(De, Oe, $e), u(
              !De || De.renderbuffer && De.renderbuffer._renderbuffer.format === Wf,
              "invalid stencil attachment for framebuffer object"
            ), ie(Ne, Oe, $e), u(
              !Ne || Ne.texture && Ne.texture._texture.format === Bi || Ne.renderbuffer && Ne.renderbuffer._renderbuffer.format === Bi,
              "invalid depth-stencil attachment for framebuffer object"
            ), V(U), U.width = Oe, U.height = $e, U.colorAttachments = je, U.depthAttachment = ve, U.stencilAttachment = De, U.depthStencilAttachment = Ne, _e.color = je.map(B), _e.depth = B(ve), _e.stencil = B(De), _e.depthStencil = B(Ne), _e.width = U.width, _e.height = U.height, j(U), _e;
          }
          function Le(le, Fe) {
            u(
              M.next !== U,
              "can not resize a framebuffer which is currently in use"
            );
            var xe = Math.max(le | 0, 1), Oe = Math.max(Fe | 0 || xe, 1);
            if (xe === U.width && Oe === U.height)
              return _e;
            for (var $e = U.colorAttachments, et = 0; et < $e.length; ++et)
              K($e[et], xe, Oe);
            return K(U.depthAttachment, xe, Oe), K(U.stencilAttachment, xe, Oe), K(U.depthStencilAttachment, xe, Oe), U.width = _e.width = xe, U.height = _e.height = Oe, j(U), _e;
          }
          return _e(oe, Z), w(_e, {
            resize: Le,
            _reglType: "framebuffer",
            _framebuffer: U,
            destroy: function() {
              ne(U), V(U);
            },
            use: function(le) {
              M.setFBO({
                framebuffer: _e
              }, le);
            }
          });
        }
        function pe(oe) {
          var Z = Array(6);
          function U(Le) {
            var le;
            u(
              Z.indexOf(M.next) < 0,
              "can not update framebuffer which is currently in use"
            );
            var Fe = {
              color: null
            }, xe = 0, Oe = null, $e = "rgba", et = "uint8", ot = 1;
            if (typeof Le == "number")
              xe = Le | 0;
            else if (!Le)
              xe = 1;
            else {
              u.type(Le, "object", "invalid arguments for framebuffer");
              var Me = Le;
              if ("shape" in Me) {
                var rt = Me.shape;
                u(
                  Array.isArray(rt) && rt.length >= 2,
                  "invalid shape for framebuffer"
                ), u(
                  rt[0] === rt[1],
                  "cube framebuffer must be square"
                ), xe = rt[0];
              } else
                "radius" in Me && (xe = Me.radius | 0), "width" in Me ? (xe = Me.width | 0, "height" in Me && u(Me.height === xe, "must be square")) : "height" in Me && (xe = Me.height | 0);
              ("color" in Me || "colors" in Me) && (Oe = Me.color || Me.colors, Array.isArray(Oe) && u(
                Oe.length === 1 || r.webgl_draw_buffers,
                "multiple render targets not supported"
              )), Oe || ("colorCount" in Me && (ot = Me.colorCount | 0, u(ot > 0, "invalid color buffer count")), "colorType" in Me && (u.oneOf(
                Me.colorType,
                Q,
                "invalid color type"
              ), et = Me.colorType), "colorFormat" in Me && ($e = Me.colorFormat, u.oneOf(
                Me.colorFormat,
                X,
                "invalid color format for texture"
              ))), "depth" in Me && (Fe.depth = Me.depth), "stencil" in Me && (Fe.stencil = Me.stencil), "depthStencil" in Me && (Fe.depthStencil = Me.depthStencil);
            }
            var Ve;
            if (Oe)
              if (Array.isArray(Oe))
                for (Ve = [], le = 0; le < Oe.length; ++le)
                  Ve[le] = Oe[le];
              else
                Ve = [Oe];
            else {
              Ve = Array(ot);
              var tt = {
                radius: xe,
                format: $e,
                type: et
              };
              for (le = 0; le < ot; ++le)
                Ve[le] = F.createCube(tt);
            }
            for (Fe.color = Array(Ve.length), le = 0; le < Ve.length; ++le) {
              var nt = Ve[le];
              u(
                typeof nt == "function" && nt._reglType === "textureCube",
                "invalid cube map"
              ), xe = xe || nt.width, u(
                nt.width === xe && nt.height === xe,
                "invalid cube map shape"
              ), Fe.color[le] = {
                target: fn,
                data: Ve[le]
              };
            }
            for (le = 0; le < 6; ++le) {
              for (var at2 = 0; at2 < Ve.length; ++at2)
                Fe.color[at2].target = fn + le;
              le > 0 && (Fe.depth = Z[0].depth, Fe.stencil = Z[0].stencil, Fe.depthStencil = Z[0].depthStencil), Z[le] ? Z[le](Fe) : Z[le] = ae(Fe);
            }
            return w(U, {
              width: xe,
              height: xe,
              color: Ve
            });
          }
          function _e(Le) {
            var le, Fe = Le | 0;
            if (u(
              Fe > 0 && Fe <= d2.maxCubeMapSize,
              "invalid radius for cube fbo"
            ), Fe === U.width)
              return U;
            var xe = U.color;
            for (le = 0; le < xe.length; ++le)
              xe[le].resize(Fe);
            for (le = 0; le < 6; ++le)
              Z[le].resize(Fe);
            return U.width = U.height = Fe, U;
          }
          return U(oe), w(U, {
            faces: Z,
            resize: _e,
            _reglType: "framebufferCube",
            destroy: function() {
              Z.forEach(function(Le) {
                Le.destroy();
              });
            }
          });
        }
        function ge() {
          M.cur = null, M.next = null, M.dirty = true, Rt(z).forEach(function(oe) {
            oe.framebuffer = e.createFramebuffer(), j(oe);
          });
        }
        return w(M, {
          getFramebuffer: function(oe) {
            if (typeof oe == "function" && oe._reglType === "framebuffer") {
              var Z = oe._framebuffer;
              if (Z instanceof fe)
                return Z;
            }
            return null;
          },
          create: ae,
          createCube: pe,
          clear: function() {
            Rt(z).forEach(ne);
          },
          restore: ge
        });
      }
      var eu = 5126, ki = 34962;
      function ea() {
        this.state = 0, this.x = 0, this.y = 0, this.z = 0, this.w = 0, this.buffer = null, this.size = 0, this.normalized = false, this.type = eu, this.offset = 0, this.stride = 0, this.divisor = 0;
      }
      function tu(e, r, d2, F, N) {
        for (var O = d2.maxAttributes, M = new Array(O), X = 0; X < O; ++X)
          M[X] = new ea();
        var W = 0, Q = {}, Y = {
          Record: ea,
          scope: {},
          state: M,
          currentVAO: null,
          targetVAO: null,
          restore: ie() ? z : function() {
          },
          createVAO: fe,
          getVAO: re2,
          destroyBuffer: te,
          setVAO: ie() ? A : B,
          clear: ie() ? K : function() {
          }
        };
        function te(V) {
          for (var ne = 0; ne < M.length; ++ne) {
            var j = M[ne];
            j.buffer === V && (e.disableVertexAttribArray(ne), j.buffer = null);
          }
        }
        function ie() {
          return r.oes_vertex_array_object;
        }
        function H() {
          return r.angle_instanced_arrays;
        }
        function re2(V) {
          return typeof V == "function" && V._vao ? V._vao : null;
        }
        function A(V) {
          if (V !== Y.currentVAO) {
            var ne = ie();
            V ? ne.bindVertexArrayOES(V.vao) : ne.bindVertexArrayOES(null), Y.currentVAO = V;
          }
        }
        function B(V) {
          if (V !== Y.currentVAO) {
            if (V)
              V.bindAttrs();
            else
              for (var ne = H(), j = 0; j < M.length; ++j) {
                var ae = M[j];
                ae.buffer ? (e.enableVertexAttribArray(j), e.vertexAttribPointer(j, ae.size, ae.type, ae.normalized, ae.stride, ae.offfset), ne && ae.divisor && ne.vertexAttribDivisorANGLE(j, ae.divisor)) : (e.disableVertexAttribArray(j), e.vertexAttrib4f(j, ae.x, ae.y, ae.z, ae.w));
              }
            Y.currentVAO = V;
          }
        }
        function K() {
          Rt(Q).forEach(function(V) {
            V.destroy();
          });
        }
        function se() {
          this.id = ++W, this.attributes = [];
          var V = ie();
          V ? this.vao = V.createVertexArrayOES() : this.vao = null, Q[this.id] = this, this.buffers = [];
        }
        se.prototype.bindAttrs = function() {
          for (var V = H(), ne = this.attributes, j = 0; j < ne.length; ++j) {
            var ae = ne[j];
            ae.buffer ? (e.enableVertexAttribArray(j), e.bindBuffer(ki, ae.buffer.buffer), e.vertexAttribPointer(j, ae.size, ae.type, ae.normalized, ae.stride, ae.offset), V && ae.divisor && V.vertexAttribDivisorANGLE(j, ae.divisor)) : (e.disableVertexAttribArray(j), e.vertexAttrib4f(j, ae.x, ae.y, ae.z, ae.w));
          }
          for (var pe = ne.length; pe < O; ++pe)
            e.disableVertexAttribArray(pe);
        }, se.prototype.refresh = function() {
          var V = ie();
          V && (V.bindVertexArrayOES(this.vao), this.bindAttrs(), Y.currentVAO = this);
        }, se.prototype.destroy = function() {
          if (this.vao) {
            var V = ie();
            this === Y.currentVAO && (Y.currentVAO = null, V.bindVertexArrayOES(null)), V.deleteVertexArrayOES(this.vao), this.vao = null;
          }
          Q[this.id] && (delete Q[this.id], F.vaoCount -= 1);
        };
        function z() {
          var V = ie();
          V && Rt(Q).forEach(function(ne) {
            ne.refresh();
          });
        }
        function fe(V) {
          var ne = new se();
          F.vaoCount += 1;
          function j(ae) {
            u(Array.isArray(ae), "arguments to vertex array constructor must be an array"), u(ae.length < O, "too many attributes"), u(ae.length > 0, "must specify at least one attribute");
            var pe = {}, ge = ne.attributes;
            ge.length = ae.length;
            for (var oe = 0; oe < ae.length; ++oe) {
              var Z = ae[oe], U = ge[oe] = new ea(), _e = Z.data || Z;
              if (Array.isArray(_e) || h2(_e) || Dt(_e)) {
                var Le;
                ne.buffers[oe] && (Le = ne.buffers[oe], h2(_e) && Le._buffer.byteLength >= _e.byteLength ? Le.subdata(_e) : (Le.destroy(), ne.buffers[oe] = null)), ne.buffers[oe] || (Le = ne.buffers[oe] = N.create(Z, ki, false, true)), U.buffer = N.getBuffer(Le), U.size = U.buffer.dimension | 0, U.normalized = false, U.type = U.buffer.dtype, U.offset = 0, U.stride = 0, U.divisor = 0, U.state = 1, pe[oe] = 1;
              } else
                N.getBuffer(Z) ? (U.buffer = N.getBuffer(Z), U.size = U.buffer.dimension | 0, U.normalized = false, U.type = U.buffer.dtype, U.offset = 0, U.stride = 0, U.divisor = 0, U.state = 1) : N.getBuffer(Z.buffer) ? (U.buffer = N.getBuffer(Z.buffer), U.size = (+Z.size || U.buffer.dimension) | 0, U.normalized = !!Z.normalized || false, "type" in Z ? (u.parameter(Z.type, Zt, "invalid buffer type"), U.type = Zt[Z.type]) : U.type = U.buffer.dtype, U.offset = (Z.offset || 0) | 0, U.stride = (Z.stride || 0) | 0, U.divisor = (Z.divisor || 0) | 0, U.state = 1, u(U.size >= 1 && U.size <= 4, "size must be between 1 and 4"), u(U.offset >= 0, "invalid offset"), u(U.stride >= 0 && U.stride <= 255, "stride must be between 0 and 255"), u(U.divisor >= 0, "divisor must be positive"), u(!U.divisor || !!r.angle_instanced_arrays, "ANGLE_instanced_arrays must be enabled to use divisor")) : "x" in Z ? (u(oe > 0, "first attribute must not be a constant"), U.x = +Z.x || 0, U.y = +Z.y || 0, U.z = +Z.z || 0, U.w = +Z.w || 0, U.state = 2) : u(false, "invalid attribute spec for location " + oe);
            }
            for (var le = 0; le < ne.buffers.length; ++le)
              !pe[le] && ne.buffers[le] && (ne.buffers[le].destroy(), ne.buffers[le] = null);
            return ne.refresh(), j;
          }
          return j.destroy = function() {
            for (var ae = 0; ae < ne.buffers.length; ++ae)
              ne.buffers[ae] && ne.buffers[ae].destroy();
            ne.buffers.length = 0, ne.destroy();
          }, j._vao = ne, j._reglType = "vao", j(V);
        }
        return Y;
      }
      var Ii = 35632, ru = 35633, nu = 35718, au = 35721;
      function iu(e, r, d2, F) {
        var N = {}, O = {};
        function M(A, B, K, se) {
          this.name = A, this.id = B, this.location = K, this.info = se;
        }
        function X(A, B) {
          for (var K = 0; K < A.length; ++K)
            if (A[K].id === B.id) {
              A[K].location = B.location;
              return;
            }
          A.push(B);
        }
        function W(A, B, K) {
          var se = A === Ii ? N : O, z = se[B];
          if (!z) {
            var fe = r.str(B);
            z = e.createShader(A), e.shaderSource(z, fe), e.compileShader(z), u.shaderError(e, z, fe, A, K), se[B] = z;
          }
          return z;
        }
        var Q = {}, Y = [], te = 0;
        function ie(A, B) {
          this.id = te++, this.fragId = A, this.vertId = B, this.program = null, this.uniforms = [], this.attributes = [], this.refCount = 1, F.profile && (this.stats = {
            uniformsCount: 0,
            attributesCount: 0
          });
        }
        function H(A, B, K) {
          var se, z, fe = W(Ii, A.fragId), V = W(ru, A.vertId), ne = A.program = e.createProgram();
          if (e.attachShader(ne, fe), e.attachShader(ne, V), K)
            for (se = 0; se < K.length; ++se) {
              var j = K[se];
              e.bindAttribLocation(ne, j[0], j[1]);
            }
          e.linkProgram(ne), u.linkError(
            e,
            ne,
            r.str(A.fragId),
            r.str(A.vertId),
            B
          );
          var ae = e.getProgramParameter(ne, nu);
          F.profile && (A.stats.uniformsCount = ae);
          var pe = A.uniforms;
          for (se = 0; se < ae; ++se)
            if (z = e.getActiveUniform(ne, se), z)
              if (z.size > 1)
                for (var ge = 0; ge < z.size; ++ge) {
                  var oe = z.name.replace("[0]", "[" + ge + "]");
                  X(pe, new M(
                    oe,
                    r.id(oe),
                    e.getUniformLocation(ne, oe),
                    z
                  ));
                }
              else
                X(pe, new M(
                  z.name,
                  r.id(z.name),
                  e.getUniformLocation(ne, z.name),
                  z
                ));
          var Z = e.getProgramParameter(ne, au);
          F.profile && (A.stats.attributesCount = Z);
          var U = A.attributes;
          for (se = 0; se < Z; ++se)
            z = e.getActiveAttrib(ne, se), z && X(U, new M(
              z.name,
              r.id(z.name),
              e.getAttribLocation(ne, z.name),
              z
            ));
        }
        F.profile && (d2.getMaxUniformsCount = function() {
          var A = 0;
          return Y.forEach(function(B) {
            B.stats.uniformsCount > A && (A = B.stats.uniformsCount);
          }), A;
        }, d2.getMaxAttributesCount = function() {
          var A = 0;
          return Y.forEach(function(B) {
            B.stats.attributesCount > A && (A = B.stats.attributesCount);
          }), A;
        });
        function re2() {
          N = {}, O = {};
          for (var A = 0; A < Y.length; ++A)
            H(Y[A], null, Y[A].attributes.map(function(B) {
              return [B.location, B.name];
            }));
        }
        return {
          clear: function() {
            var A = e.deleteShader.bind(e);
            Rt(N).forEach(A), N = {}, Rt(O).forEach(A), O = {}, Y.forEach(function(B) {
              e.deleteProgram(B.program);
            }), Y.length = 0, Q = {}, d2.shaderCount = 0;
          },
          program: function(A, B, K, se) {
            u.command(A >= 0, "missing vertex shader", K), u.command(B >= 0, "missing fragment shader", K);
            var z = Q[B];
            z || (z = Q[B] = {});
            var fe = z[A];
            if (fe && (fe.refCount++, !se))
              return fe;
            var V = new ie(B, A);
            return d2.shaderCount++, H(V, K, se), fe || (z[A] = V), Y.push(V), w(V, {
              destroy: function() {
                if (V.refCount--, V.refCount <= 0) {
                  e.deleteProgram(V.program);
                  var ne = Y.indexOf(V);
                  Y.splice(ne, 1), d2.shaderCount--;
                }
                z[V.vertId].refCount <= 0 && (e.deleteShader(O[V.vertId]), delete O[V.vertId], delete Q[V.fragId][V.vertId]), Object.keys(Q[V.fragId]).length || (e.deleteShader(N[V.fragId]), delete N[V.fragId], delete Q[V.fragId]);
              }
            });
          },
          restore: re2,
          shader: W,
          frag: -1,
          vert: -1
        };
      }
      var ou = 6408, Mr = 5121, su = 3333, cn = 5126;
      function fu(e, r, d2, F, N, O, M) {
        function X(Y) {
          var te;
          r.next === null ? (u(
            N.preserveDrawingBuffer,
            'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'
          ), te = Mr) : (u(
            r.next.colorAttachments[0].texture !== null,
            "You cannot read from a renderbuffer"
          ), te = r.next.colorAttachments[0].texture._texture.type, O.oes_texture_float ? (u(
            te === Mr || te === cn,
            "Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"
          ), te === cn && u(M.readFloat, "Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float")) : u(
            te === Mr,
            "Reading from a framebuffer is only allowed for the type 'uint8'"
          ));
          var ie = 0, H = 0, re2 = F.framebufferWidth, A = F.framebufferHeight, B = null;
          h2(Y) ? B = Y : Y && (u.type(Y, "object", "invalid arguments to regl.read()"), ie = Y.x | 0, H = Y.y | 0, u(
            ie >= 0 && ie < F.framebufferWidth,
            "invalid x offset for regl.read"
          ), u(
            H >= 0 && H < F.framebufferHeight,
            "invalid y offset for regl.read"
          ), re2 = (Y.width || F.framebufferWidth - ie) | 0, A = (Y.height || F.framebufferHeight - H) | 0, B = Y.data || null), B && (te === Mr ? u(
            B instanceof Uint8Array,
            "buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'"
          ) : te === cn && u(
            B instanceof Float32Array,
            "buffer must be 'Float32Array' when reading from a framebuffer of type 'float'"
          )), u(
            re2 > 0 && re2 + ie <= F.framebufferWidth,
            "invalid width for read pixels"
          ), u(
            A > 0 && A + H <= F.framebufferHeight,
            "invalid height for read pixels"
          ), d2();
          var K = re2 * A * 4;
          return B || (te === Mr ? B = new Uint8Array(K) : te === cn && (B = B || new Float32Array(K))), u.isTypedArray(B, "data buffer for regl.read() must be a typedarray"), u(B.byteLength >= K, "data buffer for regl.read() too small"), e.pixelStorei(su, 4), e.readPixels(
            ie,
            H,
            re2,
            A,
            ou,
            te,
            B
          ), B;
        }
        function W(Y) {
          var te;
          return r.setFBO({
            framebuffer: Y.framebuffer
          }, function() {
            te = X(Y);
          }), te;
        }
        function Q(Y) {
          return !Y || !("framebuffer" in Y) ? X(Y) : W(Y);
        }
        return Q;
      }
      function yr(e) {
        return Array.prototype.slice.call(e);
      }
      function _r(e) {
        return yr(e).join("");
      }
      function uu() {
        var e = 0, r = [], d2 = [];
        function F(te) {
          for (var ie = 0; ie < d2.length; ++ie)
            if (d2[ie] === te)
              return r[ie];
          var H = "g" + e++;
          return r.push(H), d2.push(te), H;
        }
        function N() {
          var te = [];
          function ie() {
            te.push.apply(te, yr(arguments));
          }
          var H = [];
          function re2() {
            var A = "v" + e++;
            return H.push(A), arguments.length > 0 && (te.push(A, "="), te.push.apply(te, yr(arguments)), te.push(";")), A;
          }
          return w(ie, {
            def: re2,
            toString: function() {
              return _r([
                H.length > 0 ? "var " + H.join(",") + ";" : "",
                _r(te)
              ]);
            }
          });
        }
        function O() {
          var te = N(), ie = N(), H = te.toString, re2 = ie.toString;
          function A(B, K) {
            ie(B, K, "=", te.def(B, K), ";");
          }
          return w(function() {
            te.apply(te, yr(arguments));
          }, {
            def: te.def,
            entry: te,
            exit: ie,
            save: A,
            set: function(B, K, se) {
              A(B, K), te(B, K, "=", se, ";");
            },
            toString: function() {
              return H() + re2();
            }
          });
        }
        function M() {
          var te = _r(arguments), ie = O(), H = O(), re2 = ie.toString, A = H.toString;
          return w(ie, {
            then: function() {
              return ie.apply(ie, yr(arguments)), this;
            },
            else: function() {
              return H.apply(H, yr(arguments)), this;
            },
            toString: function() {
              var B = A();
              return B && (B = "else{" + B + "}"), _r([
                "if(",
                te,
                "){",
                re2(),
                "}",
                B
              ]);
            }
          });
        }
        var X = N(), W = {};
        function Q(te, ie) {
          var H = [];
          function re2() {
            var z = "a" + H.length;
            return H.push(z), z;
          }
          ie = ie || 0;
          for (var A = 0; A < ie; ++A)
            re2();
          var B = O(), K = B.toString, se = W[te] = w(B, {
            arg: re2,
            toString: function() {
              return _r([
                "function(",
                H.join(),
                "){",
                K(),
                "}"
              ]);
            }
          });
          return se;
        }
        function Y() {
          var te = [
            '"use strict";',
            X,
            "return {"
          ];
          Object.keys(W).forEach(function(re2) {
            te.push('"', re2, '":', W[re2].toString(), ",");
          }), te.push("}");
          var ie = _r(te).replace(/;/g, `;
`).replace(/}/g, `}
`).replace(/{/g, `{
`), H = Function.apply(null, r.concat(ie));
          return H.apply(null, d2);
        }
        return {
          window: X,
          link: F,
          block: N,
          proc: Q,
          scope: O,
          cond: M,
          compile: Y
        };
      }
      var br = "xyzw".split(""), Ni = 5121, gr = 1, ta = 2, ra = 0, na = 1, aa = 2, ia = 3, ln = 4, Pi = 5, Ui = 6, $i = "dither", zi = "blend.enable", ji = "blend.color", oa = "blend.equation", sa = "blend.func", Vi = "depth.enable", Xi = "depth.func", Hi = "depth.range", Wi = "depth.mask", fa = "colorMask", Yi = "cull.enable", qi = "cull.face", ua = "frontFace", ca = "lineWidth", Ki = "polygonOffset.enable", la = "polygonOffset.offset", Qi = "sample.alpha", Zi = "sample.enable", da = "sample.coverage", Ji = "stencil.enable", eo = "stencil.mask", ha = "stencil.func", ma = "stencil.opFront", Br = "stencil.opBack", to = "scissor.enable", dn = "scissor.box", Ut = "viewport", kr = "profile", nr = "framebuffer", Ir = "vert", Nr = "frag", ar = "elements", ir = "primitive", or = "count", hn = "offset", mn = "instances", Pr = "vao", pa = "Width", va = "Height", xr = nr + pa, Er = nr + va, cu = Ut + pa, lu = Ut + va, ro = "drawingBuffer", no = ro + pa, ao = ro + va, du = [
        sa,
        oa,
        ha,
        ma,
        Br,
        da,
        Ut,
        dn,
        la
      ], wr = 34962, hu = 34963, mu = 35632, pu = 35633, io2 = 3553, vu = 34067, yu = 2884, _u = 3042, bu = 3024, gu = 2960, xu = 2929, Eu = 3089, wu = 32823, Au = 32926, Su = 32928, ya = 5126, pn = 35664, vn = 35665, yn = 35666, _a = 5124, _n = 35667, bn = 35668, gn = 35669, ba = 35670, xn = 35671, En = 35672, wn = 35673, Ur = 35674, $r = 35675, zr = 35676, jr = 35678, Vr = 35680, oo = 4, Xr = 1028, sr = 1029, so = 2304, ga = 2305, Tu = 32775, Lu = 32776, Ru = 519, Vt = 7680, fo = 0, uo = 1, co = 32774, Cu = 513, lo = 36160, Ou = 36064, It = {
        0: 0,
        1: 1,
        zero: 0,
        one: 1,
        "src color": 768,
        "one minus src color": 769,
        "src alpha": 770,
        "one minus src alpha": 771,
        "dst color": 774,
        "one minus dst color": 775,
        "dst alpha": 772,
        "one minus dst alpha": 773,
        "constant color": 32769,
        "one minus constant color": 32770,
        "constant alpha": 32771,
        "one minus constant alpha": 32772,
        "src alpha saturate": 776
      }, ho = [
        "constant color, constant alpha",
        "one minus constant color, constant alpha",
        "constant color, one minus constant alpha",
        "one minus constant color, one minus constant alpha",
        "constant alpha, constant color",
        "constant alpha, one minus constant color",
        "one minus constant alpha, constant color",
        "one minus constant alpha, one minus constant color"
      ], Ar = {
        never: 512,
        less: 513,
        "<": 513,
        equal: 514,
        "=": 514,
        "==": 514,
        "===": 514,
        lequal: 515,
        "<=": 515,
        greater: 516,
        ">": 516,
        notequal: 517,
        "!=": 517,
        "!==": 517,
        gequal: 518,
        ">=": 518,
        always: 519
      }, Xt = {
        0: 0,
        zero: 0,
        keep: 7680,
        replace: 7681,
        increment: 7682,
        decrement: 7683,
        "increment wrap": 34055,
        "decrement wrap": 34056,
        invert: 5386
      }, mo = {
        frag: mu,
        vert: pu
      }, xa = {
        cw: so,
        ccw: ga
      };
      function An(e) {
        return Array.isArray(e) || h2(e) || Dt(e);
      }
      function po(e) {
        return e.sort(function(r, d2) {
          return r === Ut ? -1 : d2 === Ut ? 1 : r < d2 ? -1 : 1;
        });
      }
      function _t(e, r, d2, F) {
        this.thisDep = e, this.contextDep = r, this.propDep = d2, this.append = F;
      }
      function Ht(e) {
        return e && !(e.thisDep || e.contextDep || e.propDep);
      }
      function Je(e) {
        return new _t(false, false, false, e);
      }
      function xt(e, r) {
        var d2 = e.type;
        if (d2 === ra) {
          var F = e.data.length;
          return new _t(
            true,
            F >= 1,
            F >= 2,
            r
          );
        } else if (d2 === ln) {
          var N = e.data;
          return new _t(
            N.thisDep,
            N.contextDep,
            N.propDep,
            r
          );
        } else {
          if (d2 === Pi)
            return new _t(
              false,
              false,
              false,
              r
            );
          if (d2 === Ui) {
            for (var O = false, M = false, X = false, W = 0; W < e.data.length; ++W) {
              var Q = e.data[W];
              if (Q.type === na)
                X = true;
              else if (Q.type === aa)
                M = true;
              else if (Q.type === ia)
                O = true;
              else if (Q.type === ra) {
                O = true;
                var Y = Q.data;
                Y >= 1 && (M = true), Y >= 2 && (X = true);
              } else
                Q.type === ln && (O = O || Q.data.thisDep, M = M || Q.data.contextDep, X = X || Q.data.propDep);
            }
            return new _t(
              O,
              M,
              X,
              r
            );
          } else
            return new _t(
              d2 === ia,
              d2 === aa,
              d2 === na,
              r
            );
        }
      }
      var vo = new _t(false, false, false, function() {
      });
      function Fu(e, r, d2, F, N, O, M, X, W, Q, Y, te, ie, H, re2) {
        var A = Q.Record, B = {
          add: 32774,
          subtract: 32778,
          "reverse subtract": 32779
        };
        d2.ext_blend_minmax && (B.min = Tu, B.max = Lu);
        var K = d2.angle_instanced_arrays, se = d2.webgl_draw_buffers, z = {
          dirty: true,
          profile: re2.profile
        }, fe = {}, V = [], ne = {}, j = {};
        function ae(s2) {
          return s2.replace(".", "_");
        }
        function pe(s2, t, v) {
          var g = ae(s2);
          V.push(s2), fe[g] = z[g] = !!v, ne[g] = t;
        }
        function ge(s2, t, v) {
          var g = ae(s2);
          V.push(s2), Array.isArray(v) ? (z[g] = v.slice(), fe[g] = v.slice()) : z[g] = fe[g] = v, j[g] = t;
        }
        pe($i, bu), pe(zi, _u), ge(ji, "blendColor", [0, 0, 0, 0]), ge(
          oa,
          "blendEquationSeparate",
          [co, co]
        ), ge(
          sa,
          "blendFuncSeparate",
          [uo, fo, uo, fo]
        ), pe(Vi, xu, true), ge(Xi, "depthFunc", Cu), ge(Hi, "depthRange", [0, 1]), ge(Wi, "depthMask", true), ge(fa, fa, [true, true, true, true]), pe(Yi, yu), ge(qi, "cullFace", sr), ge(ua, ua, ga), ge(ca, ca, 1), pe(Ki, wu), ge(la, "polygonOffset", [0, 0]), pe(Qi, Au), pe(Zi, Su), ge(da, "sampleCoverage", [1, false]), pe(Ji, gu), ge(eo, "stencilMask", -1), ge(ha, "stencilFunc", [Ru, 0, -1]), ge(
          ma,
          "stencilOpSeparate",
          [Xr, Vt, Vt, Vt]
        ), ge(
          Br,
          "stencilOpSeparate",
          [sr, Vt, Vt, Vt]
        ), pe(to, Eu), ge(
          dn,
          "scissor",
          [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
        ), ge(
          Ut,
          Ut,
          [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
        );
        var oe = {
          gl: e,
          context: ie,
          strings: r,
          next: fe,
          current: z,
          draw: te,
          elements: O,
          buffer: N,
          shader: Y,
          attributes: Q.state,
          vao: Q,
          uniforms: W,
          framebuffer: X,
          extensions: d2,
          timer: H,
          isBufferArgs: An
        }, Z = {
          primTypes: ur,
          compareFuncs: Ar,
          blendFuncs: It,
          blendEquations: B,
          stencilOps: Xt,
          glTypes: Zt,
          orientationType: xa
        };
        u.optional(function() {
          oe.isArrayLike = Ye;
        }), se && (Z.backBuffer = [sr], Z.drawBuffer = gt(F.maxDrawbuffers, function(s2) {
          return s2 === 0 ? [0] : gt(s2, function(t) {
            return Ou + t;
          });
        }));
        var U = 0;
        function _e() {
          var s2 = uu(), t = s2.link;
          s2.global, s2.id = U++, s2.batchId = "0";
          var v = t(oe), g = s2.shared = {
            props: "a0"
          };
          Object.keys(oe).forEach(function(n) {
            g[n] = window.def(v, ".", n);
          }), u.optional(function() {
            s2.CHECK = t(u), s2.commandStr = u.guessCommand(), s2.command = t(s2.commandStr), s2.assert = function(n, m2, f) {
              n(
                "if(!(",
                m2,
                "))",
                this.CHECK,
                ".commandRaise(",
                t(f),
                ",",
                this.command,
                ");"
              );
            }, Z.invalidBlendCombinations = ho;
          });
          var T = s2.next = {}, y2 = s2.current = {};
          Object.keys(j).forEach(function(n) {
            Array.isArray(z[n]) && (T[n] = window.def(g.next, ".", n), y2[n] = window.def(g.current, ".", n));
          });
          var p = s2.constants = {};
          Object.keys(Z).forEach(function(n) {
            p[n] = window.def(JSON.stringify(Z[n]));
          }), s2.invoke = function(n, m2) {
            switch (m2.type) {
              case ra:
                var f = [
                  "this",
                  g.context,
                  g.props,
                  s2.batchId
                ];
                return n.def(
                  t(m2.data),
                  ".call(",
                  f.slice(0, Math.max(m2.data.length + 1, 4)),
                  ")"
                );
              case na:
                return n.def(g.props, m2.data);
              case aa:
                return n.def(g.context, m2.data);
              case ia:
                return n.def("this", m2.data);
              case ln:
                return m2.data.append(s2, n), m2.data.ref;
              case Pi:
                return m2.data.toString();
              case Ui:
                return m2.data.map(function(E) {
                  return s2.invoke(n, E);
                });
            }
          }, s2.attribCache = {};
          var b = {};
          return s2.scopeAttrib = function(n) {
            var m2 = r.id(n);
            if (m2 in b)
              return b[m2];
            var f = Q.scope[m2];
            f || (f = Q.scope[m2] = new A());
            var E = b[m2] = t(f);
            return E;
          }, s2;
        }
        function Le(s2) {
          var t = s2.static, v = s2.dynamic, g;
          if (kr in t) {
            var T = !!t[kr];
            g = Je(function(p, b) {
              return T;
            }), g.enable = T;
          } else if (kr in v) {
            var y2 = v[kr];
            g = xt(y2, function(p, b) {
              return p.invoke(b, y2);
            });
          }
          return g;
        }
        function le(s2, t) {
          var v = s2.static, g = s2.dynamic;
          if (nr in v) {
            var T = v[nr];
            return T ? (T = X.getFramebuffer(T), u.command(T, "invalid framebuffer object"), Je(function(p, b) {
              var n = p.link(T), m2 = p.shared;
              b.set(
                m2.framebuffer,
                ".next",
                n
              );
              var f = m2.context;
              return b.set(
                f,
                "." + xr,
                n + ".width"
              ), b.set(
                f,
                "." + Er,
                n + ".height"
              ), n;
            })) : Je(function(p, b) {
              var n = p.shared;
              b.set(
                n.framebuffer,
                ".next",
                "null"
              );
              var m2 = n.context;
              return b.set(
                m2,
                "." + xr,
                m2 + "." + no
              ), b.set(
                m2,
                "." + Er,
                m2 + "." + ao
              ), "null";
            });
          } else if (nr in g) {
            var y2 = g[nr];
            return xt(y2, function(p, b) {
              var n = p.invoke(b, y2), m2 = p.shared, f = m2.framebuffer, E = b.def(
                f,
                ".getFramebuffer(",
                n,
                ")"
              );
              u.optional(function() {
                p.assert(
                  b,
                  "!" + n + "||" + E,
                  "invalid framebuffer object"
                );
              }), b.set(
                f,
                ".next",
                E
              );
              var L = m2.context;
              return b.set(
                L,
                "." + xr,
                E + "?" + E + ".width:" + L + "." + no
              ), b.set(
                L,
                "." + Er,
                E + "?" + E + ".height:" + L + "." + ao
              ), E;
            });
          } else
            return null;
        }
        function Fe(s2, t, v) {
          var g = s2.static, T = s2.dynamic;
          function y2(n) {
            if (n in g) {
              var m2 = g[n];
              u.commandType(m2, "object", "invalid " + n, v.commandStr);
              var f = true, E = m2.x | 0, L = m2.y | 0, I, P;
              return "width" in m2 ? (I = m2.width | 0, u.command(I >= 0, "invalid " + n, v.commandStr)) : f = false, "height" in m2 ? (P = m2.height | 0, u.command(P >= 0, "invalid " + n, v.commandStr)) : f = false, new _t(
                !f && t && t.thisDep,
                !f && t && t.contextDep,
                !f && t && t.propDep,
                function(me, Ce) {
                  var de = me.shared.context, ye = I;
                  "width" in m2 || (ye = Ce.def(de, ".", xr, "-", E));
                  var Ee = P;
                  return "height" in m2 || (Ee = Ce.def(de, ".", Er, "-", L)), [E, L, ye, Ee];
                }
              );
            } else if (n in T) {
              var k = T[n], q = xt(k, function(me, Ce) {
                var de = me.invoke(Ce, k);
                u.optional(function() {
                  me.assert(
                    Ce,
                    de + "&&typeof " + de + '==="object"',
                    "invalid " + n
                  );
                });
                var ye = me.shared.context, Ee = Ce.def(de, ".x|0"), ze = Ce.def(de, ".y|0"), Xe = Ce.def(
                  '"width" in ',
                  de,
                  "?",
                  de,
                  ".width|0:",
                  "(",
                  ye,
                  ".",
                  xr,
                  "-",
                  Ee,
                  ")"
                ), bt = Ce.def(
                  '"height" in ',
                  de,
                  "?",
                  de,
                  ".height|0:",
                  "(",
                  ye,
                  ".",
                  Er,
                  "-",
                  ze,
                  ")"
                );
                return u.optional(function() {
                  me.assert(
                    Ce,
                    Xe + ">=0&&" + bt + ">=0",
                    "invalid " + n
                  );
                }), [Ee, ze, Xe, bt];
              });
              return t && (q.thisDep = q.thisDep || t.thisDep, q.contextDep = q.contextDep || t.contextDep, q.propDep = q.propDep || t.propDep), q;
            } else
              return t ? new _t(
                t.thisDep,
                t.contextDep,
                t.propDep,
                function(me, Ce) {
                  var de = me.shared.context;
                  return [
                    0,
                    0,
                    Ce.def(de, ".", xr),
                    Ce.def(de, ".", Er)
                  ];
                }
              ) : null;
          }
          var p = y2(Ut);
          if (p) {
            var b = p;
            p = new _t(
              p.thisDep,
              p.contextDep,
              p.propDep,
              function(n, m2) {
                var f = b.append(n, m2), E = n.shared.context;
                return m2.set(
                  E,
                  "." + cu,
                  f[2]
                ), m2.set(
                  E,
                  "." + lu,
                  f[3]
                ), f;
              }
            );
          }
          return {
            viewport: p,
            scissor_box: y2(dn)
          };
        }
        function xe(s2, t) {
          var v = s2.static, g = typeof v[Nr] == "string" && typeof v[Ir] == "string";
          if (g) {
            if (Object.keys(t.dynamic).length > 0)
              return null;
            var T = t.static, y2 = Object.keys(T);
            if (y2.length > 0 && typeof T[y2[0]] == "number") {
              for (var p = [], b = 0; b < y2.length; ++b)
                u(typeof T[y2[b]] == "number", "must specify all vertex attribute locations when using vaos"), p.push([T[y2[b]] | 0, y2[b]]);
              return p;
            }
          }
          return null;
        }
        function Oe(s2, t, v) {
          var g = s2.static, T = s2.dynamic;
          function y2(f) {
            if (f in g) {
              var E = r.id(g[f]);
              u.optional(function() {
                Y.shader(mo[f], E, u.guessCommand());
              });
              var L = Je(function() {
                return E;
              });
              return L.id = E, L;
            } else if (f in T) {
              var I = T[f];
              return xt(I, function(P, k) {
                var q = P.invoke(k, I), me = k.def(P.shared.strings, ".id(", q, ")");
                return u.optional(function() {
                  k(
                    P.shared.shader,
                    ".shader(",
                    mo[f],
                    ",",
                    me,
                    ",",
                    P.command,
                    ");"
                  );
                }), me;
              });
            }
            return null;
          }
          var p = y2(Nr), b = y2(Ir), n = null, m2;
          return Ht(p) && Ht(b) ? (n = Y.program(b.id, p.id, null, v), m2 = Je(function(f, E) {
            return f.link(n);
          })) : m2 = new _t(
            p && p.thisDep || b && b.thisDep,
            p && p.contextDep || b && b.contextDep,
            p && p.propDep || b && b.propDep,
            function(f, E) {
              var L = f.shared.shader, I;
              p ? I = p.append(f, E) : I = E.def(L, ".", Nr);
              var P;
              b ? P = b.append(f, E) : P = E.def(L, ".", Ir);
              var k = L + ".program(" + P + "," + I;
              return u.optional(function() {
                k += "," + f.command;
              }), E.def(k + ")");
            }
          ), {
            frag: p,
            vert: b,
            progVar: m2,
            program: n
          };
        }
        function $e(s2, t) {
          var v = s2.static, g = s2.dynamic;
          function T() {
            if (ar in v) {
              var f = v[ar];
              An(f) ? f = O.getElements(O.create(f, true)) : f && (f = O.getElements(f), u.command(f, "invalid elements", t.commandStr));
              var E = Je(function(I, P) {
                if (f) {
                  var k = I.link(f);
                  return I.ELEMENTS = k, k;
                }
                return I.ELEMENTS = null, null;
              });
              return E.value = f, E;
            } else if (ar in g) {
              var L = g[ar];
              return xt(L, function(I, P) {
                var k = I.shared, q = k.isBufferArgs, me = k.elements, Ce = I.invoke(P, L), de = P.def("null"), ye = P.def(q, "(", Ce, ")"), Ee = I.cond(ye).then(de, "=", me, ".createStream(", Ce, ");").else(de, "=", me, ".getElements(", Ce, ");");
                return u.optional(function() {
                  I.assert(
                    Ee.else,
                    "!" + Ce + "||" + de,
                    "invalid elements"
                  );
                }), P.entry(Ee), P.exit(
                  I.cond(ye).then(me, ".destroyStream(", de, ");")
                ), I.ELEMENTS = de, de;
              });
            }
            return null;
          }
          var y2 = T();
          function p() {
            if (ir in v) {
              var f = v[ir];
              return u.commandParameter(f, ur, "invalid primitve", t.commandStr), Je(function(L, I) {
                return ur[f];
              });
            } else if (ir in g) {
              var E = g[ir];
              return xt(E, function(L, I) {
                var P = L.constants.primTypes, k = L.invoke(I, E);
                return u.optional(function() {
                  L.assert(
                    I,
                    k + " in " + P,
                    "invalid primitive, must be one of " + Object.keys(ur)
                  );
                }), I.def(P, "[", k, "]");
              });
            } else if (y2)
              return Ht(y2) ? y2.value ? Je(function(L, I) {
                return I.def(L.ELEMENTS, ".primType");
              }) : Je(function() {
                return oo;
              }) : new _t(
                y2.thisDep,
                y2.contextDep,
                y2.propDep,
                function(L, I) {
                  var P = L.ELEMENTS;
                  return I.def(P, "?", P, ".primType:", oo);
                }
              );
            return null;
          }
          function b(f, E) {
            if (f in v) {
              var L = v[f] | 0;
              return u.command(!E || L >= 0, "invalid " + f, t.commandStr), Je(function(P, k) {
                return E && (P.OFFSET = L), L;
              });
            } else if (f in g) {
              var I = g[f];
              return xt(I, function(P, k) {
                var q = P.invoke(k, I);
                return E && (P.OFFSET = q, u.optional(function() {
                  P.assert(
                    k,
                    q + ">=0",
                    "invalid " + f
                  );
                })), q;
              });
            } else if (E && y2)
              return Je(function(P, k) {
                return P.OFFSET = "0", 0;
              });
            return null;
          }
          var n = b(hn, true);
          function m2() {
            if (or in v) {
              var f = v[or] | 0;
              return u.command(
                typeof f == "number" && f >= 0,
                "invalid vertex count",
                t.commandStr
              ), Je(function() {
                return f;
              });
            } else if (or in g) {
              var E = g[or];
              return xt(E, function(P, k) {
                var q = P.invoke(k, E);
                return u.optional(function() {
                  P.assert(
                    k,
                    "typeof " + q + '==="number"&&' + q + ">=0&&" + q + "===(" + q + "|0)",
                    "invalid vertex count"
                  );
                }), q;
              });
            } else if (y2)
              if (Ht(y2)) {
                if (y2)
                  return n ? new _t(
                    n.thisDep,
                    n.contextDep,
                    n.propDep,
                    function(P, k) {
                      var q = k.def(
                        P.ELEMENTS,
                        ".vertCount-",
                        P.OFFSET
                      );
                      return u.optional(function() {
                        P.assert(
                          k,
                          q + ">=0",
                          "invalid vertex offset/element buffer too small"
                        );
                      }), q;
                    }
                  ) : Je(function(P, k) {
                    return k.def(P.ELEMENTS, ".vertCount");
                  });
                var L = Je(function() {
                  return -1;
                });
                return u.optional(function() {
                  L.MISSING = true;
                }), L;
              } else {
                var I = new _t(
                  y2.thisDep || n.thisDep,
                  y2.contextDep || n.contextDep,
                  y2.propDep || n.propDep,
                  function(P, k) {
                    var q = P.ELEMENTS;
                    return P.OFFSET ? k.def(
                      q,
                      "?",
                      q,
                      ".vertCount-",
                      P.OFFSET,
                      ":-1"
                    ) : k.def(q, "?", q, ".vertCount:-1");
                  }
                );
                return u.optional(function() {
                  I.DYNAMIC = true;
                }), I;
              }
            return null;
          }
          return {
            elements: y2,
            primitive: p(),
            count: m2(),
            instances: b(mn, false),
            offset: n
          };
        }
        function et(s2, t) {
          var v = s2.static, g = s2.dynamic, T = {};
          return V.forEach(function(y2) {
            var p = ae(y2);
            function b(n, m2) {
              if (y2 in v) {
                var f = n(v[y2]);
                T[p] = Je(function() {
                  return f;
                });
              } else if (y2 in g) {
                var E = g[y2];
                T[p] = xt(E, function(L, I) {
                  return m2(L, I, L.invoke(I, E));
                });
              }
            }
            switch (y2) {
              case Yi:
              case zi:
              case $i:
              case Ji:
              case Vi:
              case to:
              case Ki:
              case Qi:
              case Zi:
              case Wi:
                return b(
                  function(n) {
                    return u.commandType(n, "boolean", y2, t.commandStr), n;
                  },
                  function(n, m2, f) {
                    return u.optional(function() {
                      n.assert(
                        m2,
                        "typeof " + f + '==="boolean"',
                        "invalid flag " + y2,
                        n.commandStr
                      );
                    }), f;
                  }
                );
              case Xi:
                return b(
                  function(n) {
                    return u.commandParameter(n, Ar, "invalid " + y2, t.commandStr), Ar[n];
                  },
                  function(n, m2, f) {
                    var E = n.constants.compareFuncs;
                    return u.optional(function() {
                      n.assert(
                        m2,
                        f + " in " + E,
                        "invalid " + y2 + ", must be one of " + Object.keys(Ar)
                      );
                    }), m2.def(E, "[", f, "]");
                  }
                );
              case Hi:
                return b(
                  function(n) {
                    return u.command(
                      Ye(n) && n.length === 2 && typeof n[0] == "number" && typeof n[1] == "number" && n[0] <= n[1],
                      "depth range is 2d array",
                      t.commandStr
                    ), n;
                  },
                  function(n, m2, f) {
                    u.optional(function() {
                      n.assert(
                        m2,
                        n.shared.isArrayLike + "(" + f + ")&&" + f + ".length===2&&typeof " + f + '[0]==="number"&&typeof ' + f + '[1]==="number"&&' + f + "[0]<=" + f + "[1]",
                        "depth range must be a 2d array"
                      );
                    });
                    var E = m2.def("+", f, "[0]"), L = m2.def("+", f, "[1]");
                    return [E, L];
                  }
                );
              case sa:
                return b(
                  function(n) {
                    u.commandType(n, "object", "blend.func", t.commandStr);
                    var m2 = "srcRGB" in n ? n.srcRGB : n.src, f = "srcAlpha" in n ? n.srcAlpha : n.src, E = "dstRGB" in n ? n.dstRGB : n.dst, L = "dstAlpha" in n ? n.dstAlpha : n.dst;
                    return u.commandParameter(m2, It, p + ".srcRGB", t.commandStr), u.commandParameter(f, It, p + ".srcAlpha", t.commandStr), u.commandParameter(E, It, p + ".dstRGB", t.commandStr), u.commandParameter(L, It, p + ".dstAlpha", t.commandStr), u.command(
                      ho.indexOf(m2 + ", " + E) === -1,
                      "unallowed blending combination (srcRGB, dstRGB) = (" + m2 + ", " + E + ")",
                      t.commandStr
                    ), [
                      It[m2],
                      It[E],
                      It[f],
                      It[L]
                    ];
                  },
                  function(n, m2, f) {
                    var E = n.constants.blendFuncs;
                    u.optional(function() {
                      n.assert(
                        m2,
                        f + "&&typeof " + f + '==="object"',
                        "invalid blend func, must be an object"
                      );
                    });
                    function L(de, ye) {
                      var Ee = m2.def(
                        '"',
                        de,
                        ye,
                        '" in ',
                        f,
                        "?",
                        f,
                        ".",
                        de,
                        ye,
                        ":",
                        f,
                        ".",
                        de
                      );
                      return u.optional(function() {
                        n.assert(
                          m2,
                          Ee + " in " + E,
                          "invalid " + y2 + "." + de + ye + ", must be one of " + Object.keys(It)
                        );
                      }), Ee;
                    }
                    var I = L("src", "RGB"), P = L("dst", "RGB");
                    u.optional(function() {
                      var de = n.constants.invalidBlendCombinations;
                      n.assert(
                        m2,
                        de + ".indexOf(" + I + '+", "+' + P + ") === -1 ",
                        "unallowed blending combination for (srcRGB, dstRGB)"
                      );
                    });
                    var k = m2.def(E, "[", I, "]"), q = m2.def(E, "[", L("src", "Alpha"), "]"), me = m2.def(E, "[", P, "]"), Ce = m2.def(E, "[", L("dst", "Alpha"), "]");
                    return [k, me, q, Ce];
                  }
                );
              case oa:
                return b(
                  function(n) {
                    if (typeof n == "string")
                      return u.commandParameter(n, B, "invalid " + y2, t.commandStr), [
                        B[n],
                        B[n]
                      ];
                    if (typeof n == "object")
                      return u.commandParameter(
                        n.rgb,
                        B,
                        y2 + ".rgb",
                        t.commandStr
                      ), u.commandParameter(
                        n.alpha,
                        B,
                        y2 + ".alpha",
                        t.commandStr
                      ), [
                        B[n.rgb],
                        B[n.alpha]
                      ];
                    u.commandRaise("invalid blend.equation", t.commandStr);
                  },
                  function(n, m2, f) {
                    var E = n.constants.blendEquations, L = m2.def(), I = m2.def(), P = n.cond("typeof ", f, '==="string"');
                    return u.optional(function() {
                      function k(q, me, Ce) {
                        n.assert(
                          q,
                          Ce + " in " + E,
                          "invalid " + me + ", must be one of " + Object.keys(B)
                        );
                      }
                      k(P.then, y2, f), n.assert(
                        P.else,
                        f + "&&typeof " + f + '==="object"',
                        "invalid " + y2
                      ), k(P.else, y2 + ".rgb", f + ".rgb"), k(P.else, y2 + ".alpha", f + ".alpha");
                    }), P.then(
                      L,
                      "=",
                      I,
                      "=",
                      E,
                      "[",
                      f,
                      "];"
                    ), P.else(
                      L,
                      "=",
                      E,
                      "[",
                      f,
                      ".rgb];",
                      I,
                      "=",
                      E,
                      "[",
                      f,
                      ".alpha];"
                    ), m2(P), [L, I];
                  }
                );
              case ji:
                return b(
                  function(n) {
                    return u.command(
                      Ye(n) && n.length === 4,
                      "blend.color must be a 4d array",
                      t.commandStr
                    ), gt(4, function(m2) {
                      return +n[m2];
                    });
                  },
                  function(n, m2, f) {
                    return u.optional(function() {
                      n.assert(
                        m2,
                        n.shared.isArrayLike + "(" + f + ")&&" + f + ".length===4",
                        "blend.color must be a 4d array"
                      );
                    }), gt(4, function(E) {
                      return m2.def("+", f, "[", E, "]");
                    });
                  }
                );
              case eo:
                return b(
                  function(n) {
                    return u.commandType(n, "number", p, t.commandStr), n | 0;
                  },
                  function(n, m2, f) {
                    return u.optional(function() {
                      n.assert(
                        m2,
                        "typeof " + f + '==="number"',
                        "invalid stencil.mask"
                      );
                    }), m2.def(f, "|0");
                  }
                );
              case ha:
                return b(
                  function(n) {
                    u.commandType(n, "object", p, t.commandStr);
                    var m2 = n.cmp || "keep", f = n.ref || 0, E = "mask" in n ? n.mask : -1;
                    return u.commandParameter(m2, Ar, y2 + ".cmp", t.commandStr), u.commandType(f, "number", y2 + ".ref", t.commandStr), u.commandType(E, "number", y2 + ".mask", t.commandStr), [
                      Ar[m2],
                      f,
                      E
                    ];
                  },
                  function(n, m2, f) {
                    var E = n.constants.compareFuncs;
                    u.optional(function() {
                      function k() {
                        n.assert(
                          m2,
                          Array.prototype.join.call(arguments, ""),
                          "invalid stencil.func"
                        );
                      }
                      k(f + "&&typeof ", f, '==="object"'), k(
                        '!("cmp" in ',
                        f,
                        ")||(",
                        f,
                        ".cmp in ",
                        E,
                        ")"
                      );
                    });
                    var L = m2.def(
                      '"cmp" in ',
                      f,
                      "?",
                      E,
                      "[",
                      f,
                      ".cmp]",
                      ":",
                      Vt
                    ), I = m2.def(f, ".ref|0"), P = m2.def(
                      '"mask" in ',
                      f,
                      "?",
                      f,
                      ".mask|0:-1"
                    );
                    return [L, I, P];
                  }
                );
              case ma:
              case Br:
                return b(
                  function(n) {
                    u.commandType(n, "object", p, t.commandStr);
                    var m2 = n.fail || "keep", f = n.zfail || "keep", E = n.zpass || "keep";
                    return u.commandParameter(m2, Xt, y2 + ".fail", t.commandStr), u.commandParameter(f, Xt, y2 + ".zfail", t.commandStr), u.commandParameter(E, Xt, y2 + ".zpass", t.commandStr), [
                      y2 === Br ? sr : Xr,
                      Xt[m2],
                      Xt[f],
                      Xt[E]
                    ];
                  },
                  function(n, m2, f) {
                    var E = n.constants.stencilOps;
                    u.optional(function() {
                      n.assert(
                        m2,
                        f + "&&typeof " + f + '==="object"',
                        "invalid " + y2
                      );
                    });
                    function L(I) {
                      return u.optional(function() {
                        n.assert(
                          m2,
                          '!("' + I + '" in ' + f + ")||(" + f + "." + I + " in " + E + ")",
                          "invalid " + y2 + "." + I + ", must be one of " + Object.keys(Xt)
                        );
                      }), m2.def(
                        '"',
                        I,
                        '" in ',
                        f,
                        "?",
                        E,
                        "[",
                        f,
                        ".",
                        I,
                        "]:",
                        Vt
                      );
                    }
                    return [
                      y2 === Br ? sr : Xr,
                      L("fail"),
                      L("zfail"),
                      L("zpass")
                    ];
                  }
                );
              case la:
                return b(
                  function(n) {
                    u.commandType(n, "object", p, t.commandStr);
                    var m2 = n.factor | 0, f = n.units | 0;
                    return u.commandType(m2, "number", p + ".factor", t.commandStr), u.commandType(f, "number", p + ".units", t.commandStr), [m2, f];
                  },
                  function(n, m2, f) {
                    u.optional(function() {
                      n.assert(
                        m2,
                        f + "&&typeof " + f + '==="object"',
                        "invalid " + y2
                      );
                    });
                    var E = m2.def(f, ".factor|0"), L = m2.def(f, ".units|0");
                    return [E, L];
                  }
                );
              case qi:
                return b(
                  function(n) {
                    var m2 = 0;
                    return n === "front" ? m2 = Xr : n === "back" && (m2 = sr), u.command(!!m2, p, t.commandStr), m2;
                  },
                  function(n, m2, f) {
                    return u.optional(function() {
                      n.assert(
                        m2,
                        f + '==="front"||' + f + '==="back"',
                        "invalid cull.face"
                      );
                    }), m2.def(f, '==="front"?', Xr, ":", sr);
                  }
                );
              case ca:
                return b(
                  function(n) {
                    return u.command(
                      typeof n == "number" && n >= F.lineWidthDims[0] && n <= F.lineWidthDims[1],
                      "invalid line width, must be a positive number between " + F.lineWidthDims[0] + " and " + F.lineWidthDims[1],
                      t.commandStr
                    ), n;
                  },
                  function(n, m2, f) {
                    return u.optional(function() {
                      n.assert(
                        m2,
                        "typeof " + f + '==="number"&&' + f + ">=" + F.lineWidthDims[0] + "&&" + f + "<=" + F.lineWidthDims[1],
                        "invalid line width"
                      );
                    }), f;
                  }
                );
              case ua:
                return b(
                  function(n) {
                    return u.commandParameter(n, xa, p, t.commandStr), xa[n];
                  },
                  function(n, m2, f) {
                    return u.optional(function() {
                      n.assert(
                        m2,
                        f + '==="cw"||' + f + '==="ccw"',
                        "invalid frontFace, must be one of cw,ccw"
                      );
                    }), m2.def(f + '==="cw"?' + so + ":" + ga);
                  }
                );
              case fa:
                return b(
                  function(n) {
                    return u.command(
                      Ye(n) && n.length === 4,
                      "color.mask must be length 4 array",
                      t.commandStr
                    ), n.map(function(m2) {
                      return !!m2;
                    });
                  },
                  function(n, m2, f) {
                    return u.optional(function() {
                      n.assert(
                        m2,
                        n.shared.isArrayLike + "(" + f + ")&&" + f + ".length===4",
                        "invalid color.mask"
                      );
                    }), gt(4, function(E) {
                      return "!!" + f + "[" + E + "]";
                    });
                  }
                );
              case da:
                return b(
                  function(n) {
                    u.command(typeof n == "object" && n, p, t.commandStr);
                    var m2 = "value" in n ? n.value : 1, f = !!n.invert;
                    return u.command(
                      typeof m2 == "number" && m2 >= 0 && m2 <= 1,
                      "sample.coverage.value must be a number between 0 and 1",
                      t.commandStr
                    ), [m2, f];
                  },
                  function(n, m2, f) {
                    u.optional(function() {
                      n.assert(
                        m2,
                        f + "&&typeof " + f + '==="object"',
                        "invalid sample.coverage"
                      );
                    });
                    var E = m2.def(
                      '"value" in ',
                      f,
                      "?+",
                      f,
                      ".value:1"
                    ), L = m2.def("!!", f, ".invert");
                    return [E, L];
                  }
                );
            }
          }), T;
        }
        function ot(s2, t) {
          var v = s2.static, g = s2.dynamic, T = {};
          return Object.keys(v).forEach(function(y2) {
            var p = v[y2], b;
            if (typeof p == "number" || typeof p == "boolean")
              b = Je(function() {
                return p;
              });
            else if (typeof p == "function") {
              var n = p._reglType;
              n === "texture2d" || n === "textureCube" ? b = Je(function(m2) {
                return m2.link(p);
              }) : n === "framebuffer" || n === "framebufferCube" ? (u.command(
                p.color.length > 0,
                'missing color attachment for framebuffer sent to uniform "' + y2 + '"',
                t.commandStr
              ), b = Je(function(m2) {
                return m2.link(p.color[0]);
              })) : u.commandRaise('invalid data for uniform "' + y2 + '"', t.commandStr);
            } else
              Ye(p) ? b = Je(function(m2) {
                var f = m2.global.def(
                  "[",
                  gt(p.length, function(E) {
                    return u.command(
                      typeof p[E] == "number" || typeof p[E] == "boolean",
                      "invalid uniform " + y2,
                      m2.commandStr
                    ), p[E];
                  }),
                  "]"
                );
                return f;
              }) : u.commandRaise('invalid or missing data for uniform "' + y2 + '"', t.commandStr);
            b.value = p, T[y2] = b;
          }), Object.keys(g).forEach(function(y2) {
            var p = g[y2];
            T[y2] = xt(p, function(b, n) {
              return b.invoke(n, p);
            });
          }), T;
        }
        function Me(s2, t) {
          var v = s2.static, g = s2.dynamic, T = {};
          return Object.keys(v).forEach(function(y2) {
            var p = v[y2], b = r.id(y2), n = new A();
            if (An(p))
              n.state = gr, n.buffer = N.getBuffer(
                N.create(p, wr, false, true)
              ), n.type = 0;
            else {
              var m2 = N.getBuffer(p);
              if (m2)
                n.state = gr, n.buffer = m2, n.type = 0;
              else if (u.command(
                typeof p == "object" && p,
                "invalid data for attribute " + y2,
                t.commandStr
              ), "constant" in p) {
                var f = p.constant;
                n.buffer = "null", n.state = ta, typeof f == "number" ? n.x = f : (u.command(
                  Ye(f) && f.length > 0 && f.length <= 4,
                  "invalid constant for attribute " + y2,
                  t.commandStr
                ), br.forEach(function(me, Ce) {
                  Ce < f.length && (n[me] = f[Ce]);
                }));
              } else {
                An(p.buffer) ? m2 = N.getBuffer(
                  N.create(p.buffer, wr, false, true)
                ) : m2 = N.getBuffer(p.buffer), u.command(!!m2, 'missing buffer for attribute "' + y2 + '"', t.commandStr);
                var E = p.offset | 0;
                u.command(
                  E >= 0,
                  'invalid offset for attribute "' + y2 + '"',
                  t.commandStr
                );
                var L = p.stride | 0;
                u.command(
                  L >= 0 && L < 256,
                  'invalid stride for attribute "' + y2 + '", must be integer betweeen [0, 255]',
                  t.commandStr
                );
                var I = p.size | 0;
                u.command(
                  !("size" in p) || I > 0 && I <= 4,
                  'invalid size for attribute "' + y2 + '", must be 1,2,3,4',
                  t.commandStr
                );
                var P = !!p.normalized, k = 0;
                "type" in p && (u.commandParameter(
                  p.type,
                  Zt,
                  "invalid type for attribute " + y2,
                  t.commandStr
                ), k = Zt[p.type]);
                var q = p.divisor | 0;
                "divisor" in p && (u.command(
                  q === 0 || K,
                  'cannot specify divisor for attribute "' + y2 + '", instancing not supported',
                  t.commandStr
                ), u.command(
                  q >= 0,
                  'invalid divisor for attribute "' + y2 + '"',
                  t.commandStr
                )), u.optional(function() {
                  var me = t.commandStr, Ce = [
                    "buffer",
                    "offset",
                    "divisor",
                    "normalized",
                    "type",
                    "size",
                    "stride"
                  ];
                  Object.keys(p).forEach(function(de) {
                    u.command(
                      Ce.indexOf(de) >= 0,
                      'unknown parameter "' + de + '" for attribute pointer "' + y2 + '" (valid parameters are ' + Ce + ")",
                      me
                    );
                  });
                }), n.buffer = m2, n.state = gr, n.size = I, n.normalized = P, n.type = k || m2.dtype, n.offset = E, n.stride = L, n.divisor = q;
              }
            }
            T[y2] = Je(function(me, Ce) {
              var de = me.attribCache;
              if (b in de)
                return de[b];
              var ye = {
                isStream: false
              };
              return Object.keys(n).forEach(function(Ee) {
                ye[Ee] = n[Ee];
              }), n.buffer && (ye.buffer = me.link(n.buffer), ye.type = ye.type || ye.buffer + ".dtype"), de[b] = ye, ye;
            });
          }), Object.keys(g).forEach(function(y2) {
            var p = g[y2];
            function b(n, m2) {
              var f = n.invoke(m2, p), E = n.shared, L = n.constants, I = E.isBufferArgs, P = E.buffer;
              u.optional(function() {
                n.assert(
                  m2,
                  f + "&&(typeof " + f + '==="object"||typeof ' + f + '==="function")&&(' + I + "(" + f + ")||" + P + ".getBuffer(" + f + ")||" + P + ".getBuffer(" + f + ".buffer)||" + I + "(" + f + '.buffer)||("constant" in ' + f + "&&(typeof " + f + '.constant==="number"||' + E.isArrayLike + "(" + f + ".constant))))",
                  'invalid dynamic attribute "' + y2 + '"'
                );
              });
              var k = {
                isStream: m2.def(false)
              }, q = new A();
              q.state = gr, Object.keys(q).forEach(function(ye) {
                k[ye] = m2.def("" + q[ye]);
              });
              var me = k.buffer, Ce = k.type;
              m2(
                "if(",
                I,
                "(",
                f,
                ")){",
                k.isStream,
                "=true;",
                me,
                "=",
                P,
                ".createStream(",
                wr,
                ",",
                f,
                ");",
                Ce,
                "=",
                me,
                ".dtype;",
                "}else{",
                me,
                "=",
                P,
                ".getBuffer(",
                f,
                ");",
                "if(",
                me,
                "){",
                Ce,
                "=",
                me,
                ".dtype;",
                '}else if("constant" in ',
                f,
                "){",
                k.state,
                "=",
                ta,
                ";",
                "if(typeof " + f + '.constant === "number"){',
                k[br[0]],
                "=",
                f,
                ".constant;",
                br.slice(1).map(function(ye) {
                  return k[ye];
                }).join("="),
                "=0;",
                "}else{",
                br.map(function(ye, Ee) {
                  return k[ye] + "=" + f + ".constant.length>" + Ee + "?" + f + ".constant[" + Ee + "]:0;";
                }).join(""),
                "}}else{",
                "if(",
                I,
                "(",
                f,
                ".buffer)){",
                me,
                "=",
                P,
                ".createStream(",
                wr,
                ",",
                f,
                ".buffer);",
                "}else{",
                me,
                "=",
                P,
                ".getBuffer(",
                f,
                ".buffer);",
                "}",
                Ce,
                '="type" in ',
                f,
                "?",
                L.glTypes,
                "[",
                f,
                ".type]:",
                me,
                ".dtype;",
                k.normalized,
                "=!!",
                f,
                ".normalized;"
              );
              function de(ye) {
                m2(k[ye], "=", f, ".", ye, "|0;");
              }
              return de("size"), de("offset"), de("stride"), de("divisor"), m2("}}"), m2.exit(
                "if(",
                k.isStream,
                "){",
                P,
                ".destroyStream(",
                me,
                ");",
                "}"
              ), k;
            }
            T[y2] = xt(p, b);
          }), T;
        }
        function rt(s2, t) {
          var v = s2.static, g = s2.dynamic;
          if (Pr in v) {
            var T = v[Pr];
            return T !== null && Q.getVAO(T) === null && (T = Q.createVAO(T)), Je(function(p) {
              return p.link(Q.getVAO(T));
            });
          } else if (Pr in g) {
            var y2 = g[Pr];
            return xt(y2, function(p, b) {
              var n = p.invoke(b, y2);
              return b.def(p.shared.vao + ".getVAO(" + n + ")");
            });
          }
          return null;
        }
        function Ve(s2) {
          var t = s2.static, v = s2.dynamic, g = {};
          return Object.keys(t).forEach(function(T) {
            var y2 = t[T];
            g[T] = Je(function(p, b) {
              return typeof y2 == "number" || typeof y2 == "boolean" ? "" + y2 : p.link(y2);
            });
          }), Object.keys(v).forEach(function(T) {
            var y2 = v[T];
            g[T] = xt(y2, function(p, b) {
              return p.invoke(b, y2);
            });
          }), g;
        }
        function tt(s2, t, v, g, T) {
          var y2 = s2.static, p = s2.dynamic;
          u.optional(function() {
            var de = [
              nr,
              Ir,
              Nr,
              ar,
              ir,
              hn,
              or,
              mn,
              kr,
              Pr
            ].concat(V);
            function ye(Ee) {
              Object.keys(Ee).forEach(function(ze) {
                u.command(
                  de.indexOf(ze) >= 0,
                  'unknown parameter "' + ze + '"',
                  T.commandStr
                );
              });
            }
            ye(y2), ye(p);
          });
          var b = xe(s2, t), n = le(s2), m2 = Fe(s2, n, T), f = $e(s2, T), E = et(s2, T), L = Oe(s2, T, b);
          function I(de) {
            var ye = m2[de];
            ye && (E[de] = ye);
          }
          I(Ut), I(ae(dn));
          var P = Object.keys(E).length > 0, k = {
            framebuffer: n,
            draw: f,
            shader: L,
            state: E,
            dirty: P,
            scopeVAO: null,
            drawVAO: null,
            useVAO: false,
            attributes: {}
          };
          if (k.profile = Le(s2), k.uniforms = ot(v, T), k.drawVAO = k.scopeVAO = rt(s2), !k.drawVAO && L.program && !b && d2.angle_instanced_arrays) {
            var q = true, me = L.program.attributes.map(function(de) {
              var ye = t.static[de];
              return q = q && !!ye, ye;
            });
            if (q && me.length > 0) {
              var Ce = Q.getVAO(Q.createVAO(me));
              k.drawVAO = new _t(null, null, null, function(de, ye) {
                return de.link(Ce);
              }), k.useVAO = true;
            }
          }
          return b ? k.useVAO = true : k.attributes = Me(t, T), k.context = Ve(g), k;
        }
        function nt(s2, t, v) {
          var g = s2.shared, T = g.context, y2 = s2.scope();
          Object.keys(v).forEach(function(p) {
            t.save(T, "." + p);
            var b = v[p], n = b.append(s2, t);
            Array.isArray(n) ? y2(T, ".", p, "=[", n.join(), "];") : y2(T, ".", p, "=", n, ";");
          }), t(y2);
        }
        function at2(s2, t, v, g) {
          var T = s2.shared, y2 = T.gl, p = T.framebuffer, b;
          se && (b = t.def(T.extensions, ".webgl_draw_buffers"));
          var n = s2.constants, m2 = n.drawBuffer, f = n.backBuffer, E;
          v ? E = v.append(s2, t) : E = t.def(p, ".next"), g || t("if(", E, "!==", p, ".cur){"), t(
            "if(",
            E,
            "){",
            y2,
            ".bindFramebuffer(",
            lo,
            ",",
            E,
            ".framebuffer);"
          ), se && t(
            b,
            ".drawBuffersWEBGL(",
            m2,
            "[",
            E,
            ".colorAttachments.length]);"
          ), t(
            "}else{",
            y2,
            ".bindFramebuffer(",
            lo,
            ",null);"
          ), se && t(b, ".drawBuffersWEBGL(", f, ");"), t(
            "}",
            p,
            ".cur=",
            E,
            ";"
          ), g || t("}");
        }
        function ft(s2, t, v) {
          var g = s2.shared, T = g.gl, y2 = s2.current, p = s2.next, b = g.current, n = g.next, m2 = s2.cond(b, ".dirty");
          V.forEach(function(f) {
            var E = ae(f);
            if (!(E in v.state)) {
              var L, I;
              if (E in p) {
                L = p[E], I = y2[E];
                var P = gt(z[E].length, function(q) {
                  return m2.def(L, "[", q, "]");
                });
                m2(s2.cond(P.map(function(q, me) {
                  return q + "!==" + I + "[" + me + "]";
                }).join("||")).then(
                  T,
                  ".",
                  j[E],
                  "(",
                  P,
                  ");",
                  P.map(function(q, me) {
                    return I + "[" + me + "]=" + q;
                  }).join(";"),
                  ";"
                ));
              } else {
                L = m2.def(n, ".", E);
                var k = s2.cond(L, "!==", b, ".", E);
                m2(k), E in ne ? k(
                  s2.cond(L).then(T, ".enable(", ne[E], ");").else(T, ".disable(", ne[E], ");"),
                  b,
                  ".",
                  E,
                  "=",
                  L,
                  ";"
                ) : k(
                  T,
                  ".",
                  j[E],
                  "(",
                  L,
                  ");",
                  b,
                  ".",
                  E,
                  "=",
                  L,
                  ";"
                );
              }
            }
          }), Object.keys(v.state).length === 0 && m2(b, ".dirty=false;"), t(m2);
        }
        function dt(s2, t, v, g) {
          var T = s2.shared, y2 = s2.current, p = T.current, b = T.gl;
          po(Object.keys(v)).forEach(function(n) {
            var m2 = v[n];
            if (!(g && !g(m2))) {
              var f = m2.append(s2, t);
              if (ne[n]) {
                var E = ne[n];
                Ht(m2) ? f ? t(b, ".enable(", E, ");") : t(b, ".disable(", E, ");") : t(s2.cond(f).then(b, ".enable(", E, ");").else(b, ".disable(", E, ");")), t(p, ".", n, "=", f, ";");
              } else if (Ye(f)) {
                var L = y2[n];
                t(
                  b,
                  ".",
                  j[n],
                  "(",
                  f,
                  ");",
                  f.map(function(I, P) {
                    return L + "[" + P + "]=" + I;
                  }).join(";"),
                  ";"
                );
              } else
                t(
                  b,
                  ".",
                  j[n],
                  "(",
                  f,
                  ");",
                  p,
                  ".",
                  n,
                  "=",
                  f,
                  ";"
                );
            }
          });
        }
        function qe(s2, t) {
          K && (s2.instancing = t.def(
            s2.shared.extensions,
            ".angle_instanced_arrays"
          ));
        }
        function Re(s2, t, v, g, T) {
          var y2 = s2.shared, p = s2.stats, b = y2.current, n = y2.timer, m2 = v.profile;
          function f() {
            return typeof performance > "u" ? "Date.now()" : "performance.now()";
          }
          var E, L;
          function I(de) {
            E = t.def(), de(E, "=", f(), ";"), typeof T == "string" ? de(p, ".count+=", T, ";") : de(p, ".count++;"), H && (g ? (L = t.def(), de(L, "=", n, ".getNumPendingQueries();")) : de(n, ".beginQuery(", p, ");"));
          }
          function P(de) {
            de(p, ".cpuTime+=", f(), "-", E, ";"), H && (g ? de(
              n,
              ".pushScopeStats(",
              L,
              ",",
              n,
              ".getNumPendingQueries(),",
              p,
              ");"
            ) : de(n, ".endQuery();"));
          }
          function k(de) {
            var ye = t.def(b, ".profile");
            t(b, ".profile=", de, ";"), t.exit(b, ".profile=", ye, ";");
          }
          var q;
          if (m2) {
            if (Ht(m2)) {
              m2.enable ? (I(t), P(t.exit), k("true")) : k("false");
              return;
            }
            q = m2.append(s2, t), k(q);
          } else
            q = t.def(b, ".profile");
          var me = s2.block();
          I(me), t("if(", q, "){", me, "}");
          var Ce = s2.block();
          P(Ce), t.exit("if(", q, "){", Ce, "}");
        }
        function ht(s2, t, v, g, T) {
          var y2 = s2.shared;
          function p(n) {
            switch (n) {
              case pn:
              case _n:
              case xn:
                return 2;
              case vn:
              case bn:
              case En:
                return 3;
              case yn:
              case gn:
              case wn:
                return 4;
              default:
                return 1;
            }
          }
          function b(n, m2, f) {
            var E = y2.gl, L = t.def(n, ".location"), I = t.def(y2.attributes, "[", L, "]"), P = f.state, k = f.buffer, q = [
              f.x,
              f.y,
              f.z,
              f.w
            ], me = [
              "buffer",
              "normalized",
              "offset",
              "stride"
            ];
            function Ce() {
              t(
                "if(!",
                I,
                ".buffer){",
                E,
                ".enableVertexAttribArray(",
                L,
                ");}"
              );
              var ye = f.type, Ee;
              if (f.size ? Ee = t.def(f.size, "||", m2) : Ee = m2, t(
                "if(",
                I,
                ".type!==",
                ye,
                "||",
                I,
                ".size!==",
                Ee,
                "||",
                me.map(function(Xe) {
                  return I + "." + Xe + "!==" + f[Xe];
                }).join("||"),
                "){",
                E,
                ".bindBuffer(",
                wr,
                ",",
                k,
                ".buffer);",
                E,
                ".vertexAttribPointer(",
                [
                  L,
                  Ee,
                  ye,
                  f.normalized,
                  f.stride,
                  f.offset
                ],
                ");",
                I,
                ".type=",
                ye,
                ";",
                I,
                ".size=",
                Ee,
                ";",
                me.map(function(Xe) {
                  return I + "." + Xe + "=" + f[Xe] + ";";
                }).join(""),
                "}"
              ), K) {
                var ze = f.divisor;
                t(
                  "if(",
                  I,
                  ".divisor!==",
                  ze,
                  "){",
                  s2.instancing,
                  ".vertexAttribDivisorANGLE(",
                  [L, ze],
                  ");",
                  I,
                  ".divisor=",
                  ze,
                  ";}"
                );
              }
            }
            function de() {
              t(
                "if(",
                I,
                ".buffer){",
                E,
                ".disableVertexAttribArray(",
                L,
                ");",
                I,
                ".buffer=null;",
                "}if(",
                br.map(function(ye, Ee) {
                  return I + "." + ye + "!==" + q[Ee];
                }).join("||"),
                "){",
                E,
                ".vertexAttrib4f(",
                L,
                ",",
                q,
                ");",
                br.map(function(ye, Ee) {
                  return I + "." + ye + "=" + q[Ee] + ";";
                }).join(""),
                "}"
              );
            }
            P === gr ? Ce() : P === ta ? de() : (t("if(", P, "===", gr, "){"), Ce(), t("}else{"), de(), t("}"));
          }
          g.forEach(function(n) {
            var m2 = n.name, f = v.attributes[m2], E;
            if (f) {
              if (!T(f))
                return;
              E = f.append(s2, t);
            } else {
              if (!T(vo))
                return;
              var L = s2.scopeAttrib(m2);
              u.optional(function() {
                s2.assert(
                  t,
                  L + ".state",
                  "missing attribute " + m2
                );
              }), E = {}, Object.keys(new A()).forEach(function(I) {
                E[I] = t.def(L, ".", I);
              });
            }
            b(
              s2.link(n),
              p(n.info.type),
              E
            );
          });
        }
        function je(s2, t, v, g, T) {
          for (var y2 = s2.shared, p = y2.gl, b, n = 0; n < g.length; ++n) {
            var m2 = g[n], f = m2.name, E = m2.info.type, L = v.uniforms[f], I = s2.link(m2), P = I + ".location", k;
            if (L) {
              if (!T(L))
                continue;
              if (Ht(L)) {
                var q = L.value;
                if (u.command(
                  q !== null && typeof q < "u",
                  'missing uniform "' + f + '"',
                  s2.commandStr
                ), E === jr || E === Vr) {
                  u.command(
                    typeof q == "function" && (E === jr && (q._reglType === "texture2d" || q._reglType === "framebuffer") || E === Vr && (q._reglType === "textureCube" || q._reglType === "framebufferCube")),
                    "invalid texture for uniform " + f,
                    s2.commandStr
                  );
                  var me = s2.link(q._texture || q.color[0]._texture);
                  t(p, ".uniform1i(", P, ",", me + ".bind());"), t.exit(me, ".unbind();");
                } else if (E === Ur || E === $r || E === zr) {
                  u.optional(function() {
                    u.command(
                      Ye(q),
                      "invalid matrix for uniform " + f,
                      s2.commandStr
                    ), u.command(
                      E === Ur && q.length === 4 || E === $r && q.length === 9 || E === zr && q.length === 16,
                      "invalid length for matrix uniform " + f,
                      s2.commandStr
                    );
                  });
                  var Ce = s2.global.def("new Float32Array([" + Array.prototype.slice.call(q) + "])"), de = 2;
                  E === $r ? de = 3 : E === zr && (de = 4), t(
                    p,
                    ".uniformMatrix",
                    de,
                    "fv(",
                    P,
                    ",false,",
                    Ce,
                    ");"
                  );
                } else {
                  switch (E) {
                    case ya:
                      u.commandType(q, "number", "uniform " + f, s2.commandStr), b = "1f";
                      break;
                    case pn:
                      u.command(
                        Ye(q) && q.length === 2,
                        "uniform " + f,
                        s2.commandStr
                      ), b = "2f";
                      break;
                    case vn:
                      u.command(
                        Ye(q) && q.length === 3,
                        "uniform " + f,
                        s2.commandStr
                      ), b = "3f";
                      break;
                    case yn:
                      u.command(
                        Ye(q) && q.length === 4,
                        "uniform " + f,
                        s2.commandStr
                      ), b = "4f";
                      break;
                    case ba:
                      u.commandType(q, "boolean", "uniform " + f, s2.commandStr), b = "1i";
                      break;
                    case _a:
                      u.commandType(q, "number", "uniform " + f, s2.commandStr), b = "1i";
                      break;
                    case xn:
                      u.command(
                        Ye(q) && q.length === 2,
                        "uniform " + f,
                        s2.commandStr
                      ), b = "2i";
                      break;
                    case _n:
                      u.command(
                        Ye(q) && q.length === 2,
                        "uniform " + f,
                        s2.commandStr
                      ), b = "2i";
                      break;
                    case En:
                      u.command(
                        Ye(q) && q.length === 3,
                        "uniform " + f,
                        s2.commandStr
                      ), b = "3i";
                      break;
                    case bn:
                      u.command(
                        Ye(q) && q.length === 3,
                        "uniform " + f,
                        s2.commandStr
                      ), b = "3i";
                      break;
                    case wn:
                      u.command(
                        Ye(q) && q.length === 4,
                        "uniform " + f,
                        s2.commandStr
                      ), b = "4i";
                      break;
                    case gn:
                      u.command(
                        Ye(q) && q.length === 4,
                        "uniform " + f,
                        s2.commandStr
                      ), b = "4i";
                      break;
                  }
                  t(
                    p,
                    ".uniform",
                    b,
                    "(",
                    P,
                    ",",
                    Ye(q) ? Array.prototype.slice.call(q) : q,
                    ");"
                  );
                }
                continue;
              } else
                k = L.append(s2, t);
            } else {
              if (!T(vo))
                continue;
              k = t.def(y2.uniforms, "[", r.id(f), "]");
            }
            E === jr ? (u(!Array.isArray(k), "must specify a scalar prop for textures"), t(
              "if(",
              k,
              "&&",
              k,
              '._reglType==="framebuffer"){',
              k,
              "=",
              k,
              ".color[0];",
              "}"
            )) : E === Vr && (u(!Array.isArray(k), "must specify a scalar prop for cube maps"), t(
              "if(",
              k,
              "&&",
              k,
              '._reglType==="framebufferCube"){',
              k,
              "=",
              k,
              ".color[0];",
              "}"
            )), u.optional(function() {
              function bt(Bt, wo) {
                s2.assert(
                  t,
                  Bt,
                  'bad data or missing for uniform "' + f + '".  ' + wo
                );
              }
              function Ea(Bt) {
                u(!Array.isArray(k), "must not specify an array type for uniform"), bt(
                  "typeof " + k + '==="' + Bt + '"',
                  "invalid type, expected " + Bt
                );
              }
              function Ft(Bt, wo) {
                Array.isArray(k) ? u(k.length === Bt, "must have length " + Bt) : bt(
                  y2.isArrayLike + "(" + k + ")&&" + k + ".length===" + Bt,
                  "invalid vector, should have length " + Bt,
                  s2.commandStr
                );
              }
              function Eo(Bt) {
                u(!Array.isArray(k), "must not specify a value type"), bt(
                  "typeof " + k + '==="function"&&' + k + '._reglType==="texture' + (Bt === io2 ? "2d" : "Cube") + '"',
                  "invalid texture type",
                  s2.commandStr
                );
              }
              switch (E) {
                case _a:
                  Ea("number");
                  break;
                case _n:
                  Ft(2);
                  break;
                case bn:
                  Ft(3);
                  break;
                case gn:
                  Ft(4);
                  break;
                case ya:
                  Ea("number");
                  break;
                case pn:
                  Ft(2);
                  break;
                case vn:
                  Ft(3);
                  break;
                case yn:
                  Ft(4);
                  break;
                case ba:
                  Ea("boolean");
                  break;
                case xn:
                  Ft(2);
                  break;
                case En:
                  Ft(3);
                  break;
                case wn:
                  Ft(4);
                  break;
                case Ur:
                  Ft(4);
                  break;
                case $r:
                  Ft(9);
                  break;
                case zr:
                  Ft(16);
                  break;
                case jr:
                  Eo(io2);
                  break;
                case Vr:
                  Eo(vu);
                  break;
              }
            });
            var ye = 1;
            switch (E) {
              case jr:
              case Vr:
                var Ee = t.def(k, "._texture");
                t(p, ".uniform1i(", P, ",", Ee, ".bind());"), t.exit(Ee, ".unbind();");
                continue;
              case _a:
              case ba:
                b = "1i";
                break;
              case _n:
              case xn:
                b = "2i", ye = 2;
                break;
              case bn:
              case En:
                b = "3i", ye = 3;
                break;
              case gn:
              case wn:
                b = "4i", ye = 4;
                break;
              case ya:
                b = "1f";
                break;
              case pn:
                b = "2f", ye = 2;
                break;
              case vn:
                b = "3f", ye = 3;
                break;
              case yn:
                b = "4f", ye = 4;
                break;
              case Ur:
                b = "Matrix2fv";
                break;
              case $r:
                b = "Matrix3fv";
                break;
              case zr:
                b = "Matrix4fv";
                break;
            }
            if (t(p, ".uniform", b, "(", P, ","), b.charAt(0) === "M") {
              var ze = Math.pow(E - Ur + 2, 2), Xe = s2.global.def("new Float32Array(", ze, ")");
              Array.isArray(k) ? t(
                "false,(",
                gt(ze, function(bt) {
                  return Xe + "[" + bt + "]=" + k[bt];
                }),
                ",",
                Xe,
                ")"
              ) : t(
                "false,(Array.isArray(",
                k,
                ")||",
                k,
                " instanceof Float32Array)?",
                k,
                ":(",
                gt(ze, function(bt) {
                  return Xe + "[" + bt + "]=" + k + "[" + bt + "]";
                }),
                ",",
                Xe,
                ")"
              );
            } else
              ye > 1 ? t(gt(ye, function(bt) {
                return Array.isArray(k) ? k[bt] : k + "[" + bt + "]";
              })) : (u(!Array.isArray(k), "uniform value must not be an array"), t(k));
            t(");");
          }
        }
        function ve(s2, t, v, g) {
          var T = s2.shared, y2 = T.gl, p = T.draw, b = g.draw;
          function n() {
            var Ee = b.elements, ze, Xe = t;
            return Ee ? ((Ee.contextDep && g.contextDynamic || Ee.propDep) && (Xe = v), ze = Ee.append(s2, Xe)) : ze = Xe.def(p, ".", ar), ze && Xe(
              "if(" + ze + ")" + y2 + ".bindBuffer(" + hu + "," + ze + ".buffer.buffer);"
            ), ze;
          }
          function m2() {
            var Ee = b.count, ze, Xe = t;
            return Ee ? ((Ee.contextDep && g.contextDynamic || Ee.propDep) && (Xe = v), ze = Ee.append(s2, Xe), u.optional(function() {
              Ee.MISSING && s2.assert(t, "false", "missing vertex count"), Ee.DYNAMIC && s2.assert(Xe, ze + ">=0", "missing vertex count");
            })) : (ze = Xe.def(p, ".", or), u.optional(function() {
              s2.assert(Xe, ze + ">=0", "missing vertex count");
            })), ze;
          }
          var f = n();
          function E(Ee) {
            var ze = b[Ee];
            return ze ? ze.contextDep && g.contextDynamic || ze.propDep ? ze.append(s2, v) : ze.append(s2, t) : t.def(p, ".", Ee);
          }
          var L = E(ir), I = E(hn), P = m2();
          if (typeof P == "number") {
            if (P === 0)
              return;
          } else
            v("if(", P, "){"), v.exit("}");
          var k, q;
          K && (k = E(mn), q = s2.instancing);
          var me = f + ".type", Ce = b.elements && Ht(b.elements);
          function de() {
            function Ee() {
              v(q, ".drawElementsInstancedANGLE(", [
                L,
                P,
                me,
                I + "<<((" + me + "-" + Ni + ")>>1)",
                k
              ], ");");
            }
            function ze() {
              v(
                q,
                ".drawArraysInstancedANGLE(",
                [L, I, P, k],
                ");"
              );
            }
            f ? Ce ? Ee() : (v("if(", f, "){"), Ee(), v("}else{"), ze(), v("}")) : ze();
          }
          function ye() {
            function Ee() {
              v(y2 + ".drawElements(" + [
                L,
                P,
                me,
                I + "<<((" + me + "-" + Ni + ")>>1)"
              ] + ");");
            }
            function ze() {
              v(y2 + ".drawArrays(" + [L, I, P] + ");");
            }
            f ? Ce ? Ee() : (v("if(", f, "){"), Ee(), v("}else{"), ze(), v("}")) : ze();
          }
          K && (typeof k != "number" || k >= 0) ? typeof k == "string" ? (v("if(", k, ">0){"), de(), v("}else if(", k, "<0){"), ye(), v("}")) : de() : ye();
        }
        function De(s2, t, v, g, T) {
          var y2 = _e(), p = y2.proc("body", T);
          return u.optional(function() {
            y2.commandStr = t.commandStr, y2.command = y2.link(t.commandStr);
          }), K && (y2.instancing = p.def(
            y2.shared.extensions,
            ".angle_instanced_arrays"
          )), s2(y2, p, v, g), y2.compile().body;
        }
        function Ne(s2, t, v, g) {
          qe(s2, t), v.useVAO ? v.drawVAO ? t(s2.shared.vao, ".setVAO(", v.drawVAO.append(s2, t), ");") : t(s2.shared.vao, ".setVAO(", s2.shared.vao, ".targetVAO);") : (t(s2.shared.vao, ".setVAO(null);"), ht(s2, t, v, g.attributes, function() {
            return true;
          })), je(s2, t, v, g.uniforms, function() {
            return true;
          }), ve(s2, t, t, v);
        }
        function Ke(s2, t) {
          var v = s2.proc("draw", 1);
          qe(s2, v), nt(s2, v, t.context), at2(s2, v, t.framebuffer), ft(s2, v, t), dt(s2, v, t.state), Re(s2, v, t, false, true);
          var g = t.shader.progVar.append(s2, v);
          if (v(s2.shared.gl, ".useProgram(", g, ".program);"), t.shader.program)
            Ne(s2, v, t, t.shader.program);
          else {
            v(s2.shared.vao, ".setVAO(null);");
            var T = s2.global.def("{}"), y2 = v.def(g, ".id"), p = v.def(T, "[", y2, "]");
            v(
              s2.cond(p).then(p, ".call(this,a0);").else(
                p,
                "=",
                T,
                "[",
                y2,
                "]=",
                s2.link(function(b) {
                  return De(Ne, s2, t, b, 1);
                }),
                "(",
                g,
                ");",
                p,
                ".call(this,a0);"
              )
            );
          }
          Object.keys(t.state).length > 0 && v(s2.shared.current, ".dirty=true;");
        }
        function Nt(s2, t, v, g) {
          s2.batchId = "a1", qe(s2, t);
          function T() {
            return true;
          }
          ht(s2, t, v, g.attributes, T), je(s2, t, v, g.uniforms, T), ve(s2, t, t, v);
        }
        function fr(s2, t, v, g) {
          qe(s2, t);
          var T = v.contextDep, y2 = t.def(), p = "a0", b = "a1", n = t.def();
          s2.shared.props = n, s2.batchId = y2;
          var m2 = s2.scope(), f = s2.scope();
          t(
            m2.entry,
            "for(",
            y2,
            "=0;",
            y2,
            "<",
            b,
            ";++",
            y2,
            "){",
            n,
            "=",
            p,
            "[",
            y2,
            "];",
            f,
            "}",
            m2.exit
          );
          function E(me) {
            return me.contextDep && T || me.propDep;
          }
          function L(me) {
            return !E(me);
          }
          if (v.needsContext && nt(s2, f, v.context), v.needsFramebuffer && at2(s2, f, v.framebuffer), dt(s2, f, v.state, E), v.profile && E(v.profile) && Re(s2, f, v, false, true), g)
            v.useVAO ? v.drawVAO ? E(v.drawVAO) ? f(s2.shared.vao, ".setVAO(", v.drawVAO.append(s2, f), ");") : m2(s2.shared.vao, ".setVAO(", v.drawVAO.append(s2, m2), ");") : m2(s2.shared.vao, ".setVAO(", s2.shared.vao, ".targetVAO);") : (m2(s2.shared.vao, ".setVAO(null);"), ht(s2, m2, v, g.attributes, L), ht(s2, f, v, g.attributes, E)), je(s2, m2, v, g.uniforms, L), je(s2, f, v, g.uniforms, E), ve(s2, m2, f, v);
          else {
            var I = s2.global.def("{}"), P = v.shader.progVar.append(s2, f), k = f.def(P, ".id"), q = f.def(I, "[", k, "]");
            f(
              s2.shared.gl,
              ".useProgram(",
              P,
              ".program);",
              "if(!",
              q,
              "){",
              q,
              "=",
              I,
              "[",
              k,
              "]=",
              s2.link(function(me) {
                return De(
                  Nt,
                  s2,
                  v,
                  me,
                  2
                );
              }),
              "(",
              P,
              ");}",
              q,
              ".call(this,a0[",
              y2,
              "],",
              y2,
              ");"
            );
          }
        }
        function l(s2, t) {
          var v = s2.proc("batch", 2);
          s2.batchId = "0", qe(s2, v);
          var g = false, T = true;
          Object.keys(t.context).forEach(function(I) {
            g = g || t.context[I].propDep;
          }), g || (nt(s2, v, t.context), T = false);
          var y2 = t.framebuffer, p = false;
          y2 ? (y2.propDep ? g = p = true : y2.contextDep && g && (p = true), p || at2(s2, v, y2)) : at2(s2, v, null), t.state.viewport && t.state.viewport.propDep && (g = true);
          function b(I) {
            return I.contextDep && g || I.propDep;
          }
          ft(s2, v, t), dt(s2, v, t.state, function(I) {
            return !b(I);
          }), (!t.profile || !b(t.profile)) && Re(s2, v, t, false, "a1"), t.contextDep = g, t.needsContext = T, t.needsFramebuffer = p;
          var n = t.shader.progVar;
          if (n.contextDep && g || n.propDep)
            fr(
              s2,
              v,
              t,
              null
            );
          else {
            var m2 = n.append(s2, v);
            if (v(s2.shared.gl, ".useProgram(", m2, ".program);"), t.shader.program)
              fr(
                s2,
                v,
                t,
                t.shader.program
              );
            else {
              v(s2.shared.vao, ".setVAO(null);");
              var f = s2.global.def("{}"), E = v.def(m2, ".id"), L = v.def(f, "[", E, "]");
              v(
                s2.cond(L).then(L, ".call(this,a0,a1);").else(
                  L,
                  "=",
                  f,
                  "[",
                  E,
                  "]=",
                  s2.link(function(I) {
                    return De(fr, s2, t, I, 2);
                  }),
                  "(",
                  m2,
                  ");",
                  L,
                  ".call(this,a0,a1);"
                )
              );
            }
          }
          Object.keys(t.state).length > 0 && v(s2.shared.current, ".dirty=true;");
        }
        function G(s2, t) {
          var v = s2.proc("scope", 3);
          s2.batchId = "a2";
          var g = s2.shared, T = g.current;
          nt(s2, v, t.context), t.framebuffer && t.framebuffer.append(s2, v), po(Object.keys(t.state)).forEach(function(p) {
            var b = t.state[p], n = b.append(s2, v);
            Ye(n) ? n.forEach(function(m2, f) {
              v.set(s2.next[p], "[" + f + "]", m2);
            }) : v.set(g.next, "." + p, n);
          }), Re(s2, v, t, true, true), [ar, hn, or, mn, ir].forEach(
            function(p) {
              var b = t.draw[p];
              b && v.set(g.draw, "." + p, "" + b.append(s2, v));
            }
          ), Object.keys(t.uniforms).forEach(function(p) {
            var b = t.uniforms[p].append(s2, v);
            Array.isArray(b) && (b = "[" + b.join() + "]"), v.set(
              g.uniforms,
              "[" + r.id(p) + "]",
              b
            );
          }), Object.keys(t.attributes).forEach(function(p) {
            var b = t.attributes[p].append(s2, v), n = s2.scopeAttrib(p);
            Object.keys(new A()).forEach(function(m2) {
              v.set(n, "." + m2, b[m2]);
            });
          }), t.scopeVAO && v.set(g.vao, ".targetVAO", t.scopeVAO.append(s2, v));
          function y2(p) {
            var b = t.shader[p];
            b && v.set(g.shader, "." + p, b.append(s2, v));
          }
          y2(Ir), y2(Nr), Object.keys(t.state).length > 0 && (v(T, ".dirty=true;"), v.exit(T, ".dirty=true;")), v("a1(", s2.shared.context, ",a0,", s2.batchId, ");");
        }
        function R2(s2) {
          if (!(typeof s2 != "object" || Ye(s2))) {
            for (var t = Object.keys(s2), v = 0; v < t.length; ++v)
              if (Lt.isDynamic(s2[t[v]]))
                return true;
            return false;
          }
        }
        function ue(s2, t, v) {
          var g = t.static[v];
          if (!g || !R2(g))
            return;
          var T = s2.global, y2 = Object.keys(g), p = false, b = false, n = false, m2 = s2.global.def("{}");
          y2.forEach(function(E) {
            var L = g[E];
            if (Lt.isDynamic(L)) {
              typeof L == "function" && (L = g[E] = Lt.unbox(L));
              var I = xt(L, null);
              p = p || I.thisDep, n = n || I.propDep, b = b || I.contextDep;
            } else {
              switch (T(m2, ".", E, "="), typeof L) {
                case "number":
                  T(L);
                  break;
                case "string":
                  T('"', L, '"');
                  break;
                case "object":
                  Array.isArray(L) && T("[", L.join(), "]");
                  break;
                default:
                  T(s2.link(L));
                  break;
              }
              T(";");
            }
          });
          function f(E, L) {
            y2.forEach(function(I) {
              var P = g[I];
              if (Lt.isDynamic(P)) {
                var k = E.invoke(L, P);
                L(m2, ".", I, "=", k, ";");
              }
            });
          }
          t.dynamic[v] = new Lt.DynamicVariable(ln, {
            thisDep: p,
            contextDep: b,
            propDep: n,
            ref: m2,
            append: f
          }), delete t.static[v];
        }
        function Ge(s2, t, v, g, T) {
          var y2 = _e();
          y2.stats = y2.link(T), Object.keys(t.static).forEach(function(b) {
            ue(y2, t, b);
          }), du.forEach(function(b) {
            ue(y2, s2, b);
          });
          var p = tt(s2, t, v, g, y2);
          return Ke(y2, p), G(y2, p), l(y2, p), w(y2.compile(), {
            destroy: function() {
              p.shader.program.destroy();
            }
          });
        }
        return {
          next: fe,
          current: z,
          procs: function() {
            var s2 = _e(), t = s2.proc("poll"), v = s2.proc("refresh"), g = s2.block();
            t(g), v(g);
            var T = s2.shared, y2 = T.gl, p = T.next, b = T.current;
            g(b, ".dirty=false;"), at2(s2, t), at2(s2, v, null, true);
            var n;
            K && (n = s2.link(K)), d2.oes_vertex_array_object && v(s2.link(d2.oes_vertex_array_object), ".bindVertexArrayOES(null);");
            for (var m2 = 0; m2 < F.maxAttributes; ++m2) {
              var f = v.def(T.attributes, "[", m2, "]"), E = s2.cond(f, ".buffer");
              E.then(
                y2,
                ".enableVertexAttribArray(",
                m2,
                ");",
                y2,
                ".bindBuffer(",
                wr,
                ",",
                f,
                ".buffer.buffer);",
                y2,
                ".vertexAttribPointer(",
                m2,
                ",",
                f,
                ".size,",
                f,
                ".type,",
                f,
                ".normalized,",
                f,
                ".stride,",
                f,
                ".offset);"
              ).else(
                y2,
                ".disableVertexAttribArray(",
                m2,
                ");",
                y2,
                ".vertexAttrib4f(",
                m2,
                ",",
                f,
                ".x,",
                f,
                ".y,",
                f,
                ".z,",
                f,
                ".w);",
                f,
                ".buffer=null;"
              ), v(E), K && v(
                n,
                ".vertexAttribDivisorANGLE(",
                m2,
                ",",
                f,
                ".divisor);"
              );
            }
            return v(
              s2.shared.vao,
              ".currentVAO=null;",
              s2.shared.vao,
              ".setVAO(",
              s2.shared.vao,
              ".targetVAO);"
            ), Object.keys(ne).forEach(function(L) {
              var I = ne[L], P = g.def(p, ".", L), k = s2.block();
              k(
                "if(",
                P,
                "){",
                y2,
                ".enable(",
                I,
                ")}else{",
                y2,
                ".disable(",
                I,
                ")}",
                b,
                ".",
                L,
                "=",
                P,
                ";"
              ), v(k), t(
                "if(",
                P,
                "!==",
                b,
                ".",
                L,
                "){",
                k,
                "}"
              );
            }), Object.keys(j).forEach(function(L) {
              var I = j[L], P = z[L], k, q, me = s2.block();
              if (me(y2, ".", I, "("), Ye(P)) {
                var Ce = P.length;
                k = s2.global.def(p, ".", L), q = s2.global.def(b, ".", L), me(
                  gt(Ce, function(de) {
                    return k + "[" + de + "]";
                  }),
                  ");",
                  gt(Ce, function(de) {
                    return q + "[" + de + "]=" + k + "[" + de + "];";
                  }).join("")
                ), t(
                  "if(",
                  gt(Ce, function(de) {
                    return k + "[" + de + "]!==" + q + "[" + de + "]";
                  }).join("||"),
                  "){",
                  me,
                  "}"
                );
              } else
                k = g.def(p, ".", L), q = g.def(b, ".", L), me(
                  k,
                  ");",
                  b,
                  ".",
                  L,
                  "=",
                  k,
                  ";"
                ), t(
                  "if(",
                  k,
                  "!==",
                  q,
                  "){",
                  me,
                  "}"
                );
              v(me);
            }), s2.compile();
          }(),
          compile: Ge
        };
      }
      function Gu() {
        return {
          vaoCount: 0,
          bufferCount: 0,
          elementsCount: 0,
          framebufferCount: 0,
          shaderCount: 0,
          textureCount: 0,
          cubeCount: 0,
          renderbufferCount: 0,
          maxTextureUnits: 0
        };
      }
      var Du = 34918, Mu = 34919, yo = 35007, Bu = function(e, r) {
        if (!r.ext_disjoint_timer_query)
          return null;
        var d2 = [];
        function F() {
          return d2.pop() || r.ext_disjoint_timer_query.createQueryEXT();
        }
        function N(K) {
          d2.push(K);
        }
        var O = [];
        function M(K) {
          var se = F();
          r.ext_disjoint_timer_query.beginQueryEXT(yo, se), O.push(se), H(O.length - 1, O.length, K);
        }
        function X() {
          r.ext_disjoint_timer_query.endQueryEXT(yo);
        }
        function W() {
          this.startQueryIndex = -1, this.endQueryIndex = -1, this.sum = 0, this.stats = null;
        }
        var Q = [];
        function Y() {
          return Q.pop() || new W();
        }
        function te(K) {
          Q.push(K);
        }
        var ie = [];
        function H(K, se, z) {
          var fe = Y();
          fe.startQueryIndex = K, fe.endQueryIndex = se, fe.sum = 0, fe.stats = z, ie.push(fe);
        }
        var re2 = [], A = [];
        function B() {
          var K, se, z = O.length;
          if (z !== 0) {
            A.length = Math.max(A.length, z + 1), re2.length = Math.max(re2.length, z + 1), re2[0] = 0, A[0] = 0;
            var fe = 0;
            for (K = 0, se = 0; se < O.length; ++se) {
              var V = O[se];
              r.ext_disjoint_timer_query.getQueryObjectEXT(V, Mu) ? (fe += r.ext_disjoint_timer_query.getQueryObjectEXT(V, Du), N(V)) : O[K++] = V, re2[se + 1] = fe, A[se + 1] = K;
            }
            for (O.length = K, K = 0, se = 0; se < ie.length; ++se) {
              var ne = ie[se], j = ne.startQueryIndex, ae = ne.endQueryIndex;
              ne.sum += re2[ae] - re2[j];
              var pe = A[j], ge = A[ae];
              ge === pe ? (ne.stats.gpuTime += ne.sum / 1e6, te(ne)) : (ne.startQueryIndex = pe, ne.endQueryIndex = ge, ie[K++] = ne);
            }
            ie.length = K;
          }
        }
        return {
          beginQuery: M,
          endQuery: X,
          pushScopeStats: H,
          update: B,
          getNumPendingQueries: function() {
            return O.length;
          },
          clear: function() {
            d2.push.apply(d2, O);
            for (var K = 0; K < d2.length; K++)
              r.ext_disjoint_timer_query.deleteQueryEXT(d2[K]);
            O.length = 0, d2.length = 0;
          },
          restore: function() {
            O.length = 0, d2.length = 0;
          }
        };
      }, ku = 16384, Iu = 256, Nu = 1024, Pu = 34962, _o = "webglcontextlost", bo = "webglcontextrestored", go = 1, Uu = 2, $u = 3;
      function xo(e, r) {
        for (var d2 = 0; d2 < e.length; ++d2)
          if (e[d2] === r)
            return d2;
        return -1;
      }
      function zu(e) {
        var r = No(e);
        if (!r)
          return null;
        var d2 = r.gl, F = d2.getContextAttributes(), N = d2.isContextLost(), O = Po(d2, r);
        if (!O)
          return null;
        var M = Do(), X = Gu(), W = O.extensions, Q = Bu(d2, W), Y = Ra(), te = d2.drawingBufferWidth, ie = d2.drawingBufferHeight, H = {
          tick: 0,
          time: 0,
          viewportWidth: te,
          viewportHeight: ie,
          framebufferWidth: te,
          framebufferHeight: ie,
          drawingBufferWidth: te,
          drawingBufferHeight: ie,
          pixelRatio: r.pixelRatio
        }, re2 = {}, A = {
          elements: null,
          primitive: 4,
          // GL_TRIANGLES
          count: -1,
          offset: 0,
          instances: -1
        }, B = Ts(d2, W), K = zs(
          d2,
          X,
          r,
          z
        ), se = tu(
          d2,
          W,
          B,
          X,
          K
        );
        function z(ve) {
          return se.destroyBuffer(ve);
        }
        var fe = ef(d2, W, K, X), V = iu(d2, M, X, r), ne = Gf(
          d2,
          W,
          B,
          function() {
            pe.procs.poll();
          },
          H,
          X,
          r
        ), j = Df(d2, W, B, X, r), ae = Jf(
          d2,
          W,
          B,
          ne,
          j,
          X
        ), pe = Fu(
          d2,
          M,
          W,
          B,
          K,
          fe,
          ne,
          ae,
          re2,
          se,
          V,
          A,
          H,
          Q,
          r
        ), ge = fu(
          d2,
          ae,
          pe.procs.poll,
          H,
          F,
          W,
          B
        ), oe = pe.next, Z = d2.canvas, U = [], _e = [], Le = [], le = [r.onDestroy], Fe = null;
        function xe() {
          if (U.length === 0) {
            Q && Q.update(), Fe = null;
            return;
          }
          Fe = Ln.next(xe), dt();
          for (var ve = U.length - 1; ve >= 0; --ve) {
            var De = U[ve];
            De && De(H, null, 0);
          }
          d2.flush(), Q && Q.update();
        }
        function Oe() {
          !Fe && U.length > 0 && (Fe = Ln.next(xe));
        }
        function $e() {
          Fe && (Ln.cancel(xe), Fe = null);
        }
        function et(ve) {
          ve.preventDefault(), N = true, $e(), _e.forEach(function(De) {
            De();
          });
        }
        function ot(ve) {
          d2.getError(), N = false, O.restore(), V.restore(), K.restore(), ne.restore(), j.restore(), ae.restore(), se.restore(), Q && Q.restore(), pe.procs.refresh(), Oe(), Le.forEach(function(De) {
            De();
          });
        }
        Z && (Z.addEventListener(_o, et, false), Z.addEventListener(bo, ot, false));
        function Me() {
          U.length = 0, $e(), Z && (Z.removeEventListener(_o, et), Z.removeEventListener(bo, ot)), V.clear(), ae.clear(), j.clear(), ne.clear(), fe.clear(), K.clear(), se.clear(), Q && Q.clear(), le.forEach(function(ve) {
            ve();
          });
        }
        function rt(ve) {
          u(!!ve, "invalid args to regl({...})"), u.type(ve, "object", "invalid args to regl({...})");
          function De(T) {
            var y2 = w({}, T);
            delete y2.uniforms, delete y2.attributes, delete y2.context, delete y2.vao, "stencil" in y2 && y2.stencil.op && (y2.stencil.opBack = y2.stencil.opFront = y2.stencil.op, delete y2.stencil.op);
            function p(b) {
              if (b in y2) {
                var n = y2[b];
                delete y2[b], Object.keys(n).forEach(function(m2) {
                  y2[b + "." + m2] = n[m2];
                });
              }
            }
            return p("blend"), p("depth"), p("cull"), p("stencil"), p("polygonOffset"), p("scissor"), p("sample"), "vao" in T && (y2.vao = T.vao), y2;
          }
          function Ne(T, y2) {
            var p = {}, b = {};
            return Object.keys(T).forEach(function(n) {
              var m2 = T[n];
              if (Lt.isDynamic(m2)) {
                b[n] = Lt.unbox(m2, n);
                return;
              } else if (y2 && Array.isArray(m2)) {
                for (var f = 0; f < m2.length; ++f)
                  if (Lt.isDynamic(m2[f])) {
                    b[n] = Lt.unbox(m2, n);
                    return;
                  }
              }
              p[n] = m2;
            }), {
              dynamic: b,
              static: p
            };
          }
          var Ke = Ne(ve.context || {}, true), Nt = Ne(ve.uniforms || {}, true), fr = Ne(ve.attributes || {}, false), l = Ne(De(ve), false), G = {
            gpuTime: 0,
            cpuTime: 0,
            count: 0
          }, R2 = pe.compile(l, fr, Nt, Ke, G), ue = R2.draw, Ge = R2.batch, s2 = R2.scope, t = [];
          function v(T) {
            for (; t.length < T; )
              t.push(null);
            return t;
          }
          function g(T, y2) {
            var p;
            if (N && u.raise("context lost"), typeof T == "function")
              return s2.call(this, null, T, 0);
            if (typeof y2 == "function")
              if (typeof T == "number")
                for (p = 0; p < T; ++p)
                  s2.call(this, null, y2, p);
              else if (Array.isArray(T))
                for (p = 0; p < T.length; ++p)
                  s2.call(this, T[p], y2, p);
              else
                return s2.call(this, T, y2, 0);
            else if (typeof T == "number") {
              if (T > 0)
                return Ge.call(this, v(T | 0), T | 0);
            } else if (Array.isArray(T)) {
              if (T.length)
                return Ge.call(this, T, T.length);
            } else
              return ue.call(this, T);
          }
          return w(g, {
            stats: G,
            destroy: function() {
              R2.destroy();
            }
          });
        }
        var Ve = ae.setFBO = rt({
          framebuffer: Lt.define.call(null, go, "framebuffer")
        });
        function tt(ve, De) {
          var Ne = 0;
          pe.procs.poll();
          var Ke = De.color;
          Ke && (d2.clearColor(+Ke[0] || 0, +Ke[1] || 0, +Ke[2] || 0, +Ke[3] || 0), Ne |= ku), "depth" in De && (d2.clearDepth(+De.depth), Ne |= Iu), "stencil" in De && (d2.clearStencil(De.stencil | 0), Ne |= Nu), u(!!Ne, "called regl.clear with no buffer specified"), d2.clear(Ne);
        }
        function nt(ve) {
          if (u(
            typeof ve == "object" && ve,
            "regl.clear() takes an object as input"
          ), "framebuffer" in ve)
            if (ve.framebuffer && ve.framebuffer_reglType === "framebufferCube")
              for (var De = 0; De < 6; ++De)
                Ve(w({
                  framebuffer: ve.framebuffer.faces[De]
                }, ve), tt);
            else
              Ve(ve, tt);
          else
            tt(null, ve);
        }
        function at2(ve) {
          u.type(ve, "function", "regl.frame() callback must be a function"), U.push(ve);
          function De() {
            var Ne = xo(U, ve);
            u(Ne >= 0, "cannot cancel a frame twice");
            function Ke() {
              var Nt = xo(U, Ke);
              U[Nt] = U[U.length - 1], U.length -= 1, U.length <= 0 && $e();
            }
            U[Ne] = Ke;
          }
          return Oe(), {
            cancel: De
          };
        }
        function ft() {
          var ve = oe.viewport, De = oe.scissor_box;
          ve[0] = ve[1] = De[0] = De[1] = 0, H.viewportWidth = H.framebufferWidth = H.drawingBufferWidth = ve[2] = De[2] = d2.drawingBufferWidth, H.viewportHeight = H.framebufferHeight = H.drawingBufferHeight = ve[3] = De[3] = d2.drawingBufferHeight;
        }
        function dt() {
          H.tick += 1, H.time = Re(), ft(), pe.procs.poll();
        }
        function qe() {
          ne.refresh(), ft(), pe.procs.refresh(), Q && Q.update();
        }
        function Re() {
          return (Ra() - Y) / 1e3;
        }
        qe();
        function ht(ve, De) {
          u.type(De, "function", "listener callback must be a function");
          var Ne;
          switch (ve) {
            case "frame":
              return at2(De);
            case "lost":
              Ne = _e;
              break;
            case "restore":
              Ne = Le;
              break;
            case "destroy":
              Ne = le;
              break;
            default:
              u.raise("invalid event, must be one of frame,lost,restore,destroy");
          }
          return Ne.push(De), {
            cancel: function() {
              for (var Ke = 0; Ke < Ne.length; ++Ke)
                if (Ne[Ke] === De) {
                  Ne[Ke] = Ne[Ne.length - 1], Ne.pop();
                  return;
                }
            }
          };
        }
        var je = w(rt, {
          // Clear current FBO
          clear: nt,
          // Short cuts for dynamic variables
          prop: Lt.define.bind(null, go),
          context: Lt.define.bind(null, Uu),
          this: Lt.define.bind(null, $u),
          // executes an empty draw command
          draw: rt({}),
          // Resources
          buffer: function(ve) {
            return K.create(ve, Pu, false, false);
          },
          elements: function(ve) {
            return fe.create(ve, false);
          },
          texture: ne.create2D,
          cube: ne.createCube,
          renderbuffer: j.create,
          framebuffer: ae.create,
          framebufferCube: ae.createCube,
          vao: se.createVAO,
          // Expose context attributes
          attributes: F,
          // Frame rendering
          frame: at2,
          on: ht,
          // System limits
          limits: B,
          hasExtension: function(ve) {
            return B.extensions.indexOf(ve.toLowerCase()) >= 0;
          },
          // Read pixels
          read: ge,
          // Destroy regl and all associated resources
          destroy: Me,
          // Direct GL state manipulation
          _gl: d2,
          _refresh: qe,
          poll: function() {
            dt(), Q && Q.update();
          },
          // Current time
          now: Re,
          // regl Statistics Information
          stats: X
        });
        return r.onDone(null, je), je;
      }
      return zu;
    });
  })(regl$1);
  var reglExports = regl$1.exports;
  const regl = /* @__PURE__ */ getDefaultExportFromCjs(reglExports), Mouse = mouseListen();
  class HydraRenderer {
    constructor({
      pb: c = null,
      width: h2 = 1280,
      height: w = 720,
      numSources: D = 4,
      numOutputs: J = 4,
      makeGlobal: Se = true,
      autoLoop: he = true,
      detectAudio: Ie = true,
      enableStreamCapture: be = true,
      canvas: vt,
      precision: He,
      extendTransforms: We = {}
      // add your own functions on init
    } = {}) {
      if (ArrayUtils.init(), this.pb = c, this.width = h2, this.height = w, this.renderAll = false, this.detectAudio = Ie, this._initCanvas(vt), this.synth = {
        time: 0,
        bpm: 30,
        width: this.width,
        height: this.height,
        fps: void 0,
        stats: {
          fps: 0
        },
        speed: 1,
        mouse: Mouse,
        render: this._render.bind(this),
        setResolution: this.setResolution.bind(this),
        update: (st) => {
        },
        // user defined update function
        hush: this.hush.bind(this),
        tick: this.tick.bind(this)
      }, Se && (window.loadScript = this.loadScript), this.timeSinceLastUpdate = 0, this._time = 0, He && ["lowp", "mediump", "highp"].includes(He.toLowerCase()))
        this.precision = He.toLowerCase();
      else {
        let st = (/iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && !window.MSStream;
        this.precision = st ? "highp" : "mediump";
      }
      if (this.extendTransforms = We, this.saveFrame = false, this.captureStream = null, this.generator = void 0, this._initRegl(), this._initOutputs(J), this._initSources(D), this._generateGlslTransforms(), this.synth.screencap = () => {
        this.saveFrame = true;
      }, be)
        try {
          this.captureStream = this.canvas.captureStream(25), this.synth.vidRecorder = new VideoRecorder(this.captureStream);
        } catch (st) {
          console.warn(`[hydra-synth warning]
new MediaSource() is not currently supported on iOS.`), console.error(st);
        }
      Ie && this._initAudio(), he && loop(this.tick.bind(this)).start(), this.sandbox = new EvalSandbox(this.synth, Se, ["speed", "update", "bpm", "fps"]);
    }
    eval(c) {
      this.sandbox.eval(c);
    }
    getScreenImage(c) {
      this.imageCallback = c, this.saveFrame = true;
    }
    hush() {
      this.s.forEach((c) => {
        c.clear();
      }), this.o.forEach((c) => {
        this.synth.solid(0, 0, 0, 0).out(c);
      }), this.synth.render(this.o[0]), this.sandbox.set("update", (c) => {
      });
    }
    loadScript(c = "") {
      return new Promise((w, D) => {
        var J = document.createElement("script");
        J.onload = function() {
          console.log(`loaded script ${c}`), w();
        }, J.onerror = (Se) => {
          console.log(`error loading script ${c}`, "log-error"), w();
        }, J.src = c, document.head.appendChild(J);
      });
    }
    setResolution(c, h2) {
      this.canvas.width = c, this.canvas.height = h2, this.width = c, this.height = h2, this.sandbox.set("width", c), this.sandbox.set("height", h2), console.log(this.width), this.o.forEach((w) => {
        w.resize(c, h2);
      }), this.s.forEach((w) => {
        w.resize(c, h2);
      }), this.regl._refresh(), console.log(this.canvas.width);
    }
    canvasToImage(c) {
      const h2 = document.createElement("a");
      h2.style.display = "none";
      let w = /* @__PURE__ */ new Date();
      h2.download = `hydra-${w.getFullYear()}-${w.getMonth() + 1}-${w.getDate()}-${w.getHours()}.${w.getMinutes()}.${w.getSeconds()}.png`, document.body.appendChild(h2);
      var D = this;
      this.canvas.toBlob((J) => {
        D.imageCallback ? (D.imageCallback(J), delete D.imageCallback) : (h2.href = URL.createObjectURL(J), console.log(h2.href), h2.click());
      }, "image/png"), setTimeout(() => {
        document.body.removeChild(h2), window.URL.revokeObjectURL(h2.href);
      }, 300);
    }
    _initAudio() {
      this.synth.a = new Audio({
        numBins: 4,
        parentEl: this.canvas.parentNode
        // changeListener: ({audio}) => {
        //   that.a = audio.bins.map((_, index) =>
        //     (scale = 1, offset = 0) => () => (audio.fft[index] * scale + offset)
        //   )
        //
        //   if (that.makeGlobal) {
        //     that.a.forEach((a, index) => {
        //       const aname = `a${index}`
        //       window[aname] = a
        //     })
        //   }
        // }
      });
    }
    // create main output canvas and add to screen
    _initCanvas(c) {
      c ? (this.canvas = c, this.width = c.width, this.height = c.height) : (this.canvas = document.createElement("canvas"), this.canvas.width = this.width, this.canvas.height = this.height, this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.imageRendering = "pixelated", document.body.appendChild(this.canvas));
    }
    _initRegl() {
      this.regl = regl({
        //  profile: true,
        canvas: this.canvas,
        pixelRatio: 1
        //,
        // extensions: [
        //   'oes_texture_half_float',
        //   'oes_texture_half_float_linear'
        // ],
        // optionalExtensions: [
        //   'oes_texture_float',
        //   'oes_texture_float_linear'
        //]
      }), this.regl.clear({
        color: [0, 0, 0, 1]
      }), this.renderAll = this.regl({
        frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform sampler2D tex0;
      uniform sampler2D tex1;
      uniform sampler2D tex2;
      uniform sampler2D tex3;

      void main () {
        vec2 st = vec2(1.0 - uv.x, uv.y);
        st*= vec2(2);
        vec2 q = floor(st).xy*(vec2(2.0, 1.0));
        int quad = int(q.x) + int(q.y);
        st.x += step(1., mod(st.y,2.0));
        st.y += step(1., mod(st.x,2.0));
        st = fract(st);
        if(quad==0){
          gl_FragColor = texture2D(tex0, st);
        } else if(quad==1){
          gl_FragColor = texture2D(tex1, st);
        } else if (quad==2){
          gl_FragColor = texture2D(tex2, st);
        } else {
          gl_FragColor = texture2D(tex3, st);
        }

      }
      `,
        vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
        attributes: {
          position: [
            [-2, 0],
            [0, -2],
            [2, 2]
          ]
        },
        uniforms: {
          tex0: this.regl.prop("tex0"),
          tex1: this.regl.prop("tex1"),
          tex2: this.regl.prop("tex2"),
          tex3: this.regl.prop("tex3")
        },
        count: 3,
        depth: { enable: false }
      }), this.renderFbo = this.regl({
        frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform vec2 resolution;
      uniform sampler2D tex0;

      void main () {
        gl_FragColor = texture2D(tex0, vec2(1.0 - uv.x, uv.y));
      }
      `,
        vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
        attributes: {
          position: [
            [-2, 0],
            [0, -2],
            [2, 2]
          ]
        },
        uniforms: {
          tex0: this.regl.prop("tex0"),
          resolution: this.regl.prop("resolution")
        },
        count: 3,
        depth: { enable: false }
      });
    }
    _initOutputs(c) {
      const h2 = this;
      this.o = Array(c).fill().map((w, D) => {
        var J = new Output({
          regl: this.regl,
          width: this.width,
          height: this.height,
          precision: this.precision,
          label: `o${D}`
        });
        return J.id = D, h2.synth["o" + D] = J, J;
      }), this.output = this.o[0];
    }
    _initSources(c) {
      this.s = [];
      for (var h2 = 0; h2 < c; h2++)
        this.createSource(h2);
    }
    createSource(c) {
      let h2 = new HydraSource({ regl: this.regl, pb: this.pb, width: this.width, height: this.height, label: `s${c}` });
      return this.synth["s" + this.s.length] = h2, this.s.push(h2), h2;
    }
    _generateGlslTransforms() {
      var c = this;
      this.generator = new GeneratorFactory({
        defaultOutput: this.o[0],
        defaultUniforms: this.o[0].uniforms,
        extendTransforms: this.extendTransforms,
        changeListener: ({ type: h2, method: w, synth: D }) => {
          h2 === "add" && (c.synth[w] = D.generators[w], c.sandbox && c.sandbox.add(w));
        }
      }), this.synth.setFunction = this.generator.setFunction.bind(this.generator);
    }
    _render(c) {
      c ? (this.output = c, this.isRenderingAll = false) : this.isRenderingAll = true;
    }
    // dt in ms
    tick(c, h2) {
      if (this.sandbox.tick(), this.detectAudio === true && this.synth.a.tick(), this.sandbox.set("time", this.synth.time += c * 1e-3 * this.synth.speed), this.timeSinceLastUpdate += c, !this.synth.fps || this.timeSinceLastUpdate >= 1e3 / this.synth.fps) {
        if (this.synth.stats.fps = Math.ceil(1e3 / this.timeSinceLastUpdate), this.synth.update)
          try {
            this.synth.update(this.timeSinceLastUpdate);
          } catch (w) {
            console.log(w);
          }
        for (let w = 0; w < this.s.length; w++)
          this.s[w].tick(this.synth.time);
        for (let w = 0; w < this.o.length; w++)
          this.o[w].tick({
            time: this.synth.time,
            mouse: this.synth.mouse,
            bpm: this.synth.bpm,
            resolution: [this.canvas.width, this.canvas.height]
          });
        this.isRenderingAll ? this.renderAll({
          tex0: this.o[0].getCurrent(),
          tex1: this.o[1].getCurrent(),
          tex2: this.o[2].getCurrent(),
          tex3: this.o[3].getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        }) : this.renderFbo({
          tex0: this.output.getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        }), this.timeSinceLastUpdate = 0;
      }
      this.saveFrame === true && (this.canvasToImage(), this.saveFrame = false);
    }
  }
  module.exports = HydraRenderer;
});
const HydraSynth = Vu();
class P5 extends p5 {
  constructor({
    width = window.innerWidth,
    height = window.innerHeight,
    mode = "P2D"
  } = {}) {
    super((p) => {
      p.setup = () => {
        p.createCanvas(width, height, p[mode]);
      };
      p.draw = () => {
      };
    }, "hydra-ui");
    this.width = width;
    this.height = height;
    this.mode = mode;
    this.canvas.style.position = "absolute";
    this.canvas.style.top = "0px";
    this.canvas.style.left = "0px";
    this.canvas.style.zIndex = -1;
  }
  show() {
    this.canvas.style.visibility = "visible";
  }
  hide() {
    this.canvas.style.visibility = "hidden";
  }
  // p5 clear function not covering canvas
  clear() {
    this.drawingContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
}
var lib$2 = { exports: {} };
var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
var parseuri$2 = function parseuri2(str) {
  var src2 = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  var m2 = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m2[i2] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src2;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
};
function pathNames(obj, path2) {
  var regx = /\/{2,9}/g, names = path2.replace(regx, "/").split("/");
  if (path2.substr(0, 1) == "/" || path2.length === 0) {
    names.splice(0, 1);
  }
  if (path2.substr(path2.length - 1, 1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  var data2 = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data2[$1] = $2;
    }
  });
  return data2;
}
var browser$6 = { exports: {} };
var debug$9 = { exports: {} };
var s$2 = 1e3;
var m$2 = s$2 * 60;
var h$2 = m$2 * 60;
var d$2 = h$2 * 24;
var y$2 = d$2 * 365.25;
var ms$3 = function(val, options2) {
  options2 = options2 || {};
  var type = typeof val;
  if (type === "string" && val.length > 0) {
    return parse$2(val);
  } else if (type === "number" && isNaN(val) === false) {
    return options2.long ? fmtLong$2(val) : fmtShort$2(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$2(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y$2;
    case "days":
    case "day":
    case "d":
      return n * d$2;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h$2;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m$2;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s$2;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort$2(ms2) {
  if (ms2 >= d$2) {
    return Math.round(ms2 / d$2) + "d";
  }
  if (ms2 >= h$2) {
    return Math.round(ms2 / h$2) + "h";
  }
  if (ms2 >= m$2) {
    return Math.round(ms2 / m$2) + "m";
  }
  if (ms2 >= s$2) {
    return Math.round(ms2 / s$2) + "s";
  }
  return ms2 + "ms";
}
function fmtLong$2(ms2) {
  return plural$2(ms2, d$2, "day") || plural$2(ms2, h$2, "hour") || plural$2(ms2, m$2, "minute") || plural$2(ms2, s$2, "second") || ms2 + " ms";
}
function plural$2(ms2, n, name) {
  if (ms2 < n) {
    return;
  }
  if (ms2 < n * 1.5) {
    return Math.floor(ms2 / n) + " " + name;
  }
  return Math.ceil(ms2 / n) + " " + name + "s";
}
(function(module2, exports2) {
  exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = ms$3;
  exports2.instances = [];
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  function selectColor(namespace) {
    var hash = 0, i2;
    for (i2 in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return exports2.colors[Math.abs(hash) % exports2.colors.length];
  }
  function createDebug(namespace) {
    var prevTime;
    function debug2() {
      if (!debug2.enabled)
        return;
      var self2 = debug2;
      var curr = +/* @__PURE__ */ new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      args[0] = exports2.coerce(args[0]);
      if ("string" !== typeof args[0]) {
        args.unshift("%O");
      }
      var index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
        if (match === "%%")
          return match;
        index2++;
        var formatter = exports2.formatters[format2];
        if ("function" === typeof formatter) {
          var val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      exports2.formatArgs.call(self2, args);
      var logFn = debug2.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.enabled = exports2.enabled(namespace);
    debug2.useColors = exports2.useColors();
    debug2.color = selectColor(namespace);
    debug2.destroy = destroy2;
    if ("function" === typeof exports2.init) {
      exports2.init(debug2);
    }
    exports2.instances.push(debug2);
    return debug2;
  }
  function destroy2() {
    var index2 = exports2.instances.indexOf(this);
    if (index2 !== -1) {
      exports2.instances.splice(index2, 1);
      return true;
    } else {
      return false;
    }
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var i2;
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len2 = split.length;
    for (i2 = 0; i2 < len2; i2++) {
      if (!split[i2])
        continue;
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
    for (i2 = 0; i2 < exports2.instances.length; i2++) {
      var instance2 = exports2.instances[i2];
      instance2.enabled = exports2.enabled(instance2.namespace);
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    var i2, len2;
    for (i2 = 0, len2 = exports2.skips.length; i2 < len2; i2++) {
      if (exports2.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len2 = exports2.names.length; i2 < len2; i2++) {
      if (exports2.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
})(debug$9, debug$9.exports);
var debugExports$2 = debug$9.exports;
(function(module2, exports2) {
  exports2 = module2.exports = debugExports$2;
  exports2.log = log3;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index2 = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if ("%%" === match)
        return;
      index2++;
      if ("%c" === match) {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log3() {
    return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = {}.DEBUG;
    }
    return r;
  }
  exports2.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
})(browser$6, browser$6.exports);
var browserExports$4 = browser$6.exports;
var parseuri$1 = parseuri$2;
var debug$8 = browserExports$4("socket.io-client:url");
var url_1 = url;
function url(uri, loc) {
  var obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if ("string" === typeof uri) {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug$8("protocol-less url %s", uri);
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    debug$8("parse %s", uri);
    obj = parseuri$1(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  var ipv6 = obj.host.indexOf(":") !== -1;
  var host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
var socket_ioParser = {};
var browser$5 = { exports: {} };
var debug$7 = { exports: {} };
var s$1 = 1e3;
var m$1 = s$1 * 60;
var h$1 = m$1 * 60;
var d$1 = h$1 * 24;
var y$1 = d$1 * 365.25;
var ms$2 = function(val, options2) {
  options2 = options2 || {};
  var type = typeof val;
  if (type === "string" && val.length > 0) {
    return parse$1(val);
  } else if (type === "number" && isNaN(val) === false) {
    return options2.long ? fmtLong$1(val) : fmtShort$1(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$1(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y$1;
    case "days":
    case "day":
    case "d":
      return n * d$1;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h$1;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m$1;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s$1;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort$1(ms2) {
  if (ms2 >= d$1) {
    return Math.round(ms2 / d$1) + "d";
  }
  if (ms2 >= h$1) {
    return Math.round(ms2 / h$1) + "h";
  }
  if (ms2 >= m$1) {
    return Math.round(ms2 / m$1) + "m";
  }
  if (ms2 >= s$1) {
    return Math.round(ms2 / s$1) + "s";
  }
  return ms2 + "ms";
}
function fmtLong$1(ms2) {
  return plural$1(ms2, d$1, "day") || plural$1(ms2, h$1, "hour") || plural$1(ms2, m$1, "minute") || plural$1(ms2, s$1, "second") || ms2 + " ms";
}
function plural$1(ms2, n, name) {
  if (ms2 < n) {
    return;
  }
  if (ms2 < n * 1.5) {
    return Math.floor(ms2 / n) + " " + name;
  }
  return Math.ceil(ms2 / n) + " " + name + "s";
}
(function(module2, exports2) {
  exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = ms$2;
  exports2.instances = [];
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  function selectColor(namespace) {
    var hash = 0, i2;
    for (i2 in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return exports2.colors[Math.abs(hash) % exports2.colors.length];
  }
  function createDebug(namespace) {
    var prevTime;
    function debug2() {
      if (!debug2.enabled)
        return;
      var self2 = debug2;
      var curr = +/* @__PURE__ */ new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      args[0] = exports2.coerce(args[0]);
      if ("string" !== typeof args[0]) {
        args.unshift("%O");
      }
      var index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
        if (match === "%%")
          return match;
        index2++;
        var formatter = exports2.formatters[format2];
        if ("function" === typeof formatter) {
          var val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      exports2.formatArgs.call(self2, args);
      var logFn = debug2.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.enabled = exports2.enabled(namespace);
    debug2.useColors = exports2.useColors();
    debug2.color = selectColor(namespace);
    debug2.destroy = destroy2;
    if ("function" === typeof exports2.init) {
      exports2.init(debug2);
    }
    exports2.instances.push(debug2);
    return debug2;
  }
  function destroy2() {
    var index2 = exports2.instances.indexOf(this);
    if (index2 !== -1) {
      exports2.instances.splice(index2, 1);
      return true;
    } else {
      return false;
    }
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var i2;
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len2 = split.length;
    for (i2 = 0; i2 < len2; i2++) {
      if (!split[i2])
        continue;
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
    for (i2 = 0; i2 < exports2.instances.length; i2++) {
      var instance2 = exports2.instances[i2];
      instance2.enabled = exports2.enabled(instance2.namespace);
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    var i2, len2;
    for (i2 = 0, len2 = exports2.skips.length; i2 < len2; i2++) {
      if (exports2.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len2 = exports2.names.length; i2 < len2; i2++) {
      if (exports2.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
})(debug$7, debug$7.exports);
var debugExports$1 = debug$7.exports;
(function(module2, exports2) {
  exports2 = module2.exports = debugExports$1;
  exports2.log = log3;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index2 = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if ("%%" === match)
        return;
      index2++;
      if ("%c" === match) {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log3() {
    return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = {}.DEBUG;
    }
    return r;
  }
  exports2.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
})(browser$5, browser$5.exports);
var browserExports$3 = browser$5.exports;
var binary = {};
var toString$3 = {}.toString;
var isarray = Array.isArray || function(arr2) {
  return toString$3.call(arr2) == "[object Array]";
};
var isBuffer = isBuf$1;
var withNativeBuffer = typeof Buffer === "function" && typeof Buffer.isBuffer === "function";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = function(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
function isBuf$1(obj) {
  return withNativeBuffer && Buffer.isBuffer(obj) || withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj));
}
var isArray$2 = isarray;
var isBuf = isBuffer;
var toString$2 = Object.prototype.toString;
var withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && toString$2.call(Blob) === "[object BlobConstructor]";
var withNativeFile$1 = typeof File === "function" || typeof File !== "undefined" && toString$2.call(File) === "[object FileConstructor]";
binary.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
};
function _deconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (isBuf(data2)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data2);
    return placeholder;
  } else if (isArray$2(data2)) {
    var newData = new Array(data2.length);
    for (var i2 = 0; i2 < data2.length; i2++) {
      newData[i2] = _deconstructPacket(data2[i2], buffers);
    }
    return newData;
  } else if (typeof data2 === "object" && !(data2 instanceof Date)) {
    var newData = {};
    for (var key in data2) {
      newData[key] = _deconstructPacket(data2[key], buffers);
    }
    return newData;
  }
  return data2;
}
binary.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = void 0;
  return packet;
};
function _reconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (data2 && data2._placeholder === true) {
    var isIndexValid = typeof data2.num === "number" && data2.num >= 0 && data2.num < buffers.length;
    if (isIndexValid) {
      return buffers[data2.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (isArray$2(data2)) {
    for (var i2 = 0; i2 < data2.length; i2++) {
      data2[i2] = _reconstructPacket(data2[i2], buffers);
    }
  } else if (typeof data2 === "object") {
    for (var key in data2) {
      data2[key] = _reconstructPacket(data2[key], buffers);
    }
  }
  return data2;
}
binary.removeBlobs = function(data2, callback2) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj)
      return obj;
    if (withNativeBlob$1 && obj instanceof Blob || withNativeFile$1 && obj instanceof File) {
      pendingBlobs++;
      var fileReader = new FileReader();
      fileReader.onload = function() {
        if (containingObject) {
          containingObject[curKey] = this.result;
        } else {
          bloblessData = this.result;
        }
        if (!--pendingBlobs) {
          callback2(bloblessData);
        }
      };
      fileReader.readAsArrayBuffer(obj);
    } else if (isArray$2(obj)) {
      for (var i2 = 0; i2 < obj.length; i2++) {
        _removeBlobs(obj[i2], i2, obj);
      }
    } else if (typeof obj === "object" && !isBuf(obj)) {
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }
  var pendingBlobs = 0;
  var bloblessData = data2;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback2(bloblessData);
  }
};
(function(exports2) {
  var debug2 = browserExports$3("socket.io-parser");
  var Emitter2 = componentEmitterExports;
  var binary$1 = binary;
  var isArray2 = isarray;
  var isBuf2 = isBuffer;
  exports2.protocol = 4;
  exports2.types = [
    "CONNECT",
    "DISCONNECT",
    "EVENT",
    "ACK",
    "ERROR",
    "BINARY_EVENT",
    "BINARY_ACK"
  ];
  exports2.CONNECT = 0;
  exports2.DISCONNECT = 1;
  exports2.EVENT = 2;
  exports2.ACK = 3;
  exports2.ERROR = 4;
  exports2.BINARY_EVENT = 5;
  exports2.BINARY_ACK = 6;
  exports2.Encoder = Encoder;
  exports2.Decoder = Decoder;
  function Encoder() {
  }
  var ERROR_PACKET = exports2.ERROR + '"encode error"';
  Encoder.prototype.encode = function(obj, callback2) {
    debug2("encoding packet %j", obj);
    if (exports2.BINARY_EVENT === obj.type || exports2.BINARY_ACK === obj.type) {
      encodeAsBinary(obj, callback2);
    } else {
      var encoding = encodeAsString(obj);
      callback2([encoding]);
    }
  };
  function encodeAsString(obj) {
    var str = "" + obj.type;
    if (exports2.BINARY_EVENT === obj.type || exports2.BINARY_ACK === obj.type) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      var payload = tryStringify2(obj.data);
      if (payload !== false) {
        str += payload;
      } else {
        return ERROR_PACKET;
      }
    }
    debug2("encoded %j as %s", obj, str);
    return str;
  }
  function tryStringify2(str) {
    try {
      return JSON.stringify(str);
    } catch (e) {
      return false;
    }
  }
  function encodeAsBinary(obj, callback2) {
    function writeEncoding(bloblessData) {
      var deconstruction = binary$1.deconstructPacket(bloblessData);
      var pack = encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack);
      callback2(buffers);
    }
    binary$1.removeBlobs(obj, writeEncoding);
  }
  function Decoder() {
    this.reconstructor = null;
  }
  Emitter2(Decoder.prototype);
  Decoder.prototype.add = function(obj) {
    var packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = decodeString(obj);
      if (exports2.BINARY_EVENT === packet.type || exports2.BINARY_ACK === packet.type) {
        this.reconstructor = new BinaryReconstructor(packet);
        if (this.reconstructor.reconPack.attachments === 0) {
          this.emit("decoded", packet);
        }
      } else {
        this.emit("decoded", packet);
      }
    } else if (isBuf2(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          this.emit("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  };
  function decodeString(str) {
    var i2 = 0;
    var p = {
      type: Number(str.charAt(0))
    };
    if (null == exports2.types[p.type]) {
      return error2("unknown packet type " + p.type);
    }
    if (exports2.BINARY_EVENT === p.type || exports2.BINARY_ACK === p.type) {
      var start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      var buf = str.substring(start, i2);
      if (buf != Number(buf) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf);
    }
    if ("/" === str.charAt(i2 + 1)) {
      var start = i2 + 1;
      while (++i2) {
        var c = str.charAt(i2);
        if ("," === c)
          break;
        if (i2 === str.length)
          break;
      }
      p.nsp = str.substring(start, i2);
    } else {
      p.nsp = "/";
    }
    var next = str.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      var start = i2 + 1;
      while (++i2) {
        var c = str.charAt(i2);
        if (null == c || Number(c) != c) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      var payload = tryParse(str.substr(i2));
      var isPayloadValid = payload !== false && (p.type === exports2.ERROR || isArray2(payload));
      if (isPayloadValid) {
        p.data = payload;
      } else {
        return error2("invalid payload");
      }
    }
    debug2("decoded %s as %j", str, p);
    return p;
  }
  function tryParse(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return false;
    }
  }
  Decoder.prototype.destroy = function() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
    }
  };
  function BinaryReconstructor(packet) {
    this.reconPack = packet;
    this.buffers = [];
  }
  BinaryReconstructor.prototype.takeBinaryData = function(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      var packet = binary$1.reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  };
  BinaryReconstructor.prototype.finishedReconstruction = function() {
    this.reconPack = null;
    this.buffers = [];
  };
  function error2(msg) {
    return {
      type: exports2.ERROR,
      data: "parser error: " + msg
    };
  }
})(socket_ioParser);
var lib$1 = { exports: {} };
var transports$1 = {};
var hasCors = { exports: {} };
try {
  hasCors.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
  hasCors.exports = false;
}
var hasCorsExports = hasCors.exports;
var globalThis_browser = function() {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
}();
var hasCORS = hasCorsExports;
var globalThis$3 = globalThis_browser;
var xmlhttprequest_browser = function(opts) {
  var xdomain = opts.xdomain;
  var xscheme = opts.xscheme;
  var enablesXDR = opts.enablesXDR;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  try {
    if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThis$3[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
};
var pollingXhr = { exports: {} };
var browser$4 = {};
var keys = Object.keys || function keys2(obj) {
  var arr2 = [];
  var has2 = Object.prototype.hasOwnProperty;
  for (var i2 in obj) {
    if (has2.call(obj, i2)) {
      arr2.push(i2);
    }
  }
  return arr2;
};
var isArray$1 = isarray;
var toString$1 = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString$1.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString$1.call(File) === "[object FileConstructor]";
var hasBinary2 = hasBinary;
function hasBinary(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (isArray$1(obj)) {
    for (var i2 = 0, l = obj.length; i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (typeof Buffer === "function" && Buffer.isBuffer && Buffer.isBuffer(obj) || typeof ArrayBuffer === "function" && obj instanceof ArrayBuffer || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
var arraybuffer_slice = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;
  if (arraybuffer.slice) {
    return arraybuffer.slice(start, end);
  }
  if (start < 0) {
    start += bytes;
  }
  if (end < 0) {
    end += bytes;
  }
  if (end > bytes) {
    end = bytes;
  }
  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }
  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i2 = start, ii = 0; i2 < end; i2++, ii++) {
    result[ii] = abv[i2];
  }
  return result.buffer;
};
var after_1 = after;
function after(count, callback2, err_cb) {
  var bail = false;
  err_cb = err_cb || noop$2;
  proxy.count = count;
  return count === 0 ? callback2() : proxy;
  function proxy(err, result) {
    if (proxy.count <= 0) {
      throw new Error("after called too many times");
    }
    --proxy.count;
    if (err) {
      bail = true;
      callback2(err);
      callback2 = err_cb;
    } else if (proxy.count === 0 && !bail) {
      callback2(null, result);
    }
  }
}
function noop$2() {
}
/*! https://mths.be/utf8js v2.1.2 by @mathias */
var stringFromCharCode = String.fromCharCode;
function ucs2decode(string) {
  var output3 = [];
  var counter2 = 0;
  var length2 = string.length;
  var value;
  var extra;
  while (counter2 < length2) {
    value = string.charCodeAt(counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length2) {
      extra = string.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output3.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output3.push(value);
        counter2--;
      }
    } else {
      output3.push(value);
    }
  }
  return output3;
}
function ucs2encode(array) {
  var length2 = array.length;
  var index2 = -1;
  var value;
  var output3 = "";
  while (++index2 < length2) {
    value = array[index2];
    if (value > 65535) {
      value -= 65536;
      output3 += stringFromCharCode(value >>> 10 & 1023 | 55296);
      value = 56320 | value & 1023;
    }
    output3 += stringFromCharCode(value);
  }
  return output3;
}
function checkScalarValue(codePoint, strict2) {
  if (codePoint >= 55296 && codePoint <= 57343) {
    if (strict2) {
      throw Error(
        "Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value"
      );
    }
    return false;
  }
  return true;
}
function createByte(codePoint, shift) {
  return stringFromCharCode(codePoint >> shift & 63 | 128);
}
function encodeCodePoint(codePoint, strict2) {
  if ((codePoint & 4294967168) == 0) {
    return stringFromCharCode(codePoint);
  }
  var symbol = "";
  if ((codePoint & 4294965248) == 0) {
    symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
  } else if ((codePoint & 4294901760) == 0) {
    if (!checkScalarValue(codePoint, strict2)) {
      codePoint = 65533;
    }
    symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
    symbol += createByte(codePoint, 6);
  } else if ((codePoint & 4292870144) == 0) {
    symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
    symbol += createByte(codePoint, 12);
    symbol += createByte(codePoint, 6);
  }
  symbol += stringFromCharCode(codePoint & 63 | 128);
  return symbol;
}
function utf8encode(string, opts) {
  opts = opts || {};
  var strict2 = false !== opts.strict;
  var codePoints = ucs2decode(string);
  var length2 = codePoints.length;
  var index2 = -1;
  var codePoint;
  var byteString = "";
  while (++index2 < length2) {
    codePoint = codePoints[index2];
    byteString += encodeCodePoint(codePoint, strict2);
  }
  return byteString;
}
function readContinuationByte() {
  if (byteIndex >= byteCount) {
    throw Error("Invalid byte index");
  }
  var continuationByte = byteArray[byteIndex] & 255;
  byteIndex++;
  if ((continuationByte & 192) == 128) {
    return continuationByte & 63;
  }
  throw Error("Invalid continuation byte");
}
function decodeSymbol(strict2) {
  var byte1;
  var byte2;
  var byte3;
  var byte4;
  var codePoint;
  if (byteIndex > byteCount) {
    throw Error("Invalid byte index");
  }
  if (byteIndex == byteCount) {
    return false;
  }
  byte1 = byteArray[byteIndex] & 255;
  byteIndex++;
  if ((byte1 & 128) == 0) {
    return byte1;
  }
  if ((byte1 & 224) == 192) {
    byte2 = readContinuationByte();
    codePoint = (byte1 & 31) << 6 | byte2;
    if (codePoint >= 128) {
      return codePoint;
    } else {
      throw Error("Invalid continuation byte");
    }
  }
  if ((byte1 & 240) == 224) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
    if (codePoint >= 2048) {
      return checkScalarValue(codePoint, strict2) ? codePoint : 65533;
    } else {
      throw Error("Invalid continuation byte");
    }
  }
  if ((byte1 & 248) == 240) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    byte4 = readContinuationByte();
    codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
    if (codePoint >= 65536 && codePoint <= 1114111) {
      return codePoint;
    }
  }
  throw Error("Invalid UTF-8 detected");
}
var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
  opts = opts || {};
  var strict2 = false !== opts.strict;
  byteArray = ucs2decode(byteString);
  byteCount = byteArray.length;
  byteIndex = 0;
  var codePoints = [];
  var tmp;
  while ((tmp = decodeSymbol(strict2)) !== false) {
    codePoints.push(tmp);
  }
  return ucs2encode(codePoints);
}
var utf8 = {
  version: "2.1.2",
  encode: utf8encode,
  decode: utf8decode
};
var base64Arraybuffer = {};
var hasRequiredBase64Arraybuffer;
function requireBase64Arraybuffer() {
  if (hasRequiredBase64Arraybuffer)
    return base64Arraybuffer;
  hasRequiredBase64Arraybuffer = 1;
  (function(chars2) {
    base64Arraybuffer.encode = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer), i2, len2 = bytes.length, base64 = "";
      for (i2 = 0; i2 < len2; i2 += 3) {
        base64 += chars2[bytes[i2] >> 2];
        base64 += chars2[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
        base64 += chars2[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
        base64 += chars2[bytes[i2 + 2] & 63];
      }
      if (len2 % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len2 % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    base64Arraybuffer.decode = function(base64) {
      var bufferLength = base64.length * 0.75, len2 = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i2 = 0; i2 < len2; i2 += 4) {
        encoded1 = chars2.indexOf(base64[i2]);
        encoded2 = chars2.indexOf(base64[i2 + 1]);
        encoded3 = chars2.indexOf(base64[i2 + 2]);
        encoded4 = chars2.indexOf(base64[i2 + 3]);
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
  return base64Arraybuffer;
}
var blob;
var hasRequiredBlob;
function requireBlob() {
  if (hasRequiredBlob)
    return blob;
  hasRequiredBlob = 1;
  var BlobBuilder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof WebKitBlobBuilder !== "undefined" ? WebKitBlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : false;
  var blobSupported = function() {
    try {
      var a2 = new Blob(["hi"]);
      return a2.size === 2;
    } catch (e) {
      return false;
    }
  }();
  var blobSupportsArrayBufferView = blobSupported && function() {
    try {
      var b = new Blob([new Uint8Array([1, 2])]);
      return b.size === 2;
    } catch (e) {
      return false;
    }
  }();
  var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
  function mapArrayBufferViews(ary) {
    return ary.map(function(chunk) {
      if (chunk.buffer instanceof ArrayBuffer) {
        var buf = chunk.buffer;
        if (chunk.byteLength !== buf.byteLength) {
          var copy2 = new Uint8Array(chunk.byteLength);
          copy2.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
          buf = copy2.buffer;
        }
        return buf;
      }
      return chunk;
    });
  }
  function BlobBuilderConstructor(ary, options2) {
    options2 = options2 || {};
    var bb = new BlobBuilder();
    mapArrayBufferViews(ary).forEach(function(part) {
      bb.append(part);
    });
    return options2.type ? bb.getBlob(options2.type) : bb.getBlob();
  }
  function BlobConstructor(ary, options2) {
    return new Blob(mapArrayBufferViews(ary), options2 || {});
  }
  if (typeof Blob !== "undefined") {
    BlobBuilderConstructor.prototype = Blob.prototype;
    BlobConstructor.prototype = Blob.prototype;
  }
  blob = function() {
    if (blobSupported) {
      return blobSupportsArrayBufferView ? Blob : BlobConstructor;
    } else if (blobBuilderSupported) {
      return BlobBuilderConstructor;
    } else {
      return void 0;
    }
  }();
  return blob;
}
(function(exports2) {
  var keys$1 = keys;
  var hasBinary3 = hasBinary2;
  var sliceBuffer = arraybuffer_slice;
  var after2 = after_1;
  var utf8$1 = utf8;
  var base64encoder;
  if (typeof ArrayBuffer !== "undefined") {
    base64encoder = requireBase64Arraybuffer();
  }
  var isAndroid = typeof navigator !== "undefined" && /Android/i.test(navigator.userAgent);
  var isPhantomJS = typeof navigator !== "undefined" && /PhantomJS/i.test(navigator.userAgent);
  var dontSendBlobs = isAndroid || isPhantomJS;
  exports2.protocol = 3;
  var packets = exports2.packets = {
    open: 0,
    close: 1,
    ping: 2,
    pong: 3,
    message: 4,
    upgrade: 5,
    noop: 6
  };
  var packetslist = keys$1(packets);
  var err = { type: "error", data: "parser error" };
  var Blob2 = requireBlob();
  exports2.encodePacket = function(packet, supportsBinary, utf8encode2, callback2) {
    if (typeof supportsBinary === "function") {
      callback2 = supportsBinary;
      supportsBinary = false;
    }
    if (typeof utf8encode2 === "function") {
      callback2 = utf8encode2;
      utf8encode2 = null;
    }
    var data2 = packet.data === void 0 ? void 0 : packet.data.buffer || packet.data;
    if (typeof ArrayBuffer !== "undefined" && data2 instanceof ArrayBuffer) {
      return encodeArrayBuffer(packet, supportsBinary, callback2);
    } else if (typeof Blob2 !== "undefined" && data2 instanceof Blob2) {
      return encodeBlob(packet, supportsBinary, callback2);
    }
    if (data2 && data2.base64) {
      return encodeBase64Object(packet, callback2);
    }
    var encoded = packets[packet.type];
    if (void 0 !== packet.data) {
      encoded += utf8encode2 ? utf8$1.encode(String(packet.data), { strict: false }) : String(packet.data);
    }
    return callback2("" + encoded);
  };
  function encodeBase64Object(packet, callback2) {
    var message = "b" + exports2.packets[packet.type] + packet.data.data;
    return callback2(message);
  }
  function encodeArrayBuffer(packet, supportsBinary, callback2) {
    if (!supportsBinary) {
      return exports2.encodeBase64Packet(packet, callback2);
    }
    var data2 = packet.data;
    var contentArray = new Uint8Array(data2);
    var resultBuffer = new Uint8Array(1 + data2.byteLength);
    resultBuffer[0] = packets[packet.type];
    for (var i2 = 0; i2 < contentArray.length; i2++) {
      resultBuffer[i2 + 1] = contentArray[i2];
    }
    return callback2(resultBuffer.buffer);
  }
  function encodeBlobAsArrayBuffer(packet, supportsBinary, callback2) {
    if (!supportsBinary) {
      return exports2.encodeBase64Packet(packet, callback2);
    }
    var fr = new FileReader();
    fr.onload = function() {
      exports2.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback2);
    };
    return fr.readAsArrayBuffer(packet.data);
  }
  function encodeBlob(packet, supportsBinary, callback2) {
    if (!supportsBinary) {
      return exports2.encodeBase64Packet(packet, callback2);
    }
    if (dontSendBlobs) {
      return encodeBlobAsArrayBuffer(packet, supportsBinary, callback2);
    }
    var length2 = new Uint8Array(1);
    length2[0] = packets[packet.type];
    var blob2 = new Blob2([length2.buffer, packet.data]);
    return callback2(blob2);
  }
  exports2.encodeBase64Packet = function(packet, callback2) {
    var message = "b" + exports2.packets[packet.type];
    if (typeof Blob2 !== "undefined" && packet.data instanceof Blob2) {
      var fr = new FileReader();
      fr.onload = function() {
        var b64 = fr.result.split(",")[1];
        callback2(message + b64);
      };
      return fr.readAsDataURL(packet.data);
    }
    var b64data;
    try {
      b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
    } catch (e) {
      var typed = new Uint8Array(packet.data);
      var basic = new Array(typed.length);
      for (var i2 = 0; i2 < typed.length; i2++) {
        basic[i2] = typed[i2];
      }
      b64data = String.fromCharCode.apply(null, basic);
    }
    message += btoa(b64data);
    return callback2(message);
  };
  exports2.decodePacket = function(data2, binaryType, utf8decode2) {
    if (data2 === void 0) {
      return err;
    }
    if (typeof data2 === "string") {
      if (data2.charAt(0) === "b") {
        return exports2.decodeBase64Packet(data2.substr(1), binaryType);
      }
      if (utf8decode2) {
        data2 = tryDecode(data2);
        if (data2 === false) {
          return err;
        }
      }
      var type = data2.charAt(0);
      if (Number(type) != type || !packetslist[type]) {
        return err;
      }
      if (data2.length > 1) {
        return { type: packetslist[type], data: data2.substring(1) };
      } else {
        return { type: packetslist[type] };
      }
    }
    var asArray = new Uint8Array(data2);
    var type = asArray[0];
    var rest = sliceBuffer(data2, 1);
    if (Blob2 && binaryType === "blob") {
      rest = new Blob2([rest]);
    }
    return { type: packetslist[type], data: rest };
  };
  function tryDecode(data2) {
    try {
      data2 = utf8$1.decode(data2, { strict: false });
    } catch (e) {
      return false;
    }
    return data2;
  }
  exports2.decodeBase64Packet = function(msg, binaryType) {
    var type = packetslist[msg.charAt(0)];
    if (!base64encoder) {
      return { type, data: { base64: true, data: msg.substr(1) } };
    }
    var data2 = base64encoder.decode(msg.substr(1));
    if (binaryType === "blob" && Blob2) {
      data2 = new Blob2([data2]);
    }
    return { type, data: data2 };
  };
  exports2.encodePayload = function(packets2, supportsBinary, callback2) {
    if (typeof supportsBinary === "function") {
      callback2 = supportsBinary;
      supportsBinary = null;
    }
    var isBinary = hasBinary3(packets2);
    if (supportsBinary && isBinary) {
      if (Blob2 && !dontSendBlobs) {
        return exports2.encodePayloadAsBlob(packets2, callback2);
      }
      return exports2.encodePayloadAsArrayBuffer(packets2, callback2);
    }
    if (!packets2.length) {
      return callback2("0:");
    }
    function setLengthHeader(message) {
      return message.length + ":" + message;
    }
    function encodeOne(packet, doneCallback) {
      exports2.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
        doneCallback(null, setLengthHeader(message));
      });
    }
    map2(packets2, encodeOne, function(err2, results) {
      return callback2(results.join(""));
    });
  };
  function map2(ary, each2, done2) {
    var result = new Array(ary.length);
    var next = after2(ary.length, done2);
    var eachWithIndex = function(i3, el, cb) {
      each2(el, function(error2, msg) {
        result[i3] = msg;
        cb(error2, result);
      });
    };
    for (var i2 = 0; i2 < ary.length; i2++) {
      eachWithIndex(i2, ary[i2], next);
    }
  }
  exports2.decodePayload = function(data2, binaryType, callback2) {
    if (typeof data2 !== "string") {
      return exports2.decodePayloadAsBinary(data2, binaryType, callback2);
    }
    if (typeof binaryType === "function") {
      callback2 = binaryType;
      binaryType = null;
    }
    var packet;
    if (data2 === "") {
      return callback2(err, 0, 1);
    }
    var length2 = "", n, msg;
    for (var i2 = 0, l = data2.length; i2 < l; i2++) {
      var chr = data2.charAt(i2);
      if (chr !== ":") {
        length2 += chr;
        continue;
      }
      if (length2 === "" || length2 != (n = Number(length2))) {
        return callback2(err, 0, 1);
      }
      msg = data2.substr(i2 + 1, n);
      if (length2 != msg.length) {
        return callback2(err, 0, 1);
      }
      if (msg.length) {
        packet = exports2.decodePacket(msg, binaryType, false);
        if (err.type === packet.type && err.data === packet.data) {
          return callback2(err, 0, 1);
        }
        var ret = callback2(packet, i2 + n, l);
        if (false === ret)
          return;
      }
      i2 += n;
      length2 = "";
    }
    if (length2 !== "") {
      return callback2(err, 0, 1);
    }
  };
  exports2.encodePayloadAsArrayBuffer = function(packets2, callback2) {
    if (!packets2.length) {
      return callback2(new ArrayBuffer(0));
    }
    function encodeOne(packet, doneCallback) {
      exports2.encodePacket(packet, true, true, function(data2) {
        return doneCallback(null, data2);
      });
    }
    map2(packets2, encodeOne, function(err2, encodedPackets) {
      var totalLength = encodedPackets.reduce(function(acc, p) {
        var len2;
        if (typeof p === "string") {
          len2 = p.length;
        } else {
          len2 = p.byteLength;
        }
        return acc + len2.toString().length + len2 + 2;
      }, 0);
      var resultArray = new Uint8Array(totalLength);
      var bufferIndex = 0;
      encodedPackets.forEach(function(p) {
        var isString2 = typeof p === "string";
        var ab = p;
        if (isString2) {
          var view = new Uint8Array(p.length);
          for (var i2 = 0; i2 < p.length; i2++) {
            view[i2] = p.charCodeAt(i2);
          }
          ab = view.buffer;
        }
        if (isString2) {
          resultArray[bufferIndex++] = 0;
        } else {
          resultArray[bufferIndex++] = 1;
        }
        var lenStr = ab.byteLength.toString();
        for (var i2 = 0; i2 < lenStr.length; i2++) {
          resultArray[bufferIndex++] = parseInt(lenStr[i2]);
        }
        resultArray[bufferIndex++] = 255;
        var view = new Uint8Array(ab);
        for (var i2 = 0; i2 < view.length; i2++) {
          resultArray[bufferIndex++] = view[i2];
        }
      });
      return callback2(resultArray.buffer);
    });
  };
  exports2.encodePayloadAsBlob = function(packets2, callback2) {
    function encodeOne(packet, doneCallback) {
      exports2.encodePacket(packet, true, true, function(encoded) {
        var binaryIdentifier = new Uint8Array(1);
        binaryIdentifier[0] = 1;
        if (typeof encoded === "string") {
          var view = new Uint8Array(encoded.length);
          for (var i2 = 0; i2 < encoded.length; i2++) {
            view[i2] = encoded.charCodeAt(i2);
          }
          encoded = view.buffer;
          binaryIdentifier[0] = 0;
        }
        var len2 = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
        var lenStr = len2.toString();
        var lengthAry = new Uint8Array(lenStr.length + 1);
        for (var i2 = 0; i2 < lenStr.length; i2++) {
          lengthAry[i2] = parseInt(lenStr[i2]);
        }
        lengthAry[lenStr.length] = 255;
        if (Blob2) {
          var blob2 = new Blob2([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
          doneCallback(null, blob2);
        }
      });
    }
    map2(packets2, encodeOne, function(err2, results) {
      return callback2(new Blob2(results));
    });
  };
  exports2.decodePayloadAsBinary = function(data2, binaryType, callback2) {
    if (typeof binaryType === "function") {
      callback2 = binaryType;
      binaryType = null;
    }
    var bufferTail = data2;
    var buffers = [];
    while (bufferTail.byteLength > 0) {
      var tailArray = new Uint8Array(bufferTail);
      var isString2 = tailArray[0] === 0;
      var msgLength = "";
      for (var i2 = 1; ; i2++) {
        if (tailArray[i2] === 255)
          break;
        if (msgLength.length > 310) {
          return callback2(err, 0, 1);
        }
        msgLength += tailArray[i2];
      }
      bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
      msgLength = parseInt(msgLength);
      var msg = sliceBuffer(bufferTail, 0, msgLength);
      if (isString2) {
        try {
          msg = String.fromCharCode.apply(null, new Uint8Array(msg));
        } catch (e) {
          var typed = new Uint8Array(msg);
          msg = "";
          for (var i2 = 0; i2 < typed.length; i2++) {
            msg += String.fromCharCode(typed[i2]);
          }
        }
      }
      buffers.push(msg);
      bufferTail = sliceBuffer(bufferTail, msgLength);
    }
    var total = buffers.length;
    buffers.forEach(function(buffer2, i3) {
      callback2(exports2.decodePacket(buffer2, binaryType, true), i3, total);
    });
  };
})(browser$4);
var transport;
var hasRequiredTransport;
function requireTransport() {
  if (hasRequiredTransport)
    return transport;
  hasRequiredTransport = 1;
  var parser2 = browser$4;
  var Emitter2 = componentEmitterExports;
  transport = Transport2;
  function Transport2(opts) {
    this.path = opts.path;
    this.hostname = opts.hostname;
    this.port = opts.port;
    this.secure = opts.secure;
    this.query = opts.query;
    this.timestampParam = opts.timestampParam;
    this.timestampRequests = opts.timestampRequests;
    this.readyState = "";
    this.agent = opts.agent || false;
    this.socket = opts.socket;
    this.enablesXDR = opts.enablesXDR;
    this.withCredentials = opts.withCredentials;
    this.pfx = opts.pfx;
    this.key = opts.key;
    this.passphrase = opts.passphrase;
    this.cert = opts.cert;
    this.ca = opts.ca;
    this.ciphers = opts.ciphers;
    this.rejectUnauthorized = opts.rejectUnauthorized;
    this.forceNode = opts.forceNode;
    this.isReactNative = opts.isReactNative;
    this.extraHeaders = opts.extraHeaders;
    this.localAddress = opts.localAddress;
  }
  Emitter2(Transport2.prototype);
  Transport2.prototype.onError = function(msg, desc) {
    var err = new Error(msg);
    err.type = "TransportError";
    err.description = desc;
    this.emit("error", err);
    return this;
  };
  Transport2.prototype.open = function() {
    if ("closed" === this.readyState || "" === this.readyState) {
      this.readyState = "opening";
      this.doOpen();
    }
    return this;
  };
  Transport2.prototype.close = function() {
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.doClose();
      this.onClose();
    }
    return this;
  };
  Transport2.prototype.send = function(packets) {
    if ("open" === this.readyState) {
      this.write(packets);
    } else {
      throw new Error("Transport not open");
    }
  };
  Transport2.prototype.onOpen = function() {
    this.readyState = "open";
    this.writable = true;
    this.emit("open");
  };
  Transport2.prototype.onData = function(data2) {
    var packet = parser2.decodePacket(data2, this.socket.binaryType);
    this.onPacket(packet);
  };
  Transport2.prototype.onPacket = function(packet) {
    this.emit("packet", packet);
  };
  Transport2.prototype.onClose = function() {
    this.readyState = "closed";
    this.emit("close");
  };
  return transport;
}
var parseqs$3 = {};
parseqs$3.encode = function(obj) {
  var str = "";
  for (var i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
};
parseqs$3.decode = function(qs2) {
  var qry = {};
  var pairs = qs2.split("&");
  for (var i2 = 0, l = pairs.length; i2 < l; i2++) {
    var pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};
var componentInherit = function(a2, b) {
  var fn = function() {
  };
  fn.prototype = b.prototype;
  a2.prototype = new fn();
  a2.prototype.constructor = a2;
};
var alphabet$3 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {}, seed$1 = 0, i$2 = 0, prev;
function encode(num) {
  var encoded = "";
  do {
    encoded = alphabet$3[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function decode(str) {
  var decoded = 0;
  for (i$2 = 0; i$2 < str.length; i$2++) {
    decoded = decoded * length + map[str.charAt(i$2)];
  }
  return decoded;
}
function yeast$2() {
  var now2 = encode(+/* @__PURE__ */ new Date());
  if (now2 !== prev)
    return seed$1 = 0, prev = now2;
  return now2 + "." + encode(seed$1++);
}
for (; i$2 < length; i$2++)
  map[alphabet$3[i$2]] = i$2;
yeast$2.encode = encode;
yeast$2.decode = decode;
var yeast_1 = yeast$2;
var browser$3 = { exports: {} };
var debug$6 = { exports: {} };
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;
var ms$1 = function(val, options2) {
  options2 = options2 || {};
  var type = typeof val;
  if (type === "string" && val.length > 0) {
    return parse(val);
  } else if (type === "number" && isNaN(val) === false) {
    return options2.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  if (ms2 >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (ms2 >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (ms2 >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (ms2 >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  return plural(ms2, d, "day") || plural(ms2, h, "hour") || plural(ms2, m, "minute") || plural(ms2, s, "second") || ms2 + " ms";
}
function plural(ms2, n, name) {
  if (ms2 < n) {
    return;
  }
  if (ms2 < n * 1.5) {
    return Math.floor(ms2 / n) + " " + name;
  }
  return Math.ceil(ms2 / n) + " " + name + "s";
}
(function(module2, exports2) {
  exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = ms$1;
  exports2.instances = [];
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  function selectColor(namespace) {
    var hash = 0, i2;
    for (i2 in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return exports2.colors[Math.abs(hash) % exports2.colors.length];
  }
  function createDebug(namespace) {
    var prevTime;
    function debug2() {
      if (!debug2.enabled)
        return;
      var self2 = debug2;
      var curr = +/* @__PURE__ */ new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      args[0] = exports2.coerce(args[0]);
      if ("string" !== typeof args[0]) {
        args.unshift("%O");
      }
      var index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
        if (match === "%%")
          return match;
        index2++;
        var formatter = exports2.formatters[format2];
        if ("function" === typeof formatter) {
          var val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      exports2.formatArgs.call(self2, args);
      var logFn = debug2.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.enabled = exports2.enabled(namespace);
    debug2.useColors = exports2.useColors();
    debug2.color = selectColor(namespace);
    debug2.destroy = destroy2;
    if ("function" === typeof exports2.init) {
      exports2.init(debug2);
    }
    exports2.instances.push(debug2);
    return debug2;
  }
  function destroy2() {
    var index2 = exports2.instances.indexOf(this);
    if (index2 !== -1) {
      exports2.instances.splice(index2, 1);
      return true;
    } else {
      return false;
    }
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var i2;
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len2 = split.length;
    for (i2 = 0; i2 < len2; i2++) {
      if (!split[i2])
        continue;
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
    for (i2 = 0; i2 < exports2.instances.length; i2++) {
      var instance2 = exports2.instances[i2];
      instance2.enabled = exports2.enabled(instance2.namespace);
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    var i2, len2;
    for (i2 = 0, len2 = exports2.skips.length; i2 < len2; i2++) {
      if (exports2.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len2 = exports2.names.length; i2 < len2; i2++) {
      if (exports2.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
})(debug$6, debug$6.exports);
var debugExports = debug$6.exports;
(function(module2, exports2) {
  exports2 = module2.exports = debugExports;
  exports2.log = log3;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index2 = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if ("%%" === match)
        return;
      index2++;
      if ("%c" === match) {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log3() {
    return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = {}.DEBUG;
    }
    return r;
  }
  exports2.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
})(browser$3, browser$3.exports);
var browserExports$2 = browser$3.exports;
var Transport$1 = requireTransport();
var parseqs$2 = parseqs$3;
var parser$3 = browser$4;
var inherit$3 = componentInherit;
var yeast$1 = yeast_1;
var debug$5 = browserExports$2("engine.io-client:polling");
var polling$1 = Polling$2;
var hasXHR2 = function() {
  var XMLHttpRequest2 = xmlhttprequest_browser;
  var xhr = new XMLHttpRequest2({ xdomain: false });
  return null != xhr.responseType;
}();
function Polling$2(opts) {
  var forceBase64 = opts && opts.forceBase64;
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport$1.call(this, opts);
}
inherit$3(Polling$2, Transport$1);
Polling$2.prototype.name = "polling";
Polling$2.prototype.doOpen = function() {
  this.poll();
};
Polling$2.prototype.pause = function(onPause) {
  var self2 = this;
  this.readyState = "pausing";
  function pause() {
    debug$5("paused");
    self2.readyState = "paused";
    onPause();
  }
  if (this.polling || !this.writable) {
    var total = 0;
    if (this.polling) {
      debug$5("we are currently polling - waiting to pause");
      total++;
      this.once("pollComplete", function() {
        debug$5("pre-pause polling complete");
        --total || pause();
      });
    }
    if (!this.writable) {
      debug$5("we are currently writing - waiting to pause");
      total++;
      this.once("drain", function() {
        debug$5("pre-pause writing complete");
        --total || pause();
      });
    }
  } else {
    pause();
  }
};
Polling$2.prototype.poll = function() {
  debug$5("polling");
  this.polling = true;
  this.doPoll();
  this.emit("poll");
};
Polling$2.prototype.onData = function(data2) {
  var self2 = this;
  debug$5("polling got data %s", data2);
  var callback2 = function(packet, index2, total) {
    if ("opening" === self2.readyState && packet.type === "open") {
      self2.onOpen();
    }
    if ("close" === packet.type) {
      self2.onClose();
      return false;
    }
    self2.onPacket(packet);
  };
  parser$3.decodePayload(data2, this.socket.binaryType, callback2);
  if ("closed" !== this.readyState) {
    this.polling = false;
    this.emit("pollComplete");
    if ("open" === this.readyState) {
      this.poll();
    } else {
      debug$5('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};
Polling$2.prototype.doClose = function() {
  var self2 = this;
  function close() {
    debug$5("writing close packet");
    self2.write([{ type: "close" }]);
  }
  if ("open" === this.readyState) {
    debug$5("transport open - closing");
    close();
  } else {
    debug$5("transport not open - deferring close");
    this.once("open", close);
  }
};
Polling$2.prototype.write = function(packets) {
  var self2 = this;
  this.writable = false;
  var callbackfn = function() {
    self2.writable = true;
    self2.emit("drain");
  };
  parser$3.encodePayload(packets, this.supportsBinary, function(data2) {
    self2.doWrite(data2, callbackfn);
  });
};
Polling$2.prototype.uri = function() {
  var query = this.query || {};
  var schema = this.secure ? "https" : "http";
  var port = "";
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast$1();
  }
  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }
  query = parseqs$2.encode(query);
  if (this.port && ("https" === schema && Number(this.port) !== 443 || "http" === schema && Number(this.port) !== 80)) {
    port = ":" + this.port;
  }
  if (query.length) {
    query = "?" + query;
  }
  var ipv6 = this.hostname.indexOf(":") !== -1;
  return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
};
var XMLHttpRequest$2 = xmlhttprequest_browser;
var Polling$1 = polling$1;
var Emitter$2 = componentEmitterExports;
var inherit$2 = componentInherit;
var debug$4 = browserExports$2("engine.io-client:polling-xhr");
var globalThis$2 = globalThis_browser;
pollingXhr.exports = XHR$1;
pollingXhr.exports.Request = Request;
function empty$3() {
}
function XHR$1(opts) {
  Polling$1.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;
  if (typeof location !== "undefined") {
    var isSSL = "https:" === location.protocol;
    var port = location.port;
    if (!port) {
      port = isSSL ? 443 : 80;
    }
    this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}
inherit$2(XHR$1, Polling$1);
XHR$1.prototype.supportsBinary = true;
XHR$1.prototype.request = function(opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;
  opts.withCredentials = this.withCredentials;
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;
  opts.extraHeaders = this.extraHeaders;
  return new Request(opts);
};
XHR$1.prototype.doWrite = function(data2, fn) {
  var isBinary = typeof data2 !== "string" && data2 !== void 0;
  var req = this.request({ method: "POST", data: data2, isBinary });
  var self2 = this;
  req.on("success", fn);
  req.on("error", function(err) {
    self2.onError("xhr post error", err);
  });
  this.sendXhr = req;
};
XHR$1.prototype.doPoll = function() {
  debug$4("xhr poll");
  var req = this.request();
  var self2 = this;
  req.on("data", function(data2) {
    self2.onData(data2);
  });
  req.on("error", function(err) {
    self2.onError("xhr poll error", err);
  });
  this.pollXhr = req;
};
function Request(opts) {
  this.method = opts.method || "GET";
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = void 0 !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;
  this.requestTimeout = opts.requestTimeout;
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.extraHeaders = opts.extraHeaders;
  this.create();
}
Emitter$2(Request.prototype);
Request.prototype.create = function() {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  var xhr = this.xhr = new XMLHttpRequest$2(opts);
  var self2 = this;
  try {
    debug$4("xhr open %s: %s", this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i2 in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i2)) {
            xhr.setRequestHeader(i2, this.extraHeaders[i2]);
          }
        }
      }
    } catch (e) {
    }
    if ("POST" === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader("Content-type", "application/octet-stream");
        } else {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        }
      } catch (e) {
      }
    }
    try {
      xhr.setRequestHeader("Accept", "*/*");
    } catch (e) {
    }
    if ("withCredentials" in xhr) {
      xhr.withCredentials = this.withCredentials;
    }
    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }
    if (this.hasXDR()) {
      xhr.onload = function() {
        self2.onLoad();
      };
      xhr.onerror = function() {
        self2.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader("Content-Type");
            if (self2.supportsBinary && contentType === "application/octet-stream" || contentType === "application/octet-stream; charset=UTF-8") {
              xhr.responseType = "arraybuffer";
            }
          } catch (e) {
          }
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self2.onLoad();
        } else {
          setTimeout(function() {
            self2.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
    }
    debug$4("xhr data %s", this.data);
    xhr.send(this.data);
  } catch (e) {
    setTimeout(function() {
      self2.onError(e);
    }, 0);
    return;
  }
  if (typeof document !== "undefined") {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};
Request.prototype.onSuccess = function() {
  this.emit("success");
  this.cleanup();
};
Request.prototype.onData = function(data2) {
  this.emit("data", data2);
  this.onSuccess();
};
Request.prototype.onError = function(err) {
  this.emit("error", err);
  this.cleanup(true);
};
Request.prototype.cleanup = function(fromError) {
  if ("undefined" === typeof this.xhr || null === this.xhr) {
    return;
  }
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty$3;
  } else {
    this.xhr.onreadystatechange = empty$3;
  }
  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {
    }
  }
  if (typeof document !== "undefined") {
    delete Request.requests[this.index];
  }
  this.xhr = null;
};
Request.prototype.onLoad = function() {
  var data2;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader("Content-Type");
    } catch (e) {
    }
    if (contentType === "application/octet-stream" || contentType === "application/octet-stream; charset=UTF-8") {
      data2 = this.xhr.response || this.xhr.responseText;
    } else {
      data2 = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data2) {
    this.onData(data2);
  }
};
Request.prototype.hasXDR = function() {
  return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
};
Request.prototype.abort = function() {
  this.cleanup();
};
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    var terminationEvent = "onpagehide" in globalThis$2 ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (var i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}
var pollingXhrExports = pollingXhr.exports;
var Polling = polling$1;
var inherit$1 = componentInherit;
var globalThis$1 = globalThis_browser;
var pollingJsonp = JSONPPolling;
var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;
var callbacks;
function empty$2() {
}
function JSONPPolling(opts) {
  Polling.call(this, opts);
  this.query = this.query || {};
  if (!callbacks) {
    callbacks = globalThis$1.___eio = globalThis$1.___eio || [];
  }
  this.index = callbacks.length;
  var self2 = this;
  callbacks.push(function(msg) {
    self2.onData(msg);
  });
  this.query.j = this.index;
  if (typeof addEventListener === "function") {
    addEventListener("beforeunload", function() {
      if (self2.script)
        self2.script.onerror = empty$2;
    }, false);
  }
}
inherit$1(JSONPPolling, Polling);
JSONPPolling.prototype.supportsBinary = false;
JSONPPolling.prototype.doClose = function() {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }
  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }
  Polling.prototype.doClose.call(this);
};
JSONPPolling.prototype.doPoll = function() {
  var self2 = this;
  var script = document.createElement("script");
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }
  script.async = true;
  script.src = this.uri();
  script.onerror = function(e) {
    self2.onError("jsonp poll error", e);
  };
  var insertAt = document.getElementsByTagName("script")[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;
  var isUAgecko = "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);
  if (isUAgecko) {
    setTimeout(function() {
      var iframe = document.createElement("iframe");
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};
JSONPPolling.prototype.doWrite = function(data2, fn) {
  var self2 = this;
  if (!this.form) {
    var form = document.createElement("form");
    var area = document.createElement("textarea");
    var id2 = this.iframeId = "eio_iframe_" + this.index;
    var iframe;
    form.className = "socketio";
    form.style.position = "absolute";
    form.style.top = "-1000px";
    form.style.left = "-1000px";
    form.target = id2;
    form.method = "POST";
    form.setAttribute("accept-charset", "utf-8");
    area.name = "d";
    form.appendChild(area);
    document.body.appendChild(form);
    this.form = form;
    this.area = area;
  }
  this.form.action = this.uri();
  function complete() {
    initIframe();
    fn();
  }
  function initIframe() {
    if (self2.iframe) {
      try {
        self2.form.removeChild(self2.iframe);
      } catch (e) {
        self2.onError("jsonp polling iframe removal error", e);
      }
    }
    try {
      var html2 = '<iframe src="javascript:0" name="' + self2.iframeId + '">';
      iframe = document.createElement(html2);
    } catch (e) {
      iframe = document.createElement("iframe");
      iframe.name = self2.iframeId;
      iframe.src = "javascript:0";
    }
    iframe.id = self2.iframeId;
    self2.form.appendChild(iframe);
    self2.iframe = iframe;
  }
  initIframe();
  data2 = data2.replace(rEscapedNewline, "\\\n");
  this.area.value = data2.replace(rNewline, "\\n");
  try {
    this.form.submit();
  } catch (e) {
  }
  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function() {
      if (self2.iframe.readyState === "complete") {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};
var Transport = requireTransport();
var parser$2 = browser$4;
var parseqs$1 = parseqs$3;
var inherit = componentInherit;
var yeast = yeast_1;
var debug$3 = browserExports$2("engine.io-client:websocket");
var BrowserWebSocket, NodeWebSocket;
if (typeof WebSocket !== "undefined") {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== "undefined") {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
}
if (typeof window === "undefined") {
  try {
    NodeWebSocket = require$$3;
  } catch (e) {
  }
}
var WebSocketImpl = BrowserWebSocket || NodeWebSocket;
var websocket$1 = WS;
function WS(opts) {
  var forceBase64 = opts && opts.forceBase64;
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  Transport.call(this, opts);
}
inherit(WS, Transport);
WS.prototype.name = "websocket";
WS.prototype.supportsBinary = true;
WS.prototype.doOpen = function() {
  if (!this.check()) {
    return;
  }
  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {};
  if (!this.isReactNative) {
    opts.agent = this.agent;
    opts.perMessageDeflate = this.perMessageDeflate;
    opts.pfx = this.pfx;
    opts.key = this.key;
    opts.passphrase = this.passphrase;
    opts.cert = this.cert;
    opts.ca = this.ca;
    opts.ciphers = this.ciphers;
    opts.rejectUnauthorized = this.rejectUnauthorized;
  }
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }
  try {
    this.ws = this.usingBrowserWebSocket && !this.isReactNative ? protocols ? new WebSocketImpl(uri, protocols) : new WebSocketImpl(uri) : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit("error", err);
  }
  if (this.ws.binaryType === void 0) {
    this.supportsBinary = false;
  }
  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = "nodebuffer";
  } else {
    this.ws.binaryType = "arraybuffer";
  }
  this.addEventListeners();
};
WS.prototype.addEventListeners = function() {
  var self2 = this;
  this.ws.onopen = function() {
    self2.onOpen();
  };
  this.ws.onclose = function() {
    self2.onClose();
  };
  this.ws.onmessage = function(ev) {
    self2.onData(ev.data);
  };
  this.ws.onerror = function(e) {
    self2.onError("websocket error", e);
  };
};
WS.prototype.write = function(packets) {
  var self2 = this;
  this.writable = false;
  var total = packets.length;
  for (var i2 = 0, l = total; i2 < l; i2++) {
    (function(packet) {
      parser$2.encodePacket(packet, self2.supportsBinary, function(data2) {
        if (!self2.usingBrowserWebSocket) {
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }
          if (self2.perMessageDeflate) {
            var len2 = "string" === typeof data2 ? Buffer.byteLength(data2) : data2.length;
            if (len2 < self2.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }
        try {
          if (self2.usingBrowserWebSocket) {
            self2.ws.send(data2);
          } else {
            self2.ws.send(data2, opts);
          }
        } catch (e) {
          debug$3("websocket closed before onclose event");
        }
        --total || done2();
      });
    })(packets[i2]);
  }
  function done2() {
    self2.emit("flush");
    setTimeout(function() {
      self2.writable = true;
      self2.emit("drain");
    }, 0);
  }
};
WS.prototype.onClose = function() {
  Transport.prototype.onClose.call(this);
};
WS.prototype.doClose = function() {
  if (typeof this.ws !== "undefined") {
    this.ws.close();
  }
};
WS.prototype.uri = function() {
  var query = this.query || {};
  var schema = this.secure ? "wss" : "ws";
  var port = "";
  if (this.port && ("wss" === schema && Number(this.port) !== 443 || "ws" === schema && Number(this.port) !== 80)) {
    port = ":" + this.port;
  }
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }
  if (!this.supportsBinary) {
    query.b64 = 1;
  }
  query = parseqs$1.encode(query);
  if (query.length) {
    query = "?" + query;
  }
  var ipv6 = this.hostname.indexOf(":") !== -1;
  return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
};
WS.prototype.check = function() {
  return !!WebSocketImpl && !("__initialize" in WebSocketImpl && this.name === WS.prototype.name);
};
var XMLHttpRequest$1 = xmlhttprequest_browser;
var XHR = pollingXhrExports;
var JSONP = pollingJsonp;
var websocket = websocket$1;
transports$1.polling = polling;
transports$1.websocket = websocket;
function polling(opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;
  if (typeof location !== "undefined") {
    var isSSL = "https:" === location.protocol;
    var port = location.port;
    if (!port) {
      port = isSSL ? 443 : 80;
    }
    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }
  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest$1(opts);
  if ("open" in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp)
      throw new Error("JSONP disabled");
    return new JSONP(opts);
  }
}
var indexOf$1 = [].indexOf;
var indexof = function(arr2, obj) {
  if (indexOf$1)
    return arr2.indexOf(obj);
  for (var i2 = 0; i2 < arr2.length; ++i2) {
    if (arr2[i2] === obj)
      return i2;
  }
  return -1;
};
var transports = transports$1;
var Emitter$1 = componentEmitterExports;
var debug$2 = browserExports$2("engine.io-client:socket");
var index = indexof;
var parser$1 = browser$4;
var parseuri = parseuri$2;
var parseqs = parseqs$3;
var socket$1 = Socket$1;
function Socket$1(uri, opts) {
  if (!(this instanceof Socket$1))
    return new Socket$1(uri, opts);
  opts = opts || {};
  if (uri && "object" === typeof uri) {
    opts = uri;
    uri = null;
  }
  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === "https" || uri.protocol === "wss";
    opts.port = uri.port;
    if (uri.query)
      opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }
  this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
  if (opts.hostname && !opts.port) {
    opts.port = this.secure ? "443" : "80";
  }
  this.agent = opts.agent || false;
  this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
  this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? 443 : 80);
  this.query = opts.query || {};
  if ("string" === typeof this.query)
    this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || "/engine.io").replace(/\/$/, "") + "/";
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.withCredentials = false !== opts.withCredentials;
  this.timestampParam = opts.timestampParam || "t";
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ["polling", "websocket"];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = "";
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;
  if (true === this.perMessageDeflate)
    this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }
  this.pfx = opts.pfx || void 0;
  this.key = opts.key || void 0;
  this.passphrase = opts.passphrase || void 0;
  this.cert = opts.cert || void 0;
  this.ca = opts.ca || void 0;
  this.ciphers = opts.ciphers || void 0;
  this.rejectUnauthorized = opts.rejectUnauthorized === void 0 ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;
  this.isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
  if (typeof self === "undefined" || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }
    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;
  this.open();
}
Socket$1.priorWebsocketSuccess = false;
Emitter$1(Socket$1.prototype);
Socket$1.protocol = parser$1.protocol;
Socket$1.Socket = Socket$1;
Socket$1.Transport = requireTransport();
Socket$1.transports = transports$1;
Socket$1.parser = browser$4;
Socket$1.prototype.createTransport = function(name) {
  debug$2('creating transport "%s"', name);
  var query = clone(this.query);
  query.EIO = parser$1.protocol;
  query.transport = name;
  var options2 = this.transportOptions[name] || {};
  if (this.id)
    query.sid = this.id;
  var transport2 = new transports[name]({
    query,
    socket: this,
    agent: options2.agent || this.agent,
    hostname: options2.hostname || this.hostname,
    port: options2.port || this.port,
    secure: options2.secure || this.secure,
    path: options2.path || this.path,
    forceJSONP: options2.forceJSONP || this.forceJSONP,
    jsonp: options2.jsonp || this.jsonp,
    forceBase64: options2.forceBase64 || this.forceBase64,
    enablesXDR: options2.enablesXDR || this.enablesXDR,
    withCredentials: options2.withCredentials || this.withCredentials,
    timestampRequests: options2.timestampRequests || this.timestampRequests,
    timestampParam: options2.timestampParam || this.timestampParam,
    policyPort: options2.policyPort || this.policyPort,
    pfx: options2.pfx || this.pfx,
    key: options2.key || this.key,
    passphrase: options2.passphrase || this.passphrase,
    cert: options2.cert || this.cert,
    ca: options2.ca || this.ca,
    ciphers: options2.ciphers || this.ciphers,
    rejectUnauthorized: options2.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options2.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options2.extraHeaders || this.extraHeaders,
    forceNode: options2.forceNode || this.forceNode,
    localAddress: options2.localAddress || this.localAddress,
    requestTimeout: options2.requestTimeout || this.requestTimeout,
    protocols: options2.protocols || void 0,
    isReactNative: this.isReactNative
  });
  return transport2;
};
function clone(obj) {
  var o = {};
  for (var i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      o[i2] = obj[i2];
    }
  }
  return o;
}
Socket$1.prototype.open = function() {
  var transport2;
  if (this.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
    transport2 = "websocket";
  } else if (0 === this.transports.length) {
    var self2 = this;
    setTimeout(function() {
      self2.emit("error", "No transports available");
    }, 0);
    return;
  } else {
    transport2 = this.transports[0];
  }
  this.readyState = "opening";
  try {
    transport2 = this.createTransport(transport2);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }
  transport2.open();
  this.setTransport(transport2);
};
Socket$1.prototype.setTransport = function(transport2) {
  debug$2("setting transport %s", transport2.name);
  var self2 = this;
  if (this.transport) {
    debug$2("clearing existing transport %s", this.transport.name);
    this.transport.removeAllListeners();
  }
  this.transport = transport2;
  transport2.on("drain", function() {
    self2.onDrain();
  }).on("packet", function(packet) {
    self2.onPacket(packet);
  }).on("error", function(e) {
    self2.onError(e);
  }).on("close", function() {
    self2.onClose("transport close");
  });
};
Socket$1.prototype.probe = function(name) {
  debug$2('probing transport "%s"', name);
  var transport2 = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self2 = this;
  Socket$1.priorWebsocketSuccess = false;
  function onTransportOpen() {
    if (self2.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self2.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed)
      return;
    debug$2('probe transport "%s" opened', name);
    transport2.send([{ type: "ping", data: "probe" }]);
    transport2.once("packet", function(msg) {
      if (failed)
        return;
      if ("pong" === msg.type && "probe" === msg.data) {
        debug$2('probe transport "%s" pong', name);
        self2.upgrading = true;
        self2.emit("upgrading", transport2);
        if (!transport2)
          return;
        Socket$1.priorWebsocketSuccess = "websocket" === transport2.name;
        debug$2('pausing current transport "%s"', self2.transport.name);
        self2.transport.pause(function() {
          if (failed)
            return;
          if ("closed" === self2.readyState)
            return;
          debug$2("changing transport and sending upgrade packet");
          cleanup();
          self2.setTransport(transport2);
          transport2.send([{ type: "upgrade" }]);
          self2.emit("upgrade", transport2);
          transport2 = null;
          self2.upgrading = false;
          self2.flush();
        });
      } else {
        debug$2('probe transport "%s" failed', name);
        var err = new Error("probe error");
        err.transport = transport2.name;
        self2.emit("upgradeError", err);
      }
    });
  }
  function freezeTransport() {
    if (failed)
      return;
    failed = true;
    cleanup();
    transport2.close();
    transport2 = null;
  }
  function onerror(err) {
    var error2 = new Error("probe error: " + err);
    error2.transport = transport2.name;
    freezeTransport();
    debug$2('probe transport "%s" failed because of error: %s', name, err);
    self2.emit("upgradeError", error2);
  }
  function onTransportClose() {
    onerror("transport closed");
  }
  function onclose() {
    onerror("socket closed");
  }
  function onupgrade(to) {
    if (transport2 && to.name !== transport2.name) {
      debug$2('"%s" works - aborting "%s"', to.name, transport2.name);
      freezeTransport();
    }
  }
  function cleanup() {
    transport2.removeListener("open", onTransportOpen);
    transport2.removeListener("error", onerror);
    transport2.removeListener("close", onTransportClose);
    self2.removeListener("close", onclose);
    self2.removeListener("upgrading", onupgrade);
  }
  transport2.once("open", onTransportOpen);
  transport2.once("error", onerror);
  transport2.once("close", onTransportClose);
  this.once("close", onclose);
  this.once("upgrading", onupgrade);
  transport2.open();
};
Socket$1.prototype.onOpen = function() {
  debug$2("socket open");
  this.readyState = "open";
  Socket$1.priorWebsocketSuccess = "websocket" === this.transport.name;
  this.emit("open");
  this.flush();
  if ("open" === this.readyState && this.upgrade && this.transport.pause) {
    debug$2("starting upgrade probes");
    for (var i2 = 0, l = this.upgrades.length; i2 < l; i2++) {
      this.probe(this.upgrades[i2]);
    }
  }
};
Socket$1.prototype.onPacket = function(packet) {
  if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
    debug$2('socket receive: type "%s", data "%s"', packet.type, packet.data);
    this.emit("packet", packet);
    this.emit("heartbeat");
    switch (packet.type) {
      case "open":
        this.onHandshake(JSON.parse(packet.data));
        break;
      case "pong":
        this.setPing();
        this.emit("pong");
        break;
      case "error":
        var err = new Error("server error");
        err.code = packet.data;
        this.onError(err);
        break;
      case "message":
        this.emit("data", packet.data);
        this.emit("message", packet.data);
        break;
    }
  } else {
    debug$2('packet received with socket readyState "%s"', this.readyState);
  }
};
Socket$1.prototype.onHandshake = function(data2) {
  this.emit("handshake", data2);
  this.id = data2.sid;
  this.transport.query.sid = data2.sid;
  this.upgrades = this.filterUpgrades(data2.upgrades);
  this.pingInterval = data2.pingInterval;
  this.pingTimeout = data2.pingTimeout;
  this.onOpen();
  if ("closed" === this.readyState)
    return;
  this.setPing();
  this.removeListener("heartbeat", this.onHeartbeat);
  this.on("heartbeat", this.onHeartbeat);
};
Socket$1.prototype.onHeartbeat = function(timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self2 = this;
  self2.pingTimeoutTimer = setTimeout(function() {
    if ("closed" === self2.readyState)
      return;
    self2.onClose("ping timeout");
  }, timeout || self2.pingInterval + self2.pingTimeout);
};
Socket$1.prototype.setPing = function() {
  var self2 = this;
  clearTimeout(self2.pingIntervalTimer);
  self2.pingIntervalTimer = setTimeout(function() {
    debug$2("writing ping packet - expecting pong within %sms", self2.pingTimeout);
    self2.ping();
    self2.onHeartbeat(self2.pingTimeout);
  }, self2.pingInterval);
};
Socket$1.prototype.ping = function() {
  var self2 = this;
  this.sendPacket("ping", function() {
    self2.emit("ping");
  });
};
Socket$1.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen);
  this.prevBufferLen = 0;
  if (0 === this.writeBuffer.length) {
    this.emit("drain");
  } else {
    this.flush();
  }
};
Socket$1.prototype.flush = function() {
  if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
    debug$2("flushing %d packets in socket", this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    this.prevBufferLen = this.writeBuffer.length;
    this.emit("flush");
  }
};
Socket$1.prototype.write = Socket$1.prototype.send = function(msg, options2, fn) {
  this.sendPacket("message", msg, options2, fn);
  return this;
};
Socket$1.prototype.sendPacket = function(type, data2, options2, fn) {
  if ("function" === typeof data2) {
    fn = data2;
    data2 = void 0;
  }
  if ("function" === typeof options2) {
    fn = options2;
    options2 = null;
  }
  if ("closing" === this.readyState || "closed" === this.readyState) {
    return;
  }
  options2 = options2 || {};
  options2.compress = false !== options2.compress;
  var packet = {
    type,
    data: data2,
    options: options2
  };
  this.emit("packetCreate", packet);
  this.writeBuffer.push(packet);
  if (fn)
    this.once("flush", fn);
  this.flush();
};
Socket$1.prototype.close = function() {
  if ("opening" === this.readyState || "open" === this.readyState) {
    this.readyState = "closing";
    var self2 = this;
    if (this.writeBuffer.length) {
      this.once("drain", function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }
  function close() {
    self2.onClose("forced close");
    debug$2("socket closing - telling transport to close");
    self2.transport.close();
  }
  function cleanupAndClose() {
    self2.removeListener("upgrade", cleanupAndClose);
    self2.removeListener("upgradeError", cleanupAndClose);
    close();
  }
  function waitForUpgrade() {
    self2.once("upgrade", cleanupAndClose);
    self2.once("upgradeError", cleanupAndClose);
  }
  return this;
};
Socket$1.prototype.onError = function(err) {
  debug$2("socket error %j", err);
  Socket$1.priorWebsocketSuccess = false;
  this.emit("error", err);
  this.onClose("transport error", err);
};
Socket$1.prototype.onClose = function(reason, desc) {
  if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
    debug$2('socket close with reason: "%s"', reason);
    var self2 = this;
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);
    this.transport.removeAllListeners("close");
    this.transport.close();
    this.transport.removeAllListeners();
    this.readyState = "closed";
    this.id = null;
    this.emit("close", reason, desc);
    self2.writeBuffer = [];
    self2.prevBufferLen = 0;
  }
};
Socket$1.prototype.filterUpgrades = function(upgrades) {
  var filteredUpgrades = [];
  for (var i2 = 0, j = upgrades.length; i2 < j; i2++) {
    if (~index(this.transports, upgrades[i2]))
      filteredUpgrades.push(upgrades[i2]);
  }
  return filteredUpgrades;
};
lib$1.exports = socket$1;
lib$1.exports.parser = browser$4;
var libExports$2 = lib$1.exports;
var socket = { exports: {} };
var toArray_1 = toArray;
function toArray(list2, index2) {
  var array = [];
  index2 = index2 || 0;
  for (var i2 = index2 || 0; i2 < list2.length; i2++) {
    array[i2 - index2] = list2[i2];
  }
  return array;
}
var on_1 = on$1;
function on$1(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function() {
      obj.removeListener(ev, fn);
    }
  };
}
var slice = [].slice;
var componentBind = function(obj, fn) {
  if ("string" == typeof fn)
    fn = obj[fn];
  if ("function" != typeof fn)
    throw new Error("bind() requires a function");
  var args = slice.call(arguments, 2);
  return function() {
    return fn.apply(obj, args.concat(slice.call(arguments)));
  };
};
(function(module2, exports2) {
  var parser2 = socket_ioParser;
  var Emitter2 = componentEmitterExports;
  var toArray2 = toArray_1;
  var on2 = on_1;
  var bind3 = componentBind;
  var debug2 = browserExports$4("socket.io-client:socket");
  var parseqs2 = parseqs$3;
  var hasBin = hasBinary2;
  module2.exports = Socket2;
  var events2 = {
    connect: 1,
    connect_error: 1,
    connect_timeout: 1,
    connecting: 1,
    disconnect: 1,
    error: 1,
    reconnect: 1,
    reconnect_attempt: 1,
    reconnect_failed: 1,
    reconnect_error: 1,
    reconnecting: 1,
    ping: 1,
    pong: 1
  };
  var emit2 = Emitter2.prototype.emit;
  function Socket2(io2, nsp, opts) {
    this.io = io2;
    this.nsp = nsp;
    this.json = this;
    this.ids = 0;
    this.acks = {};
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.connected = false;
    this.disconnected = true;
    this.flags = {};
    if (opts && opts.query) {
      this.query = opts.query;
    }
    if (this.io.autoConnect)
      this.open();
  }
  Emitter2(Socket2.prototype);
  Socket2.prototype.subEvents = function() {
    if (this.subs)
      return;
    var io2 = this.io;
    this.subs = [
      on2(io2, "open", bind3(this, "onopen")),
      on2(io2, "packet", bind3(this, "onpacket")),
      on2(io2, "close", bind3(this, "onclose"))
    ];
  };
  Socket2.prototype.open = Socket2.prototype.connect = function() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io.reconnecting)
      this.io.open();
    if ("open" === this.io.readyState)
      this.onopen();
    this.emit("connecting");
    return this;
  };
  Socket2.prototype.send = function() {
    var args = toArray2(arguments);
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  };
  Socket2.prototype.emit = function(ev) {
    if (events2.hasOwnProperty(ev)) {
      emit2.apply(this, arguments);
      return this;
    }
    var args = toArray2(arguments);
    var packet = {
      type: (this.flags.binary !== void 0 ? this.flags.binary : hasBin(args)) ? parser2.BINARY_EVENT : parser2.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = !this.flags || false !== this.flags.compress;
    if ("function" === typeof args[args.length - 1]) {
      debug2("emitting packet with ack id %d", this.ids);
      this.acks[this.ids] = args.pop();
      packet.id = this.ids++;
    }
    if (this.connected) {
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  };
  Socket2.prototype.packet = function(packet) {
    packet.nsp = this.nsp;
    this.io.packet(packet);
  };
  Socket2.prototype.onopen = function() {
    debug2("transport is open - connecting");
    if ("/" !== this.nsp) {
      if (this.query) {
        var query = typeof this.query === "object" ? parseqs2.encode(this.query) : this.query;
        debug2("sending connect packet with query %s", query);
        this.packet({ type: parser2.CONNECT, query });
      } else {
        this.packet({ type: parser2.CONNECT });
      }
    }
  };
  Socket2.prototype.onclose = function(reason) {
    debug2("close (%s)", reason);
    this.connected = false;
    this.disconnected = true;
    delete this.id;
    this.emit("disconnect", reason);
  };
  Socket2.prototype.onpacket = function(packet) {
    var sameNamespace = packet.nsp === this.nsp;
    var rootNamespaceError = packet.type === parser2.ERROR && packet.nsp === "/";
    if (!sameNamespace && !rootNamespaceError)
      return;
    switch (packet.type) {
      case parser2.CONNECT:
        this.onconnect();
        break;
      case parser2.EVENT:
        this.onevent(packet);
        break;
      case parser2.BINARY_EVENT:
        this.onevent(packet);
        break;
      case parser2.ACK:
        this.onack(packet);
        break;
      case parser2.BINARY_ACK:
        this.onack(packet);
        break;
      case parser2.DISCONNECT:
        this.ondisconnect();
        break;
      case parser2.ERROR:
        this.emit("error", packet.data);
        break;
    }
  };
  Socket2.prototype.onevent = function(packet) {
    var args = packet.data || [];
    debug2("emitting event %j", args);
    if (null != packet.id) {
      debug2("attaching ack callback to event");
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      emit2.apply(this, args);
    } else {
      this.receiveBuffer.push(args);
    }
  };
  Socket2.prototype.ack = function(id2) {
    var self2 = this;
    var sent = false;
    return function() {
      if (sent)
        return;
      sent = true;
      var args = toArray2(arguments);
      debug2("sending ack %j", args);
      self2.packet({
        type: hasBin(args) ? parser2.BINARY_ACK : parser2.ACK,
        id: id2,
        data: args
      });
    };
  };
  Socket2.prototype.onack = function(packet) {
    var ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      debug2("calling ack %s with %j", packet.id, packet.data);
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
      debug2("bad ack %s", packet.id);
    }
  };
  Socket2.prototype.onconnect = function() {
    this.connected = true;
    this.disconnected = false;
    this.emitBuffered();
    this.emit("connect");
  };
  Socket2.prototype.emitBuffered = function() {
    var i2;
    for (i2 = 0; i2 < this.receiveBuffer.length; i2++) {
      emit2.apply(this, this.receiveBuffer[i2]);
    }
    this.receiveBuffer = [];
    for (i2 = 0; i2 < this.sendBuffer.length; i2++) {
      this.packet(this.sendBuffer[i2]);
    }
    this.sendBuffer = [];
  };
  Socket2.prototype.ondisconnect = function() {
    debug2("server disconnect (%s)", this.nsp);
    this.destroy();
    this.onclose("io server disconnect");
  };
  Socket2.prototype.destroy = function() {
    if (this.subs) {
      for (var i2 = 0; i2 < this.subs.length; i2++) {
        this.subs[i2].destroy();
      }
      this.subs = null;
    }
    this.io.destroy(this);
  };
  Socket2.prototype.close = Socket2.prototype.disconnect = function() {
    if (this.connected) {
      debug2("performing disconnect (%s)", this.nsp);
      this.packet({ type: parser2.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  };
  Socket2.prototype.compress = function(compress) {
    this.flags.compress = compress;
    return this;
  };
  Socket2.prototype.binary = function(binary2) {
    this.flags.binary = binary2;
    return this;
  };
})(socket);
var socketExports = socket.exports;
var backo2 = Backoff$1;
function Backoff$1(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff$1.prototype.duration = function() {
  var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms2);
    ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
  }
  return Math.min(ms2, this.max) | 0;
};
Backoff$1.prototype.reset = function() {
  this.attempts = 0;
};
Backoff$1.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff$1.prototype.setMax = function(max) {
  this.max = max;
};
Backoff$1.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
var eio = libExports$2;
var Socket = socketExports;
var Emitter = componentEmitterExports;
var parser = socket_ioParser;
var on = on_1;
var bind = componentBind;
var debug$1 = browserExports$4("socket.io-client:manager");
var indexOf = indexof;
var Backoff = backo2;
var has = Object.prototype.hasOwnProperty;
var manager = Manager;
function Manager(uri, opts) {
  if (!(this instanceof Manager))
    return new Manager(uri, opts);
  if (uri && "object" === typeof uri) {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  opts.path = opts.path || "/socket.io";
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1e3);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
  this.readyState = "closed";
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect)
    this.open();
}
Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};
Manager.prototype.updateSocketIds = function() {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};
Manager.prototype.generateId = function(nsp) {
  return (nsp === "/" ? "" : nsp + "#") + this.engine.id;
};
Emitter(Manager.prototype);
Manager.prototype.reconnection = function(v) {
  if (!arguments.length)
    return this._reconnection;
  this._reconnection = !!v;
  return this;
};
Manager.prototype.reconnectionAttempts = function(v) {
  if (!arguments.length)
    return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};
Manager.prototype.reconnectionDelay = function(v) {
  if (!arguments.length)
    return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};
Manager.prototype.randomizationFactor = function(v) {
  if (!arguments.length)
    return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};
Manager.prototype.reconnectionDelayMax = function(v) {
  if (!arguments.length)
    return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};
Manager.prototype.timeout = function(v) {
  if (!arguments.length)
    return this._timeout;
  this._timeout = v;
  return this;
};
Manager.prototype.maybeReconnectOnOpen = function() {
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    this.reconnect();
  }
};
Manager.prototype.open = Manager.prototype.connect = function(fn, opts) {
  debug$1("readyState %s", this.readyState);
  if (~this.readyState.indexOf("open"))
    return this;
  debug$1("opening %s", this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket2 = this.engine;
  var self2 = this;
  this.readyState = "opening";
  this.skipReconnect = false;
  var openSub = on(socket2, "open", function() {
    self2.onopen();
    fn && fn();
  });
  var errorSub = on(socket2, "error", function(data2) {
    debug$1("connect_error");
    self2.cleanup();
    self2.readyState = "closed";
    self2.emitAll("connect_error", data2);
    if (fn) {
      var err = new Error("Connection error");
      err.data = data2;
      fn(err);
    } else {
      self2.maybeReconnectOnOpen();
    }
  });
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug$1("connect attempt will timeout after %d", timeout);
    if (timeout === 0) {
      openSub.destroy();
    }
    var timer = setTimeout(function() {
      debug$1("connect attempt timed out after %d", timeout);
      openSub.destroy();
      socket2.close();
      socket2.emit("error", "timeout");
      self2.emitAll("connect_timeout", timeout);
    }, timeout);
    this.subs.push({
      destroy: function() {
        clearTimeout(timer);
      }
    });
  }
  this.subs.push(openSub);
  this.subs.push(errorSub);
  return this;
};
Manager.prototype.onopen = function() {
  debug$1("open");
  this.cleanup();
  this.readyState = "open";
  this.emit("open");
  var socket2 = this.engine;
  this.subs.push(on(socket2, "data", bind(this, "ondata")));
  this.subs.push(on(socket2, "ping", bind(this, "onping")));
  this.subs.push(on(socket2, "pong", bind(this, "onpong")));
  this.subs.push(on(socket2, "error", bind(this, "onerror")));
  this.subs.push(on(socket2, "close", bind(this, "onclose")));
  this.subs.push(on(this.decoder, "decoded", bind(this, "ondecoded")));
};
Manager.prototype.onping = function() {
  this.lastPing = /* @__PURE__ */ new Date();
  this.emitAll("ping");
};
Manager.prototype.onpong = function() {
  this.emitAll("pong", /* @__PURE__ */ new Date() - this.lastPing);
};
Manager.prototype.ondata = function(data2) {
  this.decoder.add(data2);
};
Manager.prototype.ondecoded = function(packet) {
  this.emit("packet", packet);
};
Manager.prototype.onerror = function(err) {
  debug$1("error", err);
  this.emitAll("error", err);
};
Manager.prototype.socket = function(nsp, opts) {
  var socket2 = this.nsps[nsp];
  if (!socket2) {
    socket2 = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket2;
    var self2 = this;
    socket2.on("connecting", onConnecting);
    socket2.on("connect", function() {
      socket2.id = self2.generateId(nsp);
    });
    if (this.autoConnect) {
      onConnecting();
    }
  }
  function onConnecting() {
    if (!~indexOf(self2.connecting, socket2)) {
      self2.connecting.push(socket2);
    }
  }
  return socket2;
};
Manager.prototype.destroy = function(socket2) {
  var index2 = indexOf(this.connecting, socket2);
  if (~index2)
    this.connecting.splice(index2, 1);
  if (this.connecting.length)
    return;
  this.close();
};
Manager.prototype.packet = function(packet) {
  debug$1("writing packet %j", packet);
  var self2 = this;
  if (packet.query && packet.type === 0)
    packet.nsp += "?" + packet.query;
  if (!self2.encoding) {
    self2.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i2 = 0; i2 < encodedPackets.length; i2++) {
        self2.engine.write(encodedPackets[i2], packet.options);
      }
      self2.encoding = false;
      self2.processPacketQueue();
    });
  } else {
    self2.packetBuffer.push(packet);
  }
};
Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};
Manager.prototype.cleanup = function() {
  debug$1("cleanup");
  var subsLength = this.subs.length;
  for (var i2 = 0; i2 < subsLength; i2++) {
    var sub = this.subs.shift();
    sub.destroy();
  }
  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;
  this.decoder.destroy();
};
Manager.prototype.close = Manager.prototype.disconnect = function() {
  debug$1("disconnect");
  this.skipReconnect = true;
  this.reconnecting = false;
  if ("opening" === this.readyState) {
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = "closed";
  if (this.engine)
    this.engine.close();
};
Manager.prototype.onclose = function(reason) {
  debug$1("onclose");
  this.cleanup();
  this.backoff.reset();
  this.readyState = "closed";
  this.emit("close", reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};
Manager.prototype.reconnect = function() {
  if (this.reconnecting || this.skipReconnect)
    return this;
  var self2 = this;
  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug$1("reconnect failed");
    this.backoff.reset();
    this.emitAll("reconnect_failed");
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug$1("will wait %dms before reconnect attempt", delay);
    this.reconnecting = true;
    var timer = setTimeout(function() {
      if (self2.skipReconnect)
        return;
      debug$1("attempting reconnect");
      self2.emitAll("reconnect_attempt", self2.backoff.attempts);
      self2.emitAll("reconnecting", self2.backoff.attempts);
      if (self2.skipReconnect)
        return;
      self2.open(function(err) {
        if (err) {
          debug$1("reconnect attempt error");
          self2.reconnecting = false;
          self2.reconnect();
          self2.emitAll("reconnect_error", err.data);
        } else {
          debug$1("reconnect success");
          self2.onreconnect();
        }
      });
    }, delay);
    this.subs.push({
      destroy: function() {
        clearTimeout(timer);
      }
    });
  }
};
Manager.prototype.onreconnect = function() {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll("reconnect", attempt);
};
(function(module2, exports2) {
  var url2 = url_1;
  var parser2 = socket_ioParser;
  var Manager2 = manager;
  var debug2 = browserExports$4("socket.io-client");
  module2.exports = exports2 = lookup10;
  var cache2 = exports2.managers = {};
  function lookup10(uri, opts) {
    if (typeof uri === "object") {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    var parsed = url2(uri);
    var source = parsed.source;
    var id2 = parsed.id;
    var path2 = parsed.path;
    var sameNamespace = cache2[id2] && path2 in cache2[id2].nsps;
    var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
    var io2;
    if (newConnection) {
      debug2("ignoring socket cache for %s", source);
      io2 = Manager2(source, opts);
    } else {
      if (!cache2[id2]) {
        debug2("new io instance for %s", source);
        cache2[id2] = Manager2(source, opts);
      }
      io2 = cache2[id2];
    }
    if (parsed.query && !opts.query) {
      opts.query = parsed.query;
    }
    return io2.socket(parsed.path, opts);
  }
  exports2.protocol = parser2.protocol;
  exports2.connect = lookup10;
  exports2.Manager = manager;
  exports2.Socket = socketExports;
})(lib$2, lib$2.exports);
var libExports$1 = lib$2.exports;
const io = /* @__PURE__ */ getDefaultExportFromCjs(libExports$1);
var browser$2 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w = d2 * 7;
  var y2 = d2 * 365.25;
  ms = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = requireMs();
  createDebug.destroy = destroy2;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index2++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend3;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend3(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len2 = split.length;
    for (i2 = 0; i2 < len2; i2++) {
      if (!split[i2]) {
        continue;
      }
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i2;
    let len2;
    for (i2 = 0, len2 = createDebug.skips.length; i2 < len2; i2++) {
      if (createDebug.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len2 = createDebug.names.length; i2 < len2; i2++) {
      if (createDebug.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy2() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common = setup;
(function(module2, exports2) {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error2) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error2) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = {}.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {
    }
  }
  module2.exports = common(exports2);
  const { formatters } = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
})(browser$2, browser$2.exports);
var browserExports$1 = browser$2.exports;
var getBrowserRtc = function getBrowserRTC2() {
  if (typeof globalThis === "undefined")
    return null;
  var wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
  };
  if (!wrtc.RTCPeerConnection)
    return null;
  return wrtc;
};
var browser$1 = { exports: {} };
var safeBuffer = { exports: {} };
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup$1 = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
  lookup$1[i$1] = code[i$1];
  revLookup[code.charCodeAt(i$1)] = i$1;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr2[curByte++] = tmp >> 16 & 255;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  return arr2;
}
function tripletToBase64(num) {
  return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output3 = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output3.push(tripletToBase64(tmp));
  }
  return output3.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts2 = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts2.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts2.push(
      lookup$1[tmp >> 2] + lookup$1[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts2.push(
      lookup$1[tmp >> 10] + lookup$1[tmp >> 4 & 63] + lookup$1[tmp << 2 & 63] + "="
    );
  }
  return parts2.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset2 + i2];
  i2 += d2;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i2] = e & 255, i2 += d2, e /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i2 - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr2 = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr2, proto);
      return arr2.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length2);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg2, encodingOrOffset, length2) {
    if (typeof arg2 === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg2);
    }
    return from(arg2, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b = fromObject(value);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length2 = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length2);
    const actual = buf.write(string, encoding);
    if (actual !== length2) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length2);
    for (let i2 = 0; i2 < length2; i2 += 1) {
      buf[i2] = array[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length2) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length2 === void 0) {
      buf = new Uint8Array(array);
    } else if (length2 === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length2);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf = createBuffer(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer4(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a2, b) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b)
      return 0;
    let x2 = a2.length;
    let y2 = b.length;
    for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a2[i2] !== b[i2]) {
        x2 = a2[i2];
        y2 = b[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list2, length2) {
    if (!Array.isArray(list2)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list2.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length2 === void 0) {
      length2 = 0;
      for (i2 = 0; i2 < list2.length; ++i2) {
        length2 += list2[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i2 = 0; i2 < list2.length; ++i2) {
      let buf = list2[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len2 = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n, m2) {
    const i2 = b[n];
    b[n] = b[m2];
    b[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    let str = "";
    const max = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len2 = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr2.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr2, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read2(arr2, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset2, length2) {
    offset2 = Number(offset2) || 0;
    const remaining = buf.length - offset2;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      const parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset2 + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset2, length2) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length2);
  }
  function asciiWrite(buf, string, offset2, length2) {
    return blitBuffer(asciiToBytes(string), buf, offset2, length2);
  }
  function base64Write(buf, string, offset2, length2) {
    return blitBuffer(base64ToBytes(string), buf, offset2, length2);
  }
  function ucs2Write(buf, string, offset2, length2) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length2);
  }
  Buffer2.prototype.write = function write(string, offset2, length2, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset2 = 0;
    } else if (length2 === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length2 = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset2;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset2, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset2, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset2, length2);
        case "base64":
          return base64Write(this, string, offset2, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset2, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i2 = start;
    while (i2 < end) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len2 = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len2)
      end = len2;
    let out = "";
    for (let i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end) {
    const len2 = this.length;
    start = ~~start;
    end = end === void 0 ? len2 : ~~end;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0)
        end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length2) {
    if (offset2 % 1 !== 0 || offset2 < 0)
      throw new RangeError("offset is not uint");
    if (offset2 + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset2 + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last2 = this[offset2 + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last2 = this[offset2 + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last2;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let i2 = byteLength3;
    let mul = 1;
    let val = this[offset2 + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset2 + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128))
      return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last2 = this[offset2 + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last2 = this[offset2 + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value, offset2, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i2 = 0;
    this[offset2] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset2 + i2] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    this[offset2 + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset2 + i2] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf, value, offset2, min, max) {
    checkIntBI(value, min, max, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    return offset2;
  }
  function wrtBigUInt64BE(buf, value, offset2, min, max) {
    checkIntBI(value, min, max, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2 + 7] = lo;
    lo = lo >> 8;
    buf[offset2 + 6] = lo;
    lo = lo >> 8;
    buf[offset2 + 5] = lo;
    lo = lo >> 8;
    buf[offset2 + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2 + 3] = hi;
    hi = hi >> 8;
    buf[offset2 + 2] = hi;
    hi = hi >> 8;
    buf[offset2 + 1] = hi;
    hi = hi >> 8;
    buf[offset2] = hi;
    return offset2 + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul = 1;
    let sub = 0;
    this[offset2] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset2 + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset2, ext, max, min) {
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset2 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, false, noAssert);
  };
  function writeDouble(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes[i2 % len2];
      }
    }
    return this;
  };
  const errors = {};
  function E(sym, getMessage2, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage2.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset2, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset2, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length2, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length2}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray2 = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray2.push(str.charCodeAt(i2) & 255);
    }
    return byteArray2;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray2 = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i2);
      hi = c >> 8;
      lo = c % 256;
      byteArray2.push(lo);
      byteArray2.push(hi);
    }
    return byteArray2;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset2, length2) {
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      if (i2 + offset2 >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset2] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet2[i2] + alphabet2[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module2, exports2) {
  var buffer$1 = buffer;
  var Buffer2 = buffer$1.Buffer;
  function copyProps(src2, dst) {
    for (var key in src2) {
      dst[key] = src2[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer$1;
  } else {
    copyProps(buffer$1, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg2, encodingOrOffset, length2) {
    return Buffer2(arg2, encodingOrOffset, length2);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg2, encodingOrOffset, length2) {
    if (typeof arg2 === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg2, encodingOrOffset, length2);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer$1.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var MAX_BYTES = 65536;
var MAX_UINT32 = 4294967295;
function oldBrowser() {
  throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
}
var Buffer$2 = safeBufferExports.Buffer;
var crypto$1 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
if (crypto$1 && crypto$1.getRandomValues) {
  browser$1.exports = randomBytes;
} else {
  browser$1.exports = oldBrowser;
}
function randomBytes(size, cb) {
  if (size > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var bytes = Buffer$2.allocUnsafe(size);
  if (size > 0) {
    if (size > MAX_BYTES) {
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        crypto$1.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
      }
    } else {
      crypto$1.getRandomValues(bytes);
    }
  }
  if (typeof cb === "function") {
    return process.nextTick(function() {
      cb(null, bytes);
    });
  }
  return bytes;
}
var browserExports = browser$1.exports;
var readableBrowser = { exports: {} };
var streamBrowser = eventsExports.EventEmitter;
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys2(object, enumerableOnly) {
    var keys3 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck2(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties2(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
    }
  }
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties2(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties2(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey2(arg2) {
    var key = _toPrimitive2(arg2, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var _require2 = buffer, Buffer2 = _require2.Buffer;
  var _require22 = require$$3, inspect2 = _require22.inspect;
  var custom = inspect2 && inspect2.custom || "inspect";
  function copyBuffer(src2, target, offset2) {
    Buffer2.prototype.copy.call(src2, target, offset2);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck2(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass2(BufferList, [{
      key: "push",
      value: function push2(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next)
          ret += s2 + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i2 = 0;
        while (p) {
          copyBuffer(p.data, ret, i2);
          i2 += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_23, options2) {
        return inspect2(this, _objectSpread2(_objectSpread2({}, options2), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return buffer_list;
}
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function(err2) {
    if (!cb && err2) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err2);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err) {
  emitErrorNT(self2, err);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose)
    return;
  if (self2._readableState && !self2._readableState.emitClose)
    return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err) {
  self2.emit("error", err);
}
function errorOrDestroy(stream2, err) {
  var rState = stream2._readableState;
  var wState = stream2._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
    stream2.destroy(err);
  else
    stream2.emit("error", err);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code2, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage2(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /* @__PURE__ */ function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage2(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base);
  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code2;
  codes[code2] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len2 = expected.length;
    expected = expected.map(function(i2) {
      return String(i2);
    });
    if (len2 > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
    } else if (len2 === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes(str, search, start) {
  if (typeof start !== "number") {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg;
  if (endsWith(name, " argument")) {
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type = includes(name, ".") ? "property" : "argument";
    msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
  return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
  return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg2) {
  return "Unknown encoding: " + arg2;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options2, isDuplex, duplexKey) {
  return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
}
function getHighWaterMark(state2, options2, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
const inherits = /* @__PURE__ */ getDefaultExportFromCjs(inherits_browserExports);
var browser = deprecate;
function deprecate(fn, msg) {
  if (config("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config("throwDeprecation")) {
        throw new Error(msg);
      } else if (config("traceDeprecation")) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config(name) {
  try {
    if (!commonjsGlobal.localStorage)
      return false;
  } catch (_23) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name];
  if (null == val)
    return false;
  return String(val).toLowerCase() === "true";
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex2;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: browser
  };
  var Stream = streamBrowser;
  var Buffer2 = buffer.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = destroy_1;
  var _require2 = state, getHighWaterMark2 = _require2.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK2 = _require$codes2.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes2.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED2 = _require$codes2.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes2.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes2.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes2.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  inherits_browserExports(Writable, Stream);
  function nop() {
  }
  function WritableState(options2, stream2, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options2.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options2.writableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options2, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options2.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current2 = this.bufferedRequest;
    var out = [];
    while (current2) {
      out.push(current2);
      current2 = current2.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_23) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options2) {
    Duplex2 = Duplex2 || require_stream_duplex();
    var isDuplex = this instanceof Duplex2;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options2);
    this._writableState = new WritableState(options2, this, isDuplex);
    this.writable = true;
    if (options2) {
      if (typeof options2.write === "function")
        this._write = options2.write;
      if (typeof options2.writev === "function")
        this._writev = options2.writev;
      if (typeof options2.destroy === "function")
        this._destroy = options2.destroy;
      if (typeof options2.final === "function")
        this._final = options2.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy2(stream2, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy2(stream2, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf2 = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf2 && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf2)
      encoding = "buffer";
    else if (!encoding)
      encoding = state2.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state2.ending)
      writeAfterEnd(this, cb);
    else if (isBuf2 || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf2, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
        clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf2, chunk, encoding, cb) {
    if (!isBuf2) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf2 = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len2 = state2.objectMode ? 1 : chunk.length;
    state2.length += len2;
    var ret = state2.length < state2.highWaterMark;
    if (!ret)
      state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last2 = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf: isBuf2,
        callback: cb,
        next: null
      };
      if (last2) {
        last2.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len2, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len2, chunk, encoding, cb) {
    state2.writelen = len2;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed)
      state2.onwrite(new ERR_STREAM_DESTROYED2("write"));
    else if (writev)
      stream2._writev(chunk, state2.onwrite);
    else
      stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy2(stream2, er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy2(stream2, er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK2();
    onwriteStateUpdate(state2);
    if (er)
      onwriteError(stream2, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream2.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync) {
        process.nextTick(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished)
      onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len2 = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len2, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null)
        state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED2("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending)
      endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy2(stream2, err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish2(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish2(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream2._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream2.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished)
        process.nextTick(cb);
      else
        stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys2 = Object.keys || function(obj) {
    var keys4 = [];
    for (var key in obj)
      keys4.push(key);
    return keys4;
  };
  _stream_duplex = Duplex2;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  inherits_browserExports(Duplex2, Readable);
  {
    var keys3 = objectKeys2(Writable.prototype);
    for (var v = 0; v < keys3.length; v++) {
      var method = keys3[v];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex2(options2) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options2);
    Readable.call(this, options2);
    Writable.call(this, options2);
    this.allowHalfOpen = true;
    if (options2) {
      if (options2.readable === false)
        this.readable = false;
      if (options2.writable === false)
        this.writable = false;
      if (options2.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = safeBufferExports.Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i2;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0)
        return "";
      i2 = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i2 = 0;
    }
    if (i2 < buf.length)
      return r ? r + this.text(buf, i2) : this.text(buf, i2);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i2) {
    var j = buf.length - 1;
    if (j < i2)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i2 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i2 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "ÔøΩ";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "ÔøΩ";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "ÔøΩ";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i2) {
    var total = utf8CheckIncomplete(this, buf, i2);
    if (!this.lastNeed)
      return buf.toString("utf8", i2);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i2, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "ÔøΩ";
    return r;
  }
  function utf16Text(buf, i2) {
    if ((buf.length - i2) % 2 === 0) {
      var r = buf.toString("utf16le", i2);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i2, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i2) {
    var n = (buf.length - i2) % 3;
    if (n === 0)
      return buf.toString("base64", i2);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i2, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback2) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback2.apply(this, args);
  };
}
function noop$1() {
}
function isRequest$1(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function eos$1(stream2, opts, callback2) {
  if (typeof opts === "function")
    return eos$1(stream2, null, opts);
  if (!opts)
    opts = {};
  callback2 = once$1(callback2 || noop$1);
  var readable = opts.readable || opts.readable !== false && stream2.readable;
  var writable = opts.writable || opts.writable !== false && stream2.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream2.writable)
      onfinish();
  };
  var writableEnded = stream2._writableState && stream2._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable)
      callback2.call(stream2);
  };
  var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
  var onend = function onend2() {
    readable = false;
    readableEnded = true;
    if (!writable)
      callback2.call(stream2);
  };
  var onerror = function onerror2(err) {
    callback2.call(stream2, err);
  };
  var onclose = function onclose2() {
    var err;
    if (readable && !readableEnded) {
      if (!stream2._readableState || !stream2._readableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback2.call(stream2, err);
    }
    if (writable && !writableEnded) {
      if (!stream2._writableState || !stream2._writableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback2.call(stream2, err);
    }
  };
  var onrequest = function onrequest2() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req)
      onrequest();
    else
      stream2.on("request", onrequest);
  } else if (writable && !stream2._writableState) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  stream2.on("end", onend);
  stream2.on("finish", onfinish);
  if (opts.error !== false)
    stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req)
      stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("end", onend);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty2(obj, key, value) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey2(arg2) {
    var key = _toPrimitive2(arg2, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done2) {
    return {
      value,
      done: done2
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error2 = this[kError];
      if (error2 !== null) {
        return Promise.reject(error2);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise2;
      if (lastPromise) {
        promise2 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise2 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise2;
      return promise2;
    }
  }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty2(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty2(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty2(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser)
    return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex2;
  Readable.ReadableState = ReadableState;
  eventsExports.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = streamBrowser;
  var Buffer2 = buffer.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$3;
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug3() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = destroy_1;
  var _require2 = state, getHighWaterMark2 = _require2.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes2.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  inherits_browserExports(Readable, Stream);
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options2, stream2, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream2 instanceof Duplex2;
    this.objectMode = !!options2.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options2.readableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options2, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options2.encoding) {
      if (!StringDecoder)
        StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options2.encoding);
      this.encoding = options2.encoding;
    }
  }
  function Readable(options2) {
    Duplex2 = Duplex2 || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options2);
    var isDuplex = this instanceof Duplex2;
    this._readableState = new ReadableState(options2, this, isDuplex);
    this.readable = true;
    if (options2) {
      if (typeof options2.read === "function")
        this._read = options2.read;
      if (typeof options2.destroy === "function")
        this._destroy = options2.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy2(stream2, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted)
            errorOrDestroy2(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy2(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0)
              addChunk(stream2, state2, chunk, false);
            else
              maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream2, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream2.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront)
        state2.buffer.unshift(chunk);
      else
        state2.buffer.push(chunk);
      if (state2.needReadable)
        emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended)
      return 0;
    if (state2.objectMode)
      return 1;
    if (n !== n) {
      if (state2.flowing && state2.length)
        return state2.buffer.head.data.length;
      else
        return state2.length;
    }
    if (n > state2.highWaterMark)
      state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length)
      return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0)
        state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading)
        n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state2);
    else
      ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended)
        state2.needReadable = true;
      if (nOrig !== n && state2.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    debug2("onEofChunk");
    if (state2.ended)
      return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream2);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream2);
      }
    }
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream2);
    }
  }
  function emitReadable_(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream2.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len2 = state2.length;
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len2 === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy2(this, new ERR_METHOD_NOT_IMPLEMENTED2("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted)
      process.nextTick(endFn);
    else
      src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug2("onunpipe");
      if (readable === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy2(dest, er);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain)
        state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0)
      return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes)
        return this;
      if (!dest)
        dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len2 = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i2 = 0; i2 < len2; i2++)
        dests[i2].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1)
      return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1)
      state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug2("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    debug2("resume", state2.reading);
    if (!state2.reading) {
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading)
      stream2.read(0);
  }
  Readable.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder)
        chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state2.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i2 in stream2) {
      if (this[i2] === void 0 && typeof stream2[i2] === "function") {
        this[i2] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream2[method].apply(stream2, arguments);
          };
        }(i2);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0)
      return null;
    var ret;
    if (state2.objectMode)
      ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder)
        ret = state2.buffer.join("");
      else if (state2.buffer.length === 1)
        ret = state2.buffer.first();
      else
        ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    debug2("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
      if (state2.autoDestroy) {
        var wState = stream2._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream2.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFromBrowser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf2(xs, x2) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x2)
        return i2;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1;
var _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require_stream_duplex();
inherits_browserExports(Transform$1, Duplex);
function afterTransform(er, data2) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$1(options2) {
  if (!(this instanceof Transform$1))
    return new Transform$1(options2);
  Duplex.call(this, options2);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options2) {
    if (typeof options2.transform === "function")
      this._transform = options2.transform;
    if (typeof options2.flush === "function")
      this._flush = options2.flush;
  }
  this.on("prefinish", prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data2) {
      done(_this, er, data2);
    });
  } else {
    done(this, null, null);
  }
}
Transform$1.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$1.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$1.prototype._destroy = function(err, cb) {
  Duplex.prototype._destroy.call(this, err, function(err2) {
    cb(err2);
  });
};
function done(stream2, er, data2) {
  if (er)
    return stream2.emit("error", er);
  if (data2 != null)
    stream2.push(data2);
  if (stream2._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream2._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream2.push(null);
}
var _stream_passthrough = PassThrough;
var Transform = _stream_transform;
inherits_browserExports(PassThrough, Transform);
function PassThrough(options2) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options2);
  Transform.call(this, options2);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once(callback2) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    callback2.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  if (err)
    throw err;
}
function isRequest(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function destroyer(stream2, reading, writing, callback2) {
  callback2 = once(callback2);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  if (eos === void 0)
    eos = endOfStream;
  eos(stream2, {
    readable: reading,
    writable: writing
  }, function(err) {
    if (err)
      return callback2(err);
    closed = true;
    callback2();
  });
  var destroyed = false;
  return function(err) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isRequest(stream2))
      return stream2.abort();
    if (typeof stream2.destroy === "function")
      return stream2.destroy();
    callback2(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length)
    return noop;
  if (typeof streams[streams.length - 1] !== "function")
    return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback2 = popCallback(streams);
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error2;
  var destroys = streams.map(function(stream2, i2) {
    var reading = i2 < streams.length - 1;
    var writing = i2 > 0;
    return destroyer(stream2, reading, writing, function(err) {
      if (!error2)
        error2 = err;
      if (err)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback2(error2);
    });
  });
  return streams.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(module2, exports2) {
  exports2 = module2.exports = require_stream_readable();
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = require_stream_writable();
  exports2.Duplex = require_stream_duplex();
  exports2.Transform = _stream_transform;
  exports2.PassThrough = _stream_passthrough;
  exports2.finished = endOfStream;
  exports2.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise;
var queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
  throw err;
}, 0));
function assign(obj, props) {
  for (const key in props) {
    Object.defineProperty(obj, key, {
      value: props[key],
      enumerable: true,
      configurable: true
    });
  }
  return obj;
}
function createError(err, code2, props) {
  if (!err || typeof err === "string") {
    throw new TypeError("Please pass an Error to err-code");
  }
  if (!props) {
    props = {};
  }
  if (typeof code2 === "object") {
    props = code2;
    code2 = "";
  }
  if (code2) {
    props.code = code2;
  }
  try {
    return assign(err, props);
  } catch (_23) {
    props.message = err.message;
    props.stack = err.stack;
    const ErrClass = function() {
    };
    ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
    const output3 = assign(new ErrClass(), props);
    return output3;
  }
}
var errCode$1 = createError;
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const debug = browserExports$1("simple-peer");
const getBrowserRTC = getBrowserRtc;
const randombytes = browserExports;
const stream = readableBrowserExports;
const queueMicrotask$1 = queueMicrotask_1;
const errCode = errCode$1;
const { Buffer: Buffer$1 } = buffer;
const MAX_BUFFERED_AMOUNT = 64 * 1024;
const ICECOMPLETE_TIMEOUT = 5 * 1e3;
const CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
function filterTrickle(sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, "");
}
function warn(message) {
  console.warn(message);
}
class Peer extends stream.Duplex {
  constructor(opts) {
    opts = Object.assign({
      allowHalfOpen: false
    }, opts);
    super(opts);
    this._id = randombytes(4).toString("hex").slice(0, 7);
    this._debug("new peer %o", opts);
    this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
    this.initiator = opts.initiator || false;
    this.channelConfig = opts.channelConfig || Peer.channelConfig;
    this.channelNegotiated = this.channelConfig.negotiated;
    this.config = Object.assign({}, Peer.config, opts.config);
    this.offerOptions = opts.offerOptions || {};
    this.answerOptions = opts.answerOptions || {};
    this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
    this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
    this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
    this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
    this.destroyed = false;
    this.destroying = false;
    this._connected = false;
    this.remoteAddress = void 0;
    this.remoteFamily = void 0;
    this.remotePort = void 0;
    this.localAddress = void 0;
    this.localFamily = void 0;
    this.localPort = void 0;
    this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
    if (!this._wrtc) {
      if (typeof window === "undefined") {
        throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
      } else {
        throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
      }
    }
    this._pcReady = false;
    this._channelReady = false;
    this._iceComplete = false;
    this._iceCompleteTimer = null;
    this._channel = null;
    this._pendingCandidates = [];
    this._isNegotiating = false;
    this._firstNegotiation = true;
    this._batchedNegotiation = false;
    this._queuedNegotiation = false;
    this._sendersAwaitingStable = [];
    this._senderMap = /* @__PURE__ */ new Map();
    this._closingInterval = null;
    this._remoteTracks = [];
    this._remoteStreams = [];
    this._chunk = null;
    this._cb = null;
    this._interval = null;
    try {
      this._pc = new this._wrtc.RTCPeerConnection(this.config);
    } catch (err) {
      this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR"));
      return;
    }
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange();
    };
    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange();
    };
    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange();
    };
    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange();
    };
    this._pc.onicecandidate = (event) => {
      this._onIceCandidate(event);
    };
    if (typeof this._pc.peerIdentity === "object") {
      this._pc.peerIdentity.catch((err) => {
        this.destroy(errCode(err, "ERR_PC_PEER_IDENTITY"));
      });
    }
    if (this.initiator || this.channelNegotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      });
    } else {
      this._pc.ondatachannel = (event) => {
        this._setupData(event);
      };
    }
    if (this.streams) {
      this.streams.forEach((stream2) => {
        this.addStream(stream2);
      });
    }
    this._pc.ontrack = (event) => {
      this._onTrack(event);
    };
    this._debug("initial negotiation");
    this._needsNegotiation();
    this._onFinishBound = () => {
      this._onFinish();
    };
    this.once("finish", this._onFinishBound);
  }
  get bufferSize() {
    return this._channel && this._channel.bufferedAmount || 0;
  }
  // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
  get connected() {
    return this._connected && this._channel.readyState === "open";
  }
  address() {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress };
  }
  signal(data2) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
    if (typeof data2 === "string") {
      try {
        data2 = JSON.parse(data2);
      } catch (err) {
        data2 = {};
      }
    }
    this._debug("signal()");
    if (data2.renegotiate && this.initiator) {
      this._debug("got request to renegotiate");
      this._needsNegotiation();
    }
    if (data2.transceiverRequest && this.initiator) {
      this._debug("got request for transceiver");
      this.addTransceiver(data2.transceiverRequest.kind, data2.transceiverRequest.init);
    }
    if (data2.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data2.candidate);
      } else {
        this._pendingCandidates.push(data2.candidate);
      }
    }
    if (data2.sdp) {
      this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data2)).then(() => {
        if (this.destroyed)
          return;
        this._pendingCandidates.forEach((candidate) => {
          this._addIceCandidate(candidate);
        });
        this._pendingCandidates = [];
        if (this._pc.remoteDescription.type === "offer")
          this._createAnswer();
      }).catch((err) => {
        this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
      });
    }
    if (!data2.sdp && !data2.candidate && !data2.renegotiate && !data2.transceiverRequest) {
      this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
    }
  }
  _addIceCandidate(candidate) {
    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
    this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
      if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
        warn("Ignoring unsupported ICE candidate.");
      } else {
        this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
      }
    });
  }
  /**
   * Send text/binary data to the remote peer.
   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
   */
  send(chunk) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
    this._channel.send(chunk);
  }
  /**
   * Add a Transceiver to the connection.
   * @param {String} kind
   * @param {Object} init
   */
  addTransceiver(kind, init) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
    this._debug("addTransceiver()");
    if (this.initiator) {
      try {
        this._pc.addTransceiver(kind, init);
        this._needsNegotiation();
      } catch (err) {
        this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
      }
    } else {
      this.emit("signal", {
        // request initiator to renegotiate
        type: "transceiverRequest",
        transceiverRequest: { kind, init }
      });
    }
  }
  /**
   * Add a MediaStream to the connection.
   * @param {MediaStream} stream
   */
  addStream(stream2) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
    this._debug("addStream()");
    stream2.getTracks().forEach((track) => {
      this.addTrack(track, stream2);
    });
  }
  /**
   * Add a MediaStreamTrack to the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  addTrack(track, stream2) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
    this._debug("addTrack()");
    const submap = this._senderMap.get(track) || /* @__PURE__ */ new Map();
    let sender = submap.get(stream2);
    if (!sender) {
      sender = this._pc.addTrack(track, stream2);
      submap.set(stream2, sender);
      this._senderMap.set(track, submap);
      this._needsNegotiation();
    } else if (sender.removed) {
      throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
    } else {
      throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
    }
  }
  /**
   * Replace a MediaStreamTrack by another in the connection.
   * @param {MediaStreamTrack} oldTrack
   * @param {MediaStreamTrack} newTrack
   * @param {MediaStream} stream
   */
  replaceTrack(oldTrack, newTrack, stream2) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
    this._debug("replaceTrack()");
    const submap = this._senderMap.get(oldTrack);
    const sender = submap ? submap.get(stream2) : null;
    if (!sender) {
      throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
    }
    if (newTrack)
      this._senderMap.set(newTrack, submap);
    if (sender.replaceTrack != null) {
      sender.replaceTrack(newTrack);
    } else {
      this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
    }
  }
  /**
   * Remove a MediaStreamTrack from the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  removeTrack(track, stream2) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
    this._debug("removeSender()");
    const submap = this._senderMap.get(track);
    const sender = submap ? submap.get(stream2) : null;
    if (!sender) {
      throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
    }
    try {
      sender.removed = true;
      this._pc.removeTrack(sender);
    } catch (err) {
      if (err.name === "NS_ERROR_UNEXPECTED") {
        this._sendersAwaitingStable.push(sender);
      } else {
        this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
      }
    }
    this._needsNegotiation();
  }
  /**
   * Remove a MediaStream from the connection.
   * @param {MediaStream} stream
   */
  removeStream(stream2) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
    this._debug("removeSenders()");
    stream2.getTracks().forEach((track) => {
      this.removeTrack(track, stream2);
    });
  }
  _needsNegotiation() {
    this._debug("_needsNegotiation");
    if (this._batchedNegotiation)
      return;
    this._batchedNegotiation = true;
    queueMicrotask$1(() => {
      this._batchedNegotiation = false;
      if (this.initiator || !this._firstNegotiation) {
        this._debug("starting batched negotiation");
        this.negotiate();
      } else {
        this._debug("non-initiator initial negotiation request discarded");
      }
      this._firstNegotiation = false;
    });
  }
  negotiate() {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;
        this._debug("already negotiating, queueing");
      } else {
        this._debug("start negotiation");
        setTimeout(() => {
          this._createOffer();
        }, 0);
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;
        this._debug("already negotiating, queueing");
      } else {
        this._debug("requesting negotiation from initiator");
        this.emit("signal", {
          // request initiator to renegotiate
          type: "renegotiate",
          renegotiate: true
        });
      }
    }
    this._isNegotiating = true;
  }
  // TODO: Delete this method once readable-stream is updated to contain a default
  // implementation of destroy() that automatically calls _destroy()
  // See: https://github.com/nodejs/readable-stream/issues/283
  destroy(err) {
    this._destroy(err, () => {
    });
  }
  _destroy(err, cb) {
    if (this.destroyed || this.destroying)
      return;
    this.destroying = true;
    this._debug("destroying (error: %s)", err && (err.message || err));
    queueMicrotask$1(() => {
      this.destroyed = true;
      this.destroying = false;
      this._debug("destroy (error: %s)", err && (err.message || err));
      this.readable = this.writable = false;
      if (!this._readableState.ended)
        this.push(null);
      if (!this._writableState.finished)
        this.end();
      this._connected = false;
      this._pcReady = false;
      this._channelReady = false;
      this._remoteTracks = null;
      this._remoteStreams = null;
      this._senderMap = null;
      clearInterval(this._closingInterval);
      this._closingInterval = null;
      clearInterval(this._interval);
      this._interval = null;
      this._chunk = null;
      this._cb = null;
      if (this._onFinishBound)
        this.removeListener("finish", this._onFinishBound);
      this._onFinishBound = null;
      if (this._channel) {
        try {
          this._channel.close();
        } catch (err2) {
        }
        this._channel.onmessage = null;
        this._channel.onopen = null;
        this._channel.onclose = null;
        this._channel.onerror = null;
      }
      if (this._pc) {
        try {
          this._pc.close();
        } catch (err2) {
        }
        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ontrack = null;
        this._pc.ondatachannel = null;
      }
      this._pc = null;
      this._channel = null;
      if (err)
        this.emit("error", err);
      this.emit("close");
      cb();
    });
  }
  _setupData(event) {
    if (!event.channel) {
      return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
    }
    this._channel = event.channel;
    this._channel.binaryType = "arraybuffer";
    if (typeof this._channel.bufferedAmountLowThreshold === "number") {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
    }
    this.channelName = this._channel.label;
    this._channel.onmessage = (event2) => {
      this._onChannelMessage(event2);
    };
    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow();
    };
    this._channel.onopen = () => {
      this._onChannelOpen();
    };
    this._channel.onclose = () => {
      this._onChannelClose();
    };
    this._channel.onerror = (event2) => {
      const err = event2.error instanceof Error ? event2.error : new Error(`Datachannel error: ${event2.message} ${event2.filename}:${event2.lineno}:${event2.colno}`);
      this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
    };
    let isClosing = false;
    this._closingInterval = setInterval(() => {
      if (this._channel && this._channel.readyState === "closing") {
        if (isClosing)
          this._onChannelClose();
        isClosing = true;
      } else {
        isClosing = false;
      }
    }, CHANNEL_CLOSING_TIMEOUT);
  }
  _read() {
  }
  _write(chunk, encoding, cb) {
    if (this.destroyed)
      return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
    if (this._connected) {
      try {
        this.send(chunk);
      } catch (err) {
        return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
      }
      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
        this._cb = cb;
      } else {
        cb(null);
      }
    } else {
      this._debug("write before connect");
      this._chunk = chunk;
      this._cb = cb;
    }
  }
  // When stream finishes writing, close socket. Half open connections are not
  // supported.
  _onFinish() {
    if (this.destroyed)
      return;
    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1e3);
    };
    if (this._connected) {
      destroySoon();
    } else {
      this.once("connect", destroySoon);
    }
  }
  _startIceCompleteTimeout() {
    if (this.destroyed)
      return;
    if (this._iceCompleteTimer)
      return;
    this._debug("started iceComplete timeout");
    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true;
        this._debug("iceComplete timeout completed");
        this.emit("iceTimeout");
        this.emit("_iceComplete");
      }
    }, this.iceCompleteTimeout);
  }
  _createOffer() {
    if (this.destroyed)
      return;
    this._pc.createOffer(this.offerOptions).then((offer) => {
      if (this.destroyed)
        return;
      if (!this.trickle && !this.allowHalfTrickle)
        offer.sdp = filterTrickle(offer.sdp);
      offer.sdp = this.sdpTransform(offer.sdp);
      const sendOffer = () => {
        if (this.destroyed)
          return;
        const signal = this._pc.localDescription || offer;
        this._debug("signal");
        this.emit("signal", {
          type: signal.type,
          sdp: signal.sdp
        });
      };
      const onSuccess = () => {
        this._debug("createOffer success");
        if (this.destroyed)
          return;
        if (this.trickle || this._iceComplete)
          sendOffer();
        else
          this.once("_iceComplete", sendOffer);
      };
      const onError = (err) => {
        this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
      };
      this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
    }).catch((err) => {
      this.destroy(errCode(err, "ERR_CREATE_OFFER"));
    });
  }
  _requestMissingTransceivers() {
    if (this._pc.getTransceivers) {
      this._pc.getTransceivers().forEach((transceiver) => {
        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
          transceiver.requested = true;
          this.addTransceiver(transceiver.sender.track.kind);
        }
      });
    }
  }
  _createAnswer() {
    if (this.destroyed)
      return;
    this._pc.createAnswer(this.answerOptions).then((answer) => {
      if (this.destroyed)
        return;
      if (!this.trickle && !this.allowHalfTrickle)
        answer.sdp = filterTrickle(answer.sdp);
      answer.sdp = this.sdpTransform(answer.sdp);
      const sendAnswer = () => {
        if (this.destroyed)
          return;
        const signal = this._pc.localDescription || answer;
        this._debug("signal");
        this.emit("signal", {
          type: signal.type,
          sdp: signal.sdp
        });
        if (!this.initiator)
          this._requestMissingTransceivers();
      };
      const onSuccess = () => {
        if (this.destroyed)
          return;
        if (this.trickle || this._iceComplete)
          sendAnswer();
        else
          this.once("_iceComplete", sendAnswer);
      };
      const onError = (err) => {
        this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
      };
      this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
    }).catch((err) => {
      this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
    });
  }
  _onConnectionStateChange() {
    if (this.destroyed)
      return;
    if (this._pc.connectionState === "failed") {
      this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
    }
  }
  _onIceStateChange() {
    if (this.destroyed)
      return;
    const iceConnectionState = this._pc.iceConnectionState;
    const iceGatheringState = this._pc.iceGatheringState;
    this._debug(
      "iceStateChange (connection: %s) (gathering: %s)",
      iceConnectionState,
      iceGatheringState
    );
    this.emit("iceStateChange", iceConnectionState, iceGatheringState);
    if (iceConnectionState === "connected" || iceConnectionState === "completed") {
      this._pcReady = true;
      this._maybeReady();
    }
    if (iceConnectionState === "failed") {
      this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
    }
    if (iceConnectionState === "closed") {
      this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
    }
  }
  getStats(cb) {
    const flattenValues = (report) => {
      if (Object.prototype.toString.call(report.values) === "[object Array]") {
        report.values.forEach((value) => {
          Object.assign(report, value);
        });
      }
      return report;
    };
    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats().then((res) => {
        const reports = [];
        res.forEach((report) => {
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, (err) => cb(err));
    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats((res) => {
        if (this.destroyed)
          return;
        const reports = [];
        res.result().forEach((result) => {
          const report = {};
          result.names().forEach((name) => {
            report[name] = result.stat(name);
          });
          report.id = result.id;
          report.type = result.type;
          report.timestamp = result.timestamp;
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, (err) => cb(err));
    } else {
      cb(null, []);
    }
  }
  _maybeReady() {
    this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
    if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
      return;
    this._connecting = true;
    const findCandidatePair = () => {
      if (this.destroyed)
        return;
      this.getStats((err, items) => {
        if (this.destroyed)
          return;
        if (err)
          items = [];
        const remoteCandidates = {};
        const localCandidates = {};
        const candidatePairs = {};
        let foundSelectedCandidatePair = false;
        items.forEach((item) => {
          if (item.type === "remotecandidate" || item.type === "remote-candidate") {
            remoteCandidates[item.id] = item;
          }
          if (item.type === "localcandidate" || item.type === "local-candidate") {
            localCandidates[item.id] = item;
          }
          if (item.type === "candidatepair" || item.type === "candidate-pair") {
            candidatePairs[item.id] = item;
          }
        });
        const setSelectedCandidatePair = (selectedCandidatePair) => {
          foundSelectedCandidatePair = true;
          let local = localCandidates[selectedCandidatePair.localCandidateId];
          if (local && (local.ip || local.address)) {
            this.localAddress = local.ip || local.address;
            this.localPort = Number(local.port);
          } else if (local && local.ipAddress) {
            this.localAddress = local.ipAddress;
            this.localPort = Number(local.portNumber);
          } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
            local = selectedCandidatePair.googLocalAddress.split(":");
            this.localAddress = local[0];
            this.localPort = Number(local[1]);
          }
          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
          }
          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
          if (remote && (remote.ip || remote.address)) {
            this.remoteAddress = remote.ip || remote.address;
            this.remotePort = Number(remote.port);
          } else if (remote && remote.ipAddress) {
            this.remoteAddress = remote.ipAddress;
            this.remotePort = Number(remote.portNumber);
          } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
            remote = selectedCandidatePair.googRemoteAddress.split(":");
            this.remoteAddress = remote[0];
            this.remotePort = Number(remote[1]);
          }
          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
          }
          this._debug(
            "connect local: %s:%s remote: %s:%s",
            this.localAddress,
            this.localPort,
            this.remoteAddress,
            this.remotePort
          );
        };
        items.forEach((item) => {
          if (item.type === "transport" && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
          }
          if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
            setSelectedCandidatePair(item);
          }
        });
        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100);
          return;
        } else {
          this._connecting = false;
          this._connected = true;
        }
        if (this._chunk) {
          try {
            this.send(this._chunk);
          } catch (err2) {
            return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
          }
          this._chunk = null;
          this._debug('sent chunk from "write before connect"');
          const cb = this._cb;
          this._cb = null;
          cb(null);
        }
        if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
          this._interval = setInterval(() => this._onInterval(), 150);
          if (this._interval.unref)
            this._interval.unref();
        }
        this._debug("connect");
        this.emit("connect");
      });
    };
    findCandidatePair();
  }
  _onInterval() {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return;
    }
    this._onChannelBufferedAmountLow();
  }
  _onSignalingStateChange() {
    if (this.destroyed)
      return;
    if (this._pc.signalingState === "stable") {
      this._isNegotiating = false;
      this._debug("flushing sender queue", this._sendersAwaitingStable);
      this._sendersAwaitingStable.forEach((sender) => {
        this._pc.removeTrack(sender);
        this._queuedNegotiation = true;
      });
      this._sendersAwaitingStable = [];
      if (this._queuedNegotiation) {
        this._debug("flushing negotiation queue");
        this._queuedNegotiation = false;
        this._needsNegotiation();
      } else {
        this._debug("negotiated");
        this.emit("negotiated");
      }
    }
    this._debug("signalingStateChange %s", this._pc.signalingState);
    this.emit("signalingStateChange", this._pc.signalingState);
  }
  _onIceCandidate(event) {
    if (this.destroyed)
      return;
    if (event.candidate && this.trickle) {
      this.emit("signal", {
        type: "candidate",
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      });
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true;
      this.emit("_iceComplete");
    }
    if (event.candidate) {
      this._startIceCompleteTimeout();
    }
  }
  _onChannelMessage(event) {
    if (this.destroyed)
      return;
    let data2 = event.data;
    if (data2 instanceof ArrayBuffer)
      data2 = Buffer$1.from(data2);
    this.push(data2);
  }
  _onChannelBufferedAmountLow() {
    if (this.destroyed || !this._cb)
      return;
    this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
    const cb = this._cb;
    this._cb = null;
    cb(null);
  }
  _onChannelOpen() {
    if (this._connected || this.destroyed)
      return;
    this._debug("on channel open");
    this._channelReady = true;
    this._maybeReady();
  }
  _onChannelClose() {
    if (this.destroyed)
      return;
    this._debug("on channel close");
    this.destroy();
  }
  _onTrack(event) {
    if (this.destroyed)
      return;
    event.streams.forEach((eventStream) => {
      this._debug("on track");
      this.emit("track", event.track, eventStream);
      this._remoteTracks.push({
        track: event.track,
        stream: eventStream
      });
      if (this._remoteStreams.some((remoteStream) => {
        return remoteStream.id === eventStream.id;
      }))
        return;
      this._remoteStreams.push(eventStream);
      queueMicrotask$1(() => {
        this._debug("on stream");
        this.emit("stream", eventStream);
      });
    });
  }
  _debug() {
    const args = [].slice.call(arguments);
    args[0] = "[" + this._id + "] " + args[0];
    debug.apply(null, args);
  }
}
Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
Peer.config = {
  iceServers: [
    {
      urls: [
        "stun:stun.l.google.com:19302",
        "stun:global.stun.twilio.com:3478"
      ]
    }
  ],
  sdpSemantics: "unified-plan"
};
Peer.channelConfig = {};
var simplePeer = Peer;
const SimplePeer = /* @__PURE__ */ getDefaultExportFromCjs(simplePeer);
var lib = { exports: {} };
var seed = 1;
function getNextValue() {
  seed = (seed * 9301 + 49297) % 233280;
  return seed / 233280;
}
function setSeed$1(_seed_) {
  seed = _seed_;
}
var randomFromSeed$1 = {
  nextValue: getNextValue,
  seed: setSeed$1
};
var randomFromSeed = randomFromSeed$1;
var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
var alphabet$2;
var previousSeed;
var shuffled;
function reset() {
  shuffled = false;
}
function setCharacters(_alphabet_) {
  if (!_alphabet_) {
    if (alphabet$2 !== ORIGINAL) {
      alphabet$2 = ORIGINAL;
      reset();
    }
    return;
  }
  if (_alphabet_ === alphabet$2) {
    return;
  }
  if (_alphabet_.length !== ORIGINAL.length) {
    throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
  }
  var unique = _alphabet_.split("").filter(function(item, ind, arr2) {
    return ind !== arr2.lastIndexOf(item);
  });
  if (unique.length) {
    throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
  }
  alphabet$2 = _alphabet_;
  reset();
}
function characters(_alphabet_) {
  setCharacters(_alphabet_);
  return alphabet$2;
}
function setSeed(seed2) {
  randomFromSeed.seed(seed2);
  if (previousSeed !== seed2) {
    reset();
    previousSeed = seed2;
  }
}
function shuffle() {
  if (!alphabet$2) {
    setCharacters(ORIGINAL);
  }
  var sourceArray = alphabet$2.split("");
  var targetArray = [];
  var r = randomFromSeed.nextValue();
  var characterIndex;
  while (sourceArray.length > 0) {
    r = randomFromSeed.nextValue();
    characterIndex = Math.floor(r * sourceArray.length);
    targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
  }
  return targetArray.join("");
}
function getShuffled() {
  if (shuffled) {
    return shuffled;
  }
  shuffled = shuffle();
  return shuffled;
}
function lookup(index2) {
  var alphabetShuffled = getShuffled();
  return alphabetShuffled[index2];
}
function get() {
  return alphabet$2 || ORIGINAL;
}
var alphabet_1 = {
  get,
  characters,
  seed: setSeed,
  lookup,
  shuffled: getShuffled
};
var crypto = typeof window === "object" && (window.crypto || window.msCrypto);
var randomByte;
if (!crypto || !crypto.getRandomValues) {
  randomByte = function(size) {
    var bytes = [];
    for (var i2 = 0; i2 < size; i2++) {
      bytes.push(Math.floor(Math.random() * 256));
    }
    return bytes;
  };
} else {
  randomByte = function(size) {
    return crypto.getRandomValues(new Uint8Array(size));
  };
}
var randomByteBrowser = randomByte;
var format_browser = function(random2, alphabet2, size) {
  var mask = (2 << Math.log(alphabet2.length - 1) / Math.LN2) - 1;
  var step = -~(1.6 * mask * size / alphabet2.length);
  var id2 = "";
  while (true) {
    var bytes = random2(step);
    var i2 = step;
    while (i2--) {
      id2 += alphabet2[bytes[i2] & mask] || "";
      if (id2.length === +size)
        return id2;
    }
  }
};
var alphabet$1 = alphabet_1;
var random = randomByteBrowser;
var format = format_browser;
function generate$2(number) {
  var loopCounter = 0;
  var done2;
  var str = "";
  while (!done2) {
    str = str + format(random, alphabet$1.get(), 1);
    done2 = number < Math.pow(16, loopCounter + 1);
    loopCounter++;
  }
  return str;
}
var generate_1 = generate$2;
var generate$1 = generate_1;
var REDUCE_TIME = 1567752802062;
var version$1 = 7;
var counter;
var previousSeconds;
function build(clusterWorkerId) {
  var str = "";
  var seconds = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
  if (seconds === previousSeconds) {
    counter++;
  } else {
    counter = 0;
    previousSeconds = seconds;
  }
  str = str + generate$1(version$1);
  str = str + generate$1(clusterWorkerId);
  if (counter > 0) {
    str = str + generate$1(counter);
  }
  str = str + generate$1(seconds);
  return str;
}
var build_1 = build;
var alphabet = alphabet_1;
function isShortId(id2) {
  if (!id2 || typeof id2 !== "string" || id2.length < 6) {
    return false;
  }
  var nonAlphabetic = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
  return !nonAlphabetic.test(id2);
}
var isValid = isShortId;
(function(module2) {
  var alphabet2 = alphabet_1;
  var build2 = build_1;
  var isValid$1 = isValid;
  var clusterWorkerId = 0;
  function seed2(seedValue) {
    alphabet2.seed(seedValue);
    return module2.exports;
  }
  function worker(workerId) {
    clusterWorkerId = workerId;
    return module2.exports;
  }
  function characters2(newCharacters) {
    if (newCharacters !== void 0) {
      alphabet2.characters(newCharacters);
    }
    return alphabet2.shuffled();
  }
  function generate2() {
    return build2(clusterWorkerId);
  }
  module2.exports = generate2;
  module2.exports.generate = generate2;
  module2.exports.seed = seed2;
  module2.exports.worker = worker;
  module2.exports.characters = characters2;
  module2.exports.isValid = isValid$1;
})(lib);
var libExports = lib.exports;
var shortid = libExports;
const shortid$1 = /* @__PURE__ */ getDefaultExportFromCjs(shortid);
var extend = Object.assign;
var PatchBay = function(options2) {
  this.signaller = io(options2.server);
  this.id = options2.id || shortid$1.generate();
  this.stream = options2.stream || null;
  this._peerOptions = options2.peerOptions || {};
  this._room = options2.room;
  this.settings["shareMediaWhenRequested"] = true;
  this.settings["shareMediaWhenInitiating"] = false;
  this.settings["requestMediaWhenInitiating"] = true;
  this.settings["autoconnect"] = false;
  this.peers = {};
  this.rtcPeers = {};
  this.signaller.on("ready", this._readyForSignalling.bind(this));
  this.signaller.on("message", this._handleMessage.bind(this));
  this.signaller.on("broadcast", this._receivedBroadcast.bind(this));
  this.signaller.emit("join", this._room, { uuid: this.id });
  this.signaller.on("new peer", this._newPeer.bind(this));
};
inherits(PatchBay, eventsExports.EventEmitter);
PatchBay.prototype.sendToAll = function(data2) {
  Object.keys(this.rtcPeers).forEach(function(id2) {
    this.rtcPeers[id2].send(data2);
  }, this);
};
PatchBay.prototype.sendToPeer = function(peerId, data2) {
  if (peerId in this.rtcPeers) {
    this.rtcPeers[peerId].send(data2);
  }
};
PatchBay.prototype.reinitAll = function() {
  Object.keys(this.rtcPeers).forEach(function(id2) {
    this.reinitPeer(id2);
  }.bind(this));
};
PatchBay.prototype.initRtcPeer = function(id2, opts) {
  this.emit("new peer", { id: id2 });
  var newOptions = opts;
  if (this.iceServers) {
    opts["config"] = {
      iceServers: this.iceServers
    };
  }
  if (opts.initiator === true) {
    if (this.stream != null) {
      if (this.settings.shareMediaWhenInitiating === true) {
        newOptions.stream = this.stream;
      }
    }
    if (this.settings.requestMediaWhenInitiating === true) {
      newOptions.offerConstraints = {
        offerToReceiveVideo: true,
        offerToReceiveAudio: true
      };
    }
  } else {
    if (this.settings.shareMediaWhenRequested === true) {
      if (this.stream != null) {
        newOptions.stream = this.stream;
      }
    }
  }
  var options2 = extend(this._peerOptions, newOptions);
  this.rtcPeers[id2] = new SimplePeer(options2);
  this._attachPeerEvents(this.rtcPeers[id2], id2);
};
PatchBay.prototype.reinitRtcConnection = function(id2, opts) {
  this.rtcPeers[id2]._destroy(null, function(e) {
    this.initRtcPeer(id2, {
      stream: this.stream,
      initiator: true
    });
  }.bind(this));
};
PatchBay.prototype._newPeer = function(peer) {
  this.peers[peer] = {
    rtcPeer: null
  };
  this.emit("new peer", peer);
};
PatchBay.prototype._readyForSignalling = function({ peers, servers }) {
  peers.forEach((peer) => {
    this._newPeer(peer);
  });
  if (servers) {
    this.iceServers = servers;
  }
  this.emit("ready");
};
PatchBay.prototype.initConnectionFromId = function(id2, callback2) {
  if (id2 in this.rtcPeers) {
    console.log("Already connected to..", id2, this.rtcPeers);
    if (this.rtcPeers[id2].initiator === false) {
      this.reinitRtcConnection(id2);
    }
  } else {
    this.initRtcPeer(id2, {
      initiator: true
    });
  }
};
PatchBay.prototype._handleMessage = function(data2) {
  if (data2.type === "signal") {
    this._handleSignal(data2);
  } else {
    this.emit("message", data2);
  }
};
PatchBay.prototype._handleSignal = function(data2) {
  if (!this.rtcPeers[data2.id]) {
    this.initRtcPeer(data2.id, { initiator: false });
  }
  this.rtcPeers[data2.id].signal(data2.message);
};
PatchBay.prototype._receivedBroadcast = function(data2) {
  this.emit("broadcast", data2);
};
PatchBay.prototype.broadcast = function(data2) {
  this.signaller.emit("broadcast", data2);
};
PatchBay.prototype._attachPeerEvents = function(p, _id) {
  p.on("signal", function(id2, signal) {
    this.signaller.emit("message", { id: id2, message: signal, type: "signal" });
  }.bind(this, _id));
  p.on("stream", function(id2, stream2) {
    this.rtcPeers[id2].stream = stream2;
    this.emit("stream", id2, stream2);
  }.bind(this, _id));
  p.on("connect", function(id2) {
    this.emit("connect", id2);
  }.bind(this, _id));
  p.on("data", function(id2, data2) {
    this.emit("data", { id: id2, data: JSON.parse(data2) });
  }.bind(this, _id));
  p.on("close", function(id2) {
    delete this.rtcPeers[id2];
    this.emit("close", id2);
  }.bind(this, _id));
  p.on("error", function(e) {
    console.warn("simple peer error", e);
  });
};
PatchBay.prototype._destroy = function() {
  Object.values(this.rtcPeers).forEach(function(peer) {
    peer.destroy();
  });
  this.signaller.close();
};
var PBLive = function() {
  this.session = {};
  this.nickFromId = {};
  this.idFromNick = {};
  this.loadFromStorage();
};
inherits(PBLive, PatchBay);
PBLive.prototype.init = function(stream2, opts) {
  this.settings = {
    server: opts.server || "https://patch-bay.glitch.me/",
    room: opts.room || "patch-bay",
    stream: stream2
  };
  this.makeGlobal = opts.makeGlobal || true;
  this.setPageTitle = opts.setTitle || true;
  if (this.session.id)
    this.settings.id = this.session.id;
  PatchBay.call(this, this.settings);
  if (this.makeGlobal)
    window.pb = this;
  this.on("ready", () => {
    if (!this.nick) {
      if (this.session.nick) {
        this.setName(this.session.nick);
      } else {
        this.session.id = this.id;
        this.setName(this.session.id);
      }
    }
  });
  this.on("broadcast", this._processBroadcast.bind(this));
  this.on("new peer", this.handleNewPeer.bind(this));
  window.onbeforeunload = () => {
    this.session.id = window.pb.id;
    this.session.nick = this.nick;
    sessionStorage.setItem("pb", JSON.stringify(this.session));
  };
  var self2 = this;
  this.on("stream", function(id2, stream3) {
    console.log("got stream!", id2, stream3);
    const video = document.createElement("video");
    if ("srcObject" in video) {
      video.srcObject = stream3;
    } else {
      video.src = window.URL.createObjectURL(stream3);
    }
    video.addEventListener("loadedmetadata", () => {
      video.play();
      self2.video = video;
      self2.emit("got video", self2.nickFromId[id2], video);
    });
  });
};
PBLive.prototype.loadFromStorage = function() {
  if (sessionStorage.getItem("pb") !== null) {
    this.session = JSON.parse(sessionStorage.getItem("pb"));
  }
};
PBLive.prototype.initSource = function(nick, callback2) {
  this.initConnectionFromId(this.idFromNick[nick], callback2);
};
PBLive.prototype.handleNewPeer = function(peer) {
  this.nickFromId[peer] = peer;
  this.idFromNick[peer] = peer;
  if (this.nick) {
    this.broadcast({
      type: "update-nick",
      id: this.id,
      nick: this.nick
    });
  }
};
PBLive.prototype.list = function() {
  var l = Object.keys(this.idFromNick);
  console.log(l);
  return Object.keys(this.idFromNick);
};
PBLive.prototype.setName = function(nick) {
  this.broadcast({
    type: "update-nick",
    id: this.id,
    nick,
    previous: this.nick
  });
  this.nick = nick;
  if (this.setPageTitle)
    document.title = nick;
};
PBLive.prototype._processBroadcast = function(data2) {
  if (data2.type === "update-nick") {
    if (data2.previous !== data2.nick) {
      delete this.idFromNick[this.nickFromId[data2.id]];
      this.nickFromId[data2.id] = data2.nick;
      this.idFromNick[data2.nick] = data2.id;
      if (data2.previous)
        ;
    }
  }
};
class Hydra extends Component {
  constructor(id2, state2, emit2) {
    super(id2);
    this.local = state2.components[id2] = {};
    state2.hydra = this;
    this.emit = emit2;
  }
  load(element) {
    let isIOS = (/iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && !window.MSStream;
    let precisionValue = isIOS ? "highp" : "mediump";
    const pb = new PBLive();
    const hydra = new HydraSynth({ pb, detectAudio: true, canvas: element.querySelector("canvas"), precision: precisionValue });
    this.hydra = hydra;
    osc().out();
    pb.init(hydra.captureStream, {
      server: window.location.origin,
      room: "iclc"
    });
    window.P5 = P5;
    window.pb = pb;
    this.emit("hydra loaded");
  }
  update(center) {
    return false;
  }
  createElement({ width = window.innerWidth, height = window.innerHeight } = {}) {
    return html$2`<div style="width:100%;height:100%;">
        <canvas class="bg-black" style="imageRendering:pixelated; width:100%;height:100%" width="${width}" height="${height}"></canvas></div>`;
  }
}
var codemirror$1 = { exports: {} };
(function(module2, exports2) {
  var $jscomp = $jscomp || {};
  $jscomp.scope = {};
  $jscomp.findInternal = function(y2, E, D) {
    y2 instanceof String && (y2 = String(y2));
    for (var v = y2.length, M = 0; M < v; M++) {
      var ja = y2[M];
      if (E.call(D, ja, M, y2))
        return { i: M, v: ja };
    }
    return { i: -1, v: void 0 };
  };
  $jscomp.ASSUME_ES5 = false;
  $jscomp.ASSUME_NO_NATIVE_MAP = false;
  $jscomp.ASSUME_NO_NATIVE_SET = false;
  $jscomp.SIMPLE_FROUND_POLYFILL = false;
  $jscomp.ISOLATE_POLYFILLS = false;
  $jscomp.FORCE_POLYFILL_PROMISE = false;
  $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = false;
  $jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(y2, E, D) {
    if (y2 == Array.prototype || y2 == Object.prototype)
      return y2;
    y2[E] = D.value;
    return y2;
  };
  $jscomp.getGlobal = function(y2) {
    y2 = ["object" == typeof globalThis && globalThis, y2, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof commonjsGlobal && commonjsGlobal];
    for (var E = 0; E < y2.length; ++E) {
      var D = y2[E];
      if (D && D.Math == Math)
        return D;
    }
    throw Error("Cannot find global object");
  };
  $jscomp.global = $jscomp.getGlobal(commonjsGlobal);
  $jscomp.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
  $jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
  $jscomp.polyfills = {};
  $jscomp.propertyToPolyfillSymbol = {};
  $jscomp.POLYFILL_PREFIX = "$jscp$";
  $jscomp.polyfill = function(y2, E, D, v) {
    E && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(y2, E, D, v) : $jscomp.polyfillUnisolated(y2, E, D, v));
  };
  $jscomp.polyfillUnisolated = function(y2, E, D, v) {
    D = $jscomp.global;
    y2 = y2.split(".");
    for (v = 0; v < y2.length - 1; v++) {
      var M = y2[v];
      if (!(M in D))
        return;
      D = D[M];
    }
    y2 = y2[y2.length - 1];
    v = D[y2];
    E = E(v);
    E != v && null != E && $jscomp.defineProperty(D, y2, { configurable: true, writable: true, value: E });
  };
  $jscomp.polyfillIsolated = function(y2, E, D, v) {
    var M = y2.split(".");
    y2 = 1 === M.length;
    v = M[0];
    v = !y2 && v in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
    for (var ja = 0; ja < M.length - 1; ja++) {
      var ka = M[ja];
      if (!(ka in v))
        return;
      v = v[ka];
    }
    M = M[M.length - 1];
    D = $jscomp.IS_SYMBOL_NATIVE && "es6" === D ? v[M] : null;
    E = E(D);
    null != E && (y2 ? $jscomp.defineProperty($jscomp.polyfills, M, { configurable: true, writable: true, value: E }) : E !== D && (void 0 === $jscomp.propertyToPolyfillSymbol[M] && (D = 1e9 * Math.random() >>> 0, $jscomp.propertyToPolyfillSymbol[M] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(M) : $jscomp.POLYFILL_PREFIX + D + "$" + M), $jscomp.defineProperty(v, $jscomp.propertyToPolyfillSymbol[M], { configurable: true, writable: true, value: E })));
  };
  $jscomp.polyfill("Array.prototype.find", function(y2) {
    return y2 ? y2 : function(E, D) {
      return $jscomp.findInternal(this, E, D).v;
    };
  }, "es6", "es3");
  (function(y2, E) {
    module2.exports = E();
  })(commonjsGlobal, function() {
    function y2(a2) {
      return new RegExp("(^|\\s)" + a2 + "(?:$|\\s)\\s*");
    }
    function E(a2) {
      for (var b = a2.childNodes.length; 0 < b; --b)
        a2.removeChild(a2.firstChild);
      return a2;
    }
    function D(a2, b) {
      return E(a2).appendChild(b);
    }
    function v(a2, b, d2, c) {
      a2 = document.createElement(a2);
      d2 && (a2.className = d2);
      c && (a2.style.cssText = c);
      if ("string" == typeof b)
        a2.appendChild(document.createTextNode(b));
      else if (b)
        for (d2 = 0; d2 < b.length; ++d2)
          a2.appendChild(b[d2]);
      return a2;
    }
    function M(a2, b, d2, c) {
      a2 = v(a2, b, d2, c);
      a2.setAttribute("role", "presentation");
      return a2;
    }
    function ja(a2, b) {
      3 == b.nodeType && (b = b.parentNode);
      if (a2.contains)
        return a2.contains(b);
      do
        if (11 == b.nodeType && (b = b.host), b == a2)
          return true;
      while (b = b.parentNode);
    }
    function ka(a2) {
      try {
        var b = a2.activeElement;
      } catch (d2) {
        b = a2.body || null;
      }
      for (; b && b.shadowRoot && b.shadowRoot.activeElement; )
        b = b.shadowRoot.activeElement;
      return b;
    }
    function Ya(a2, b) {
      var d2 = a2.className;
      y2(b).test(d2) || (a2.className += (d2 ? " " : "") + b);
    }
    function fd(a2, b) {
      a2 = a2.split(" ");
      for (var d2 = 0; d2 < a2.length; d2++)
        a2[d2] && !y2(a2[d2]).test(b) && (b += " " + a2[d2]);
      return b;
    }
    function qa(a2) {
      return a2.display.wrapper.ownerDocument;
    }
    function gd(a2) {
      var b = Array.prototype.slice.call(arguments, 1);
      return function() {
        return a2.apply(null, b);
      };
    }
    function Za(a2, b, d2) {
      b || (b = {});
      for (var c in a2)
        !a2.hasOwnProperty(c) || false === d2 && b.hasOwnProperty(c) || (b[c] = a2[c]);
      return b;
    }
    function wa(a2, b, d2, c, e) {
      null == b && (b = a2.search(/[^\s\u00a0]/), -1 == b && (b = a2.length));
      c = c || 0;
      for (e = e || 0; ; ) {
        var f = a2.indexOf(
          "	",
          c
        );
        if (0 > f || f >= b)
          return e + (b - c);
        e += f - c;
        e += d2 - e % d2;
        c = f + 1;
      }
    }
    function ea(a2, b) {
      for (var d2 = 0; d2 < a2.length; ++d2)
        if (a2[d2] == b)
          return d2;
      return -1;
    }
    function hd(a2, b, d2) {
      for (var c = 0, e = 0; ; ) {
        var f = a2.indexOf("	", c);
        -1 == f && (f = a2.length);
        var g = f - c;
        if (f == a2.length || e + g >= b)
          return c + Math.min(g, b - e);
        e += f - c;
        e += d2 - e % d2;
        c = f + 1;
        if (e >= b)
          return c;
      }
    }
    function id2(a2) {
      for (; vc.length <= a2; )
        vc.push(J(vc) + " ");
      return vc[a2];
    }
    function J(a2) {
      return a2[a2.length - 1];
    }
    function wc(a2, b) {
      for (var d2 = [], c = 0; c < a2.length; c++)
        d2[c] = b(a2[c], c);
      return d2;
    }
    function yg(a2, b, d2) {
      for (var c = 0, e = d2(b); c < a2.length && d2(a2[c]) <= e; )
        c++;
      a2.splice(c, 0, b);
    }
    function pe() {
    }
    function qe(a2, b) {
      Object.create ? a2 = Object.create(a2) : (pe.prototype = a2, a2 = new pe());
      b && Za(b, a2);
      return a2;
    }
    function jd(a2) {
      return /\w/.test(a2) || "¬Ä" < a2 && (a2.toUpperCase() != a2.toLowerCase() || zg.test(a2));
    }
    function xc(a2, b) {
      return b ? -1 < b.source.indexOf("\\w") && jd(a2) ? true : b.test(a2) : jd(a2);
    }
    function re2(a2) {
      for (var b in a2)
        if (a2.hasOwnProperty(b) && a2[b])
          return false;
      return true;
    }
    function kd(a2) {
      return 768 <= a2.charCodeAt(0) && Ag.test(a2);
    }
    function se(a2, b, d2) {
      for (; (0 > d2 ? 0 < b : b < a2.length) && kd(a2.charAt(b)); )
        b += d2;
      return b;
    }
    function Jb(a2, b, d2) {
      for (var c = b > d2 ? -1 : 1; ; ) {
        if (b == d2)
          return b;
        var e = (b + d2) / 2;
        e = 0 > c ? Math.ceil(e) : Math.floor(e);
        if (e == b)
          return a2(e) ? b : d2;
        a2(e) ? d2 = e : b = e + c;
      }
    }
    function Bg(a2, b, d2, c) {
      if (!a2)
        return c(b, d2, "ltr", 0);
      for (var e = false, f = 0; f < a2.length; ++f) {
        var g = a2[f];
        if (g.from < d2 && g.to > b || b == d2 && g.to == b)
          c(Math.max(g.from, b), Math.min(g.to, d2), 1 == g.level ? "rtl" : "ltr", f), e = true;
      }
      e || c(b, d2, "ltr");
    }
    function Kb(a2, b, d2) {
      var c;
      Lb = null;
      for (var e = 0; e < a2.length; ++e) {
        var f = a2[e];
        if (f.from < b && f.to > b)
          return e;
        f.to == b && (f.from != f.to && "before" == d2 ? c = e : Lb = e);
        f.from == b && (f.from != f.to && "before" != d2 ? c = e : Lb = e);
      }
      return null != c ? c : Lb;
    }
    function Ja(a2, b) {
      var d2 = a2.order;
      null == d2 && (d2 = a2.order = Cg(a2.text, b));
      return d2;
    }
    function ta(a2, b, d2) {
      if (a2.removeEventListener)
        a2.removeEventListener(b, d2, false);
      else if (a2.detachEvent)
        a2.detachEvent("on" + b, d2);
      else {
        var c = (a2 = a2._handlers) && a2[b];
        c && (d2 = ea(c, d2), -1 < d2 && (a2[b] = c.slice(0, d2).concat(c.slice(d2 + 1))));
      }
    }
    function W(a2, b) {
      var d2 = a2._handlers && a2._handlers[b] || yc;
      if (d2.length)
        for (var c = Array.prototype.slice.call(
          arguments,
          2
        ), e = 0; e < d2.length; ++e)
          d2[e].apply(null, c);
    }
    function Z(a2, b, d2) {
      "string" == typeof b && (b = { type: b, preventDefault: function() {
        this.defaultPrevented = true;
      } });
      W(a2, d2 || b.type, a2, b);
      return ld(b) || b.codemirrorIgnore;
    }
    function te(a2) {
      var b = a2._handlers && a2._handlers.cursorActivity;
      if (b) {
        a2 = a2.curOp.cursorActivityHandlers || (a2.curOp.cursorActivityHandlers = []);
        for (var d2 = 0; d2 < b.length; ++d2)
          -1 == ea(a2, b[d2]) && a2.push(b[d2]);
      }
    }
    function xa(a2, b) {
      return 0 < (a2._handlers && a2._handlers[b] || yc).length;
    }
    function pb(a2) {
      a2.prototype.on = function(b, d2) {
        z(
          this,
          b,
          d2
        );
      };
      a2.prototype.off = function(b, d2) {
        ta(this, b, d2);
      };
    }
    function la(a2) {
      a2.preventDefault ? a2.preventDefault() : a2.returnValue = false;
    }
    function ue(a2) {
      a2.stopPropagation ? a2.stopPropagation() : a2.cancelBubble = true;
    }
    function ld(a2) {
      return null != a2.defaultPrevented ? a2.defaultPrevented : 0 == a2.returnValue;
    }
    function Mb(a2) {
      la(a2);
      ue(a2);
    }
    function ve(a2) {
      var b = a2.which;
      null == b && (a2.button & 1 ? b = 1 : a2.button & 2 ? b = 3 : a2.button & 4 && (b = 2));
      ya && a2.ctrlKey && 1 == b && (b = 3);
      return b;
    }
    function Dg(a2, b) {
      2 < arguments.length && (b.dependencies = Array.prototype.slice.call(
        arguments,
        2
      ));
      md[a2] = b;
    }
    function zc(a2) {
      if ("string" == typeof a2 && qb.hasOwnProperty(a2))
        a2 = qb[a2];
      else if (a2 && "string" == typeof a2.name && qb.hasOwnProperty(a2.name)) {
        var b = qb[a2.name];
        "string" == typeof b && (b = { name: b });
        a2 = qe(b, a2);
        a2.name = b.name;
      } else {
        if ("string" == typeof a2 && /^[\w\-]+\/[\w\-]+\+xml$/.test(a2))
          return zc("application/xml");
        if ("string" == typeof a2 && /^[\w\-]+\/[\w\-]+\+json$/.test(a2))
          return zc("application/json");
      }
      return "string" == typeof a2 ? { name: a2 } : a2 || { name: "null" };
    }
    function nd(a2, b) {
      b = zc(b);
      var d2 = md[b.name];
      if (!d2)
        return nd(
          a2,
          "text/plain"
        );
      a2 = d2(a2, b);
      if (rb.hasOwnProperty(b.name)) {
        d2 = rb[b.name];
        for (var c in d2)
          d2.hasOwnProperty(c) && (a2.hasOwnProperty(c) && (a2["_" + c] = a2[c]), a2[c] = d2[c]);
      }
      a2.name = b.name;
      b.helperType && (a2.helperType = b.helperType);
      if (b.modeProps)
        for (var e in b.modeProps)
          a2[e] = b.modeProps[e];
      return a2;
    }
    function Eg(a2, b) {
      a2 = rb.hasOwnProperty(a2) ? rb[a2] : rb[a2] = {};
      Za(b, a2);
    }
    function $a(a2, b) {
      if (true === b)
        return b;
      if (a2.copyState)
        return a2.copyState(b);
      a2 = {};
      for (var d2 in b) {
        var c = b[d2];
        c instanceof Array && (c = c.concat([]));
        a2[d2] = c;
      }
      return a2;
    }
    function od(a2, b) {
      for (var d2; a2.innerMode; ) {
        d2 = a2.innerMode(b);
        if (!d2 || d2.mode == a2)
          break;
        b = d2.state;
        a2 = d2.mode;
      }
      return d2 || { mode: a2, state: b };
    }
    function we(a2, b, d2) {
      return a2.startState ? a2.startState(b, d2) : true;
    }
    function w(a2, b) {
      b -= a2.first;
      if (0 > b || b >= a2.size)
        throw Error("There is no line " + (b + a2.first) + " in the document.");
      for (; !a2.lines; )
        for (var d2 = 0; ; ++d2) {
          var c = a2.children[d2], e = c.chunkSize();
          if (b < e) {
            a2 = c;
            break;
          }
          b -= e;
        }
      return a2.lines[b];
    }
    function ab(a2, b, d2) {
      var c = [], e = b.line;
      a2.iter(b.line, d2.line + 1, function(f) {
        f = f.text;
        e == d2.line && (f = f.slice(0, d2.ch));
        e == b.line && (f = f.slice(b.ch));
        c.push(f);
        ++e;
      });
      return c;
    }
    function pd(a2, b, d2) {
      var c = [];
      a2.iter(b, d2, function(e) {
        c.push(e.text);
      });
      return c;
    }
    function Ea(a2, b) {
      if (b -= a2.height)
        for (; a2; a2 = a2.parent)
          a2.height += b;
    }
    function N(a2) {
      if (null == a2.parent)
        return null;
      var b = a2.parent;
      a2 = ea(b.lines, a2);
      for (var d2 = b.parent; d2; b = d2, d2 = d2.parent)
        for (var c = 0; d2.children[c] != b; ++c)
          a2 += d2.children[c].chunkSize();
      return a2 + b.first;
    }
    function bb(a2, b) {
      var d2 = a2.first;
      a:
        do {
          for (var c = 0; c < a2.children.length; ++c) {
            var e = a2.children[c], f = e.height;
            if (b < f) {
              a2 = e;
              continue a;
            }
            b -= f;
            d2 += e.chunkSize();
          }
          return d2;
        } while (!a2.lines);
      for (c = 0; c < a2.lines.length; ++c) {
        e = a2.lines[c].height;
        if (b < e)
          break;
        b -= e;
      }
      return d2 + c;
    }
    function Nb(a2, b) {
      return b >= a2.first && b < a2.first + a2.size;
    }
    function qd(a2, b) {
      return String(a2.lineNumberFormatter(b + a2.firstLineNumber));
    }
    function t(a2, b, d2) {
      void 0 === d2 && (d2 = null);
      if (!(this instanceof t))
        return new t(a2, b, d2);
      this.line = a2;
      this.ch = b;
      this.sticky = d2;
    }
    function B(a2, b) {
      return a2.line - b.line || a2.ch - b.ch;
    }
    function rd(a2, b) {
      return a2.sticky == b.sticky && 0 == B(a2, b);
    }
    function sd(a2) {
      return t(
        a2.line,
        a2.ch
      );
    }
    function Ac(a2, b) {
      return 0 > B(a2, b) ? b : a2;
    }
    function Bc(a2, b) {
      return 0 > B(a2, b) ? a2 : b;
    }
    function C(a2, b) {
      if (b.line < a2.first)
        return t(a2.first, 0);
      var d2 = a2.first + a2.size - 1;
      if (b.line > d2)
        return t(d2, w(a2, d2).text.length);
      a2 = w(a2, b.line).text.length;
      d2 = b.ch;
      b = null == d2 || d2 > a2 ? t(b.line, a2) : 0 > d2 ? t(b.line, 0) : b;
      return b;
    }
    function xe(a2, b) {
      for (var d2 = [], c = 0; c < b.length; c++)
        d2[c] = C(a2, b[c]);
      return d2;
    }
    function ye(a2, b, d2, c) {
      var e = [a2.state.modeGen], f = {};
      ze(a2, b.text, a2.doc.mode, d2, function(k, l) {
        return e.push(k, l);
      }, f, c);
      var g = d2.state;
      c = function(k) {
        d2.baseTokens = e;
        var l = a2.state.overlays[k], m2 = 1, n = 0;
        d2.state = true;
        ze(a2, b.text, l.mode, d2, function(p, q) {
          for (var r = m2; n < p; ) {
            var u = e[m2];
            u > p && e.splice(m2, 1, p, e[m2 + 1], u);
            m2 += 2;
            n = Math.min(p, u);
          }
          if (q)
            if (l.opaque)
              e.splice(r, m2 - r, p, "overlay " + q), m2 = r + 2;
            else
              for (; r < m2; r += 2)
                p = e[r + 1], e[r + 1] = (p ? p + " " : "") + "overlay " + q;
        }, f);
        d2.state = g;
        d2.baseTokens = null;
        d2.baseTokenPos = 1;
      };
      for (var h2 = 0; h2 < a2.state.overlays.length; ++h2)
        c(h2);
      return { styles: e, classes: f.bgClass || f.textClass ? f : null };
    }
    function Ae(a2, b, d2) {
      if (!b.styles || b.styles[0] != a2.state.modeGen) {
        var c = Ob(
          a2,
          N(b)
        ), e = b.text.length > a2.options.maxHighlightLength && $a(a2.doc.mode, c.state), f = ye(a2, b, c);
        e && (c.state = e);
        b.stateAfter = c.save(!e);
        b.styles = f.styles;
        f.classes ? b.styleClasses = f.classes : b.styleClasses && (b.styleClasses = null);
        d2 === a2.doc.highlightFrontier && (a2.doc.modeFrontier = Math.max(a2.doc.modeFrontier, ++a2.doc.highlightFrontier));
      }
      return b.styles;
    }
    function Ob(a2, b, d2) {
      var c = a2.doc, e = a2.display;
      if (!c.mode.startState)
        return new Fa(c, true, b);
      var f = Fg(a2, b, d2), g = f > c.first && w(c, f - 1).stateAfter, h2 = g ? Fa.fromSaved(c, g, f) : new Fa(
        c,
        we(c.mode),
        f
      );
      c.iter(f, b, function(k) {
        td(a2, k.text, h2);
        var l = h2.line;
        k.stateAfter = l == b - 1 || 0 == l % 5 || l >= e.viewFrom && l < e.viewTo ? h2.save() : null;
        h2.nextLine();
      });
      d2 && (c.modeFrontier = h2.line);
      return h2;
    }
    function td(a2, b, d2, c) {
      var e = a2.doc.mode;
      a2 = new X(b, a2.options.tabSize, d2);
      a2.start = a2.pos = c || 0;
      for ("" == b && Be(e, d2.state); !a2.eol(); )
        ud(e, a2, d2.state), a2.start = a2.pos;
    }
    function Be(a2, b) {
      if (a2.blankLine)
        return a2.blankLine(b);
      if (a2.innerMode && (a2 = od(a2, b), a2.mode.blankLine))
        return a2.mode.blankLine(a2.state);
    }
    function ud(a2, b, d2, c) {
      for (var e = 0; 10 > e; e++) {
        c && (c[0] = od(a2, d2).mode);
        var f = a2.token(b, d2);
        if (b.pos > b.start)
          return f;
      }
      throw Error("Mode " + a2.name + " failed to advance stream.");
    }
    function Ce(a2, b, d2, c) {
      var e = a2.doc, f = e.mode;
      b = C(e, b);
      var g = w(e, b.line);
      d2 = Ob(a2, b.line, d2);
      a2 = new X(g.text, a2.options.tabSize, d2);
      var h2;
      for (c && (h2 = []); (c || a2.pos < b.ch) && !a2.eol(); ) {
        a2.start = a2.pos;
        var k = ud(f, a2, d2.state);
        c && h2.push(new De(a2, k, $a(e.mode, d2.state)));
      }
      return c ? h2 : new De(a2, k, d2.state);
    }
    function Ee(a2, b) {
      if (a2)
        for (; ; ) {
          var d2 = a2.match(/(?:^|\s+)line-(background-)?(\S+)/);
          if (!d2)
            break;
          a2 = a2.slice(0, d2.index) + a2.slice(d2.index + d2[0].length);
          var c = d2[1] ? "bgClass" : "textClass";
          null == b[c] ? b[c] = d2[2] : new RegExp("(?:^|\\s)" + d2[2] + "(?:$|\\s)").test(b[c]) || (b[c] += " " + d2[2]);
        }
      return a2;
    }
    function ze(a2, b, d2, c, e, f, g) {
      var h2 = d2.flattenSpans;
      null == h2 && (h2 = a2.options.flattenSpans);
      var k = 0, l = null, m2 = new X(b, a2.options.tabSize, c), n = a2.options.addModeClass && [null];
      for ("" == b && Ee(Be(d2, c.state), f); !m2.eol(); ) {
        if (m2.pos > a2.options.maxHighlightLength) {
          h2 = false;
          g && td(a2, b, c, m2.pos);
          m2.pos = b.length;
          var p = null;
        } else
          p = Ee(ud(
            d2,
            m2,
            c.state,
            n
          ), f);
        if (n) {
          var q = n[0].name;
          q && (p = "m-" + (p ? q + " " + p : q));
        }
        if (!h2 || l != p) {
          for (; k < m2.start; )
            k = Math.min(m2.start, k + 5e3), e(k, l);
          l = p;
        }
        m2.start = m2.pos;
      }
      for (; k < m2.pos; )
        a2 = Math.min(m2.pos, k + 5e3), e(a2, l), k = a2;
    }
    function Fg(a2, b, d2) {
      for (var c, e, f = a2.doc, g = d2 ? -1 : b - (a2.doc.mode.innerMode ? 1e3 : 100); b > g; --b) {
        if (b <= f.first)
          return f.first;
        var h2 = w(f, b - 1), k = h2.stateAfter;
        if (k && (!d2 || b + (k instanceof Cc ? k.lookAhead : 0) <= f.modeFrontier))
          return b;
        h2 = wa(h2.text, null, a2.options.tabSize);
        if (null == e || c > h2)
          e = b - 1, c = h2;
      }
      return e;
    }
    function Gg(a2, b) {
      a2.modeFrontier = Math.min(a2.modeFrontier, b);
      if (!(a2.highlightFrontier < b - 10)) {
        for (var d2 = a2.first, c = b - 1; c > d2; c--) {
          var e = w(a2, c).stateAfter;
          if (e && (!(e instanceof Cc) || c + e.lookAhead < b)) {
            d2 = c + 1;
            break;
          }
        }
        a2.highlightFrontier = Math.min(a2.highlightFrontier, d2);
      }
    }
    function Dc(a2, b, d2) {
      this.marker = a2;
      this.from = b;
      this.to = d2;
    }
    function Pb(a2, b) {
      if (a2)
        for (var d2 = 0; d2 < a2.length; ++d2) {
          var c = a2[d2];
          if (c.marker == b)
            return c;
        }
    }
    function vd(a2, b) {
      if (b.full)
        return null;
      var d2 = Nb(a2, b.from.line) && w(a2, b.from.line).markedSpans, c = Nb(a2, b.to.line) && w(a2, b.to.line).markedSpans;
      if (!d2 && !c)
        return null;
      a2 = b.from.ch;
      var e = b.to.ch, f = 0 == B(b.from, b.to), g;
      if (d2)
        for (var h2 = 0; h2 < d2.length; ++h2) {
          var k = d2[h2], l = k.marker;
          if (null == k.from || (l.inclusiveLeft ? k.from <= a2 : k.from < a2) || !(k.from != a2 || "bookmark" != l.type || f && k.marker.insertLeft)) {
            var m2 = null == k.to || (l.inclusiveRight ? k.to >= a2 : k.to > a2);
            (g || (g = [])).push(new Dc(l, k.from, m2 ? null : k.to));
          }
        }
      d2 = g;
      var n;
      if (c) {
        for (g = 0; g < c.length; ++g)
          if (h2 = c[g], k = h2.marker, null == h2.to || (k.inclusiveRight ? h2.to >= e : h2.to > e) || h2.from == e && "bookmark" == k.type && (!f || h2.marker.insertLeft))
            l = null == h2.from || (k.inclusiveLeft ? h2.from <= e : h2.from < e), (n || (n = [])).push(new Dc(k, l ? null : h2.from - e, null == h2.to ? null : h2.to - e));
      }
      c = 1 == b.text.length;
      e = J(b.text).length + (c ? a2 : 0);
      if (d2) {
        for (f = 0; f < d2.length; ++f)
          if (g = d2[f], null == g.to)
            (h2 = Pb(n, g.marker), h2) ? c && (g.to = null == h2.to ? null : h2.to + e) : g.to = a2;
      }
      if (n)
        for (a2 = 0; a2 < n.length; ++a2)
          f = n[a2], null != f.to && (f.to += e), null == f.from ? Pb(d2, f.marker) || (f.from = e, c && (d2 || (d2 = [])).push(f)) : (f.from += e, c && (d2 || (d2 = [])).push(f));
      d2 && (d2 = Fe(d2));
      n && n != d2 && (n = Fe(n));
      a2 = [d2];
      if (!c) {
        b = b.text.length - 2;
        var p;
        if (0 < b && d2)
          for (c = 0; c < d2.length; ++c)
            null == d2[c].to && (p || (p = [])).push(new Dc(d2[c].marker, null, null));
        for (d2 = 0; d2 < b; ++d2)
          a2.push(p);
        a2.push(n);
      }
      return a2;
    }
    function Fe(a2) {
      for (var b = 0; b < a2.length; ++b) {
        var d2 = a2[b];
        null != d2.from && d2.from == d2.to && false !== d2.marker.clearWhenEmpty && a2.splice(b--, 1);
      }
      return a2.length ? a2 : null;
    }
    function Hg(a2, b, d2) {
      var c = null;
      a2.iter(b.line, d2.line + 1, function(m2) {
        if (m2.markedSpans)
          for (var n = 0; n < m2.markedSpans.length; ++n) {
            var p = m2.markedSpans[n].marker;
            !p.readOnly || c && -1 != ea(c, p) || (c || (c = [])).push(p);
          }
      });
      if (!c)
        return null;
      a2 = [{ from: b, to: d2 }];
      for (b = 0; b < c.length; ++b) {
        d2 = c[b];
        for (var e = d2.find(0), f = 0; f < a2.length; ++f) {
          var g = a2[f];
          if (!(0 > B(g.to, e.from) || 0 < B(g.from, e.to))) {
            var h2 = [f, 1], k = B(g.from, e.from), l = B(g.to, e.to);
            (0 > k || !d2.inclusiveLeft && !k) && h2.push({ from: g.from, to: e.from });
            (0 < l || !d2.inclusiveRight && !l) && h2.push({ from: e.to, to: g.to });
            a2.splice.apply(a2, h2);
            f += h2.length - 3;
          }
        }
      }
      return a2;
    }
    function Ge(a2) {
      var b = a2.markedSpans;
      if (b) {
        for (var d2 = 0; d2 < b.length; ++d2)
          b[d2].marker.detachLine(a2);
        a2.markedSpans = null;
      }
    }
    function He(a2, b) {
      if (b) {
        for (var d2 = 0; d2 < b.length; ++d2)
          b[d2].marker.attachLine(a2);
        a2.markedSpans = b;
      }
    }
    function wd(a2, b) {
      var d2 = a2.lines.length - b.lines.length;
      if (0 != d2)
        return d2;
      d2 = a2.find();
      var c = b.find(), e = B(d2.from, c.from) || (a2.inclusiveLeft ? -1 : 0) - (b.inclusiveLeft ? -1 : 0);
      return e ? -e : (d2 = B(d2.to, c.to) || (a2.inclusiveRight ? 1 : 0) - (b.inclusiveRight ? 1 : 0)) ? d2 : b.id - a2.id;
    }
    function sb(a2, b) {
      a2 = Ka && a2.markedSpans;
      if (a2) {
        for (var d2, c = 0; c < a2.length; ++c)
          if (d2 = a2[c], d2.marker.collapsed && null == (b ? d2.from : d2.to) && (!e || 0 > wd(e, d2.marker)))
            var e = d2.marker;
      }
      return e;
    }
    function Ie(a2, b, d2, c, e) {
      a2 = w(a2, b);
      if (a2 = Ka && a2.markedSpans)
        for (b = 0; b < a2.length; ++b) {
          var f = a2[b];
          if (f.marker.collapsed) {
            var g = f.marker.find(0), h2 = B(g.from, d2) || (f.marker.inclusiveLeft ? -1 : 0) - (e.inclusiveLeft ? -1 : 0), k = B(g.to, c) || (f.marker.inclusiveRight ? 1 : 0) - (e.inclusiveRight ? 1 : 0);
            if (!(0 <= h2 && 0 >= k || 0 >= h2 && 0 <= k) && (0 >= h2 && (f.marker.inclusiveRight && e.inclusiveLeft ? 0 <= B(g.to, d2) : 0 < B(g.to, d2)) || 0 <= h2 && (f.marker.inclusiveRight && e.inclusiveLeft ? 0 >= B(g.from, c) : 0 > B(g.from, c))))
              return true;
          }
        }
    }
    function za(a2) {
      for (var b; b = sb(a2, true); )
        a2 = b.find(-1, true).line;
      return a2;
    }
    function xd(a2, b) {
      a2 = w(a2, b);
      var d2 = za(a2);
      return a2 == d2 ? b : N(d2);
    }
    function Je(a2, b) {
      if (b > a2.lastLine())
        return b;
      var d2 = w(a2, b);
      if (!Pa(a2, d2))
        return b;
      for (; a2 = sb(d2, false); )
        d2 = a2.find(1, true).line;
      return N(d2) + 1;
    }
    function Pa(a2, b) {
      var d2 = Ka && b.markedSpans;
      if (d2) {
        for (var c, e = 0; e < d2.length; ++e)
          if (c = d2[e], c.marker.collapsed && (null == c.from || !c.marker.widgetNode && 0 == c.from && c.marker.inclusiveLeft && yd(a2, b, c)))
            return true;
      }
    }
    function yd(a2, b, d2) {
      if (null == d2.to)
        return b = d2.marker.find(1, true), yd(a2, b.line, Pb(b.line.markedSpans, d2.marker));
      if (d2.marker.inclusiveRight && d2.to == b.text.length)
        return true;
      for (var c, e = 0; e < b.markedSpans.length; ++e)
        if (c = b.markedSpans[e], c.marker.collapsed && !c.marker.widgetNode && c.from == d2.to && (null == c.to || c.to != d2.from) && (c.marker.inclusiveLeft || d2.marker.inclusiveRight) && yd(a2, b, c))
          return true;
    }
    function Ga(a2) {
      a2 = za(a2);
      for (var b = 0, d2 = a2.parent, c = 0; c < d2.lines.length; ++c) {
        var e = d2.lines[c];
        if (e == a2)
          break;
        else
          b += e.height;
      }
      for (a2 = d2.parent; a2; d2 = a2, a2 = d2.parent)
        for (c = 0; c < a2.children.length && (e = a2.children[c], e != d2); ++c)
          b += e.height;
      return b;
    }
    function Ec(a2) {
      if (0 == a2.height)
        return 0;
      for (var b = a2.text.length, d2, c = a2; d2 = sb(c, true); )
        d2 = d2.find(0, true), c = d2.from.line, b += d2.from.ch - d2.to.ch;
      for (c = a2; d2 = sb(c, false); )
        a2 = d2.find(0, true), b -= c.text.length - a2.from.ch, c = a2.to.line, b += c.text.length - a2.to.ch;
      return b;
    }
    function zd(a2) {
      var b = a2.display;
      a2 = a2.doc;
      b.maxLine = w(a2, a2.first);
      b.maxLineLength = Ec(b.maxLine);
      b.maxLineChanged = true;
      a2.iter(function(d2) {
        var c = Ec(d2);
        c > b.maxLineLength && (b.maxLineLength = c, b.maxLine = d2);
      });
    }
    function Ke(a2, b) {
      if (!a2 || /^\s*$/.test(a2))
        return null;
      b = b.addModeClass ? Ig : Jg;
      return b[a2] || (b[a2] = a2.replace(
        /\S+/g,
        "cm-$&"
      ));
    }
    function Le(a2, b) {
      var d2 = M("span", null, null, fa ? "padding-right: .1px" : null);
      d2 = { pre: M("pre", [d2], "CodeMirror-line"), content: d2, col: 0, pos: 0, cm: a2, trailingSpace: false, splitSpaces: a2.getOption("lineWrapping") };
      b.measure = {};
      for (var c = 0; c <= (b.rest ? b.rest.length : 0); c++) {
        var e = c ? b.rest[c - 1] : b.line, f = void 0;
        d2.pos = 0;
        d2.addToken = Kg;
        var g = a2.display.measure;
        if (null != Ad)
          g = Ad;
        else {
          var h2 = D(g, document.createTextNode("AÿÆA")), k = Qb(h2, 0, 1).getBoundingClientRect();
          h2 = Qb(h2, 1, 2).getBoundingClientRect();
          E(g);
          g = k && k.left != k.right ? Ad = 3 > h2.right - k.right : false;
        }
        g && (f = Ja(e, a2.doc.direction)) && (d2.addToken = Lg(d2.addToken, f));
        d2.map = [];
        var l = b != a2.display.externalMeasured && N(e);
        a: {
          var m2 = h2 = k = g = void 0, n = void 0, p = void 0, q = void 0;
          f = d2;
          l = Ae(a2, e, l);
          var r = e.markedSpans, u = e.text, A = 0;
          if (r)
            for (var Y = u.length, x2 = 0, P = 1, K = "", Q = 0; ; ) {
              if (Q == x2) {
                n = m2 = h2 = p = "";
                k = g = null;
                Q = Infinity;
                for (var S = [], F = void 0, R2 = 0; R2 < r.length; ++R2) {
                  var H = r[R2], L = H.marker;
                  if ("bookmark" == L.type && H.from == x2 && L.widgetNode)
                    S.push(L);
                  else if (H.from <= x2 && (null == H.to || H.to > x2 || L.collapsed && H.to == x2 && H.from == x2)) {
                    null != H.to && H.to != x2 && Q > H.to && (Q = H.to, m2 = "");
                    L.className && (n += " " + L.className);
                    L.css && (p = (p ? p + ";" : "") + L.css);
                    L.startStyle && H.from == x2 && (h2 += " " + L.startStyle);
                    L.endStyle && H.to == Q && (F || (F = [])).push(L.endStyle, H.to);
                    L.title && ((g || (g = {})).title = L.title);
                    if (L.attributes)
                      for (var ha in L.attributes)
                        (g || (g = {}))[ha] = L.attributes[ha];
                    L.collapsed && (!k || 0 > wd(k.marker, L)) && (k = H);
                  } else
                    H.from > x2 && Q > H.from && (Q = H.from);
                }
                if (F)
                  for (R2 = 0; R2 < F.length; R2 += 2)
                    F[R2 + 1] == Q && (m2 += " " + F[R2]);
                if (!k || k.from == x2)
                  for (F = 0; F < S.length; ++F)
                    Me(
                      f,
                      0,
                      S[F]
                    );
                if (k && (k.from || 0) == x2) {
                  Me(f, (null == k.to ? Y + 1 : k.to) - x2, k.marker, null == k.from);
                  if (null == k.to)
                    break a;
                  k.to == x2 && (k = false);
                }
              }
              if (x2 >= Y)
                break;
              for (S = Math.min(Y, Q); ; ) {
                if (K) {
                  F = x2 + K.length;
                  k || (R2 = F > S ? K.slice(0, S - x2) : K, f.addToken(f, R2, q ? q + n : n, h2, x2 + R2.length == Q ? m2 : "", p, g));
                  if (F >= S) {
                    K = K.slice(S - x2);
                    x2 = S;
                    break;
                  }
                  x2 = F;
                  h2 = "";
                }
                K = u.slice(A, A = l[P++]);
                q = Ke(l[P++], f.cm.options);
              }
            }
          else
            for (g = 1; g < l.length; g += 2)
              f.addToken(f, u.slice(A, A = l[g]), Ke(l[g + 1], f.cm.options));
        }
        e.styleClasses && (e.styleClasses.bgClass && (d2.bgClass = fd(
          e.styleClasses.bgClass,
          d2.bgClass || ""
        )), e.styleClasses.textClass && (d2.textClass = fd(e.styleClasses.textClass, d2.textClass || "")));
        0 == d2.map.length && (e = d2.map, f = e.push, g = d2.content, k = g.appendChild, h2 = a2.display.measure, null == Bd && (m2 = v("span", "‚Äã"), D(h2, v("span", [m2, document.createTextNode("x")])), 0 != h2.firstChild.offsetHeight && (Bd = 1 >= m2.offsetWidth && 2 < m2.offsetHeight && !(G && 8 > T))), h2 = Bd ? v("span", "‚Äã") : v("span", "¬†", null, "display: inline-block; width: 1px; margin-right: -1px"), h2.setAttribute("cm-text", ""), f.call(e, 0, 0, k.call(
          g,
          h2
        )));
        0 == c ? (b.measure.map = d2.map, b.measure.cache = {}) : ((b.measure.maps || (b.measure.maps = [])).push(d2.map), (b.measure.caches || (b.measure.caches = [])).push({}));
      }
      fa && (ha = d2.content.lastChild, /\bcm-tab\b/.test(ha.className) || ha.querySelector && ha.querySelector(".cm-tab")) && (d2.content.className = "cm-tab-wrap-hack");
      W(a2, "renderLine", a2, b.line, d2.pre);
      d2.pre.className && (d2.textClass = fd(d2.pre.className, d2.textClass || ""));
      return d2;
    }
    function Mg(a2) {
      var b = v("span", "‚Ä¢", "cm-invalidchar");
      b.title = "\\u" + a2.charCodeAt(0).toString(16);
      b.setAttribute("aria-label", b.title);
      return b;
    }
    function Kg(a2, b, d2, c, e, f, g) {
      if (b) {
        if (a2.splitSpaces) {
          var h2 = a2.trailingSpace;
          if (1 < b.length && !/  /.test(b))
            h2 = b;
          else {
            for (var k = "", l = 0; l < b.length; l++) {
              var m2 = b.charAt(l);
              " " != m2 || !h2 || l != b.length - 1 && 32 != b.charCodeAt(l + 1) || (m2 = "¬†");
              k += m2;
              h2 = " " == m2;
            }
            h2 = k;
          }
        } else
          h2 = b;
        k = h2;
        l = a2.cm.state.specialChars;
        m2 = false;
        if (l.test(b)) {
          h2 = document.createDocumentFragment();
          for (var n = 0; ; ) {
            l.lastIndex = n;
            var p = l.exec(b), q = p ? p.index - n : b.length - n;
            if (q) {
              var r = document.createTextNode(k.slice(n, n + q));
              G && 9 > T ? h2.appendChild(v("span", [r])) : h2.appendChild(r);
              a2.map.push(a2.pos, a2.pos + q, r);
              a2.col += q;
              a2.pos += q;
            }
            if (!p)
              break;
            n += q + 1;
            "	" == p[0] ? (p = a2.cm.options.tabSize, p -= a2.col % p, q = h2.appendChild(v("span", id2(p), "cm-tab")), q.setAttribute("role", "presentation"), q.setAttribute("cm-text", "	"), a2.col += p) : ("\r" == p[0] || "\n" == p[0] ? (q = h2.appendChild(v("span", "\r" == p[0] ? "‚êç" : "‚ê§", "cm-invalidchar")), q.setAttribute("cm-text", p[0])) : (q = a2.cm.options.specialCharPlaceholder(p[0]), q.setAttribute("cm-text", p[0]), G && 9 > T ? h2.appendChild(v("span", [q])) : h2.appendChild(q)), a2.col += 1);
            a2.map.push(a2.pos, a2.pos + 1, q);
            a2.pos++;
          }
        } else
          a2.col += b.length, h2 = document.createTextNode(k), a2.map.push(a2.pos, a2.pos + b.length, h2), G && 9 > T && (m2 = true), a2.pos += b.length;
        a2.trailingSpace = 32 == k.charCodeAt(b.length - 1);
        if (d2 || c || e || m2 || f || g) {
          b = d2 || "";
          c && (b += c);
          e && (b += e);
          c = v("span", [h2], b, f);
          if (g)
            for (var u in g)
              g.hasOwnProperty(u) && "style" != u && "class" != u && c.setAttribute(u, g[u]);
          return a2.content.appendChild(c);
        }
        a2.content.appendChild(h2);
      }
    }
    function Lg(a2, b) {
      return function(d2, c, e, f, g, h2, k) {
        e = e ? e + " cm-force-border" : "cm-force-border";
        for (var l = d2.pos, m2 = l + c.length; ; ) {
          for (var n = void 0, p = 0; p < b.length && !(n = b[p], n.to > l && n.from <= l); p++)
            ;
          if (n.to >= m2)
            return a2(d2, c, e, f, g, h2, k);
          a2(d2, c.slice(0, n.to - l), e, f, null, h2, k);
          f = null;
          c = c.slice(n.to - l);
          l = n.to;
        }
      };
    }
    function Me(a2, b, d2, c) {
      var e = !c && d2.widgetNode;
      e && a2.map.push(a2.pos, a2.pos + b, e);
      !c && a2.cm.display.input.needsContentAttribute && (e || (e = a2.content.appendChild(document.createElement("span"))), e.setAttribute("cm-marker", d2.id));
      e && (a2.cm.display.input.setUneditable(e), a2.content.appendChild(e));
      a2.pos += b;
      a2.trailingSpace = false;
    }
    function Ne(a2, b, d2) {
      for (var c = this.line = b, e; c = sb(c, false); )
        c = c.find(1, true).line, (e || (e = [])).push(c);
      this.size = (this.rest = e) ? N(J(this.rest)) - d2 + 1 : 1;
      this.node = this.text = null;
      this.hidden = Pa(a2, b);
    }
    function Fc(a2, b, d2) {
      var c = [], e;
      for (e = b; e < d2; )
        b = new Ne(a2.doc, w(a2.doc, e), e), e += b.size, c.push(b);
      return c;
    }
    function Ng(a2, b) {
      if (a2 = a2.ownsGroup)
        try {
          var d2 = a2.delayedCallbacks, c = 0;
          do {
            for (; c < d2.length; c++)
              d2[c].call(null);
            for (var e = 0; e < a2.ops.length; e++) {
              var f = a2.ops[e];
              if (f.cursorActivityHandlers)
                for (; f.cursorActivityCalled < f.cursorActivityHandlers.length; )
                  f.cursorActivityHandlers[f.cursorActivityCalled++].call(null, f.cm);
            }
          } while (c < d2.length);
        } finally {
          tb = null, b(a2);
        }
    }
    function aa(a2, b) {
      var d2 = a2._handlers && a2._handlers[b] || yc;
      if (d2.length) {
        var c = Array.prototype.slice.call(arguments, 2);
        if (tb)
          var e = tb.delayedCallbacks;
        else
          Rb ? e = Rb : (e = Rb = [], setTimeout(Og, 0));
        for (var f = function(h2) {
          e.push(function() {
            return d2[h2].apply(null, c);
          });
        }, g = 0; g < d2.length; ++g)
          f(g);
      }
    }
    function Og() {
      var a2 = Rb;
      Rb = null;
      for (var b = 0; b < a2.length; ++b)
        a2[b]();
    }
    function Oe(a2, b, d2, c) {
      for (var e = 0; e < b.changes.length; e++) {
        var f = b.changes[e];
        if ("text" == f) {
          f = a2;
          var g = b, h2 = g.text.className, k = Pe(f, g);
          g.text == g.node && (g.node = k.pre);
          g.text.parentNode.replaceChild(k.pre, g.text);
          g.text = k.pre;
          k.bgClass != g.bgClass || k.textClass != g.textClass ? (g.bgClass = k.bgClass, g.textClass = k.textClass, Cd(f, g)) : h2 && (g.text.className = h2);
        } else if ("gutter" == f)
          Qe(a2, b, d2, c);
        else if ("class" == f)
          Cd(a2, b);
        else if ("widget" == f) {
          f = a2;
          g = b;
          h2 = c;
          g.alignable && (g.alignable = null);
          k = y2("CodeMirror-linewidget");
          for (var l = g.node.firstChild, m2; l; l = m2)
            m2 = l.nextSibling, k.test(l.className) && g.node.removeChild(l);
          Re(f, g, h2);
        }
      }
      b.changes = null;
    }
    function Sb(a2) {
      a2.node == a2.text && (a2.node = v("div", null, null, "position: relative"), a2.text.parentNode && a2.text.parentNode.replaceChild(a2.node, a2.text), a2.node.appendChild(a2.text), G && 8 > T && (a2.node.style.zIndex = 2));
      return a2.node;
    }
    function Pe(a2, b) {
      var d2 = a2.display.externalMeasured;
      return d2 && d2.line == b.line ? (a2.display.externalMeasured = null, b.measure = d2.measure, d2.built) : Le(a2, b);
    }
    function Cd(a2, b) {
      var d2 = b.bgClass ? b.bgClass + " " + (b.line.bgClass || "") : b.line.bgClass;
      d2 && (d2 += " CodeMirror-linebackground");
      if (b.background)
        d2 ? b.background.className = d2 : (b.background.parentNode.removeChild(b.background), b.background = null);
      else if (d2) {
        var c = Sb(b);
        b.background = c.insertBefore(v("div", null, d2), c.firstChild);
        a2.display.input.setUneditable(b.background);
      }
      b.line.wrapClass ? Sb(b).className = b.line.wrapClass : b.node != b.text && (b.node.className = "");
      b.text.className = (b.textClass ? b.textClass + " " + (b.line.textClass || "") : b.line.textClass) || "";
    }
    function Qe(a2, b, d2, c) {
      b.gutter && (b.node.removeChild(b.gutter), b.gutter = null);
      b.gutterBackground && (b.node.removeChild(b.gutterBackground), b.gutterBackground = null);
      if (b.line.gutterClass) {
        var e = Sb(b);
        b.gutterBackground = v("div", null, "CodeMirror-gutter-background " + b.line.gutterClass, "left: " + (a2.options.fixedGutter ? c.fixedPos : -c.gutterTotalWidth) + "px; width: " + c.gutterTotalWidth + "px");
        a2.display.input.setUneditable(b.gutterBackground);
        e.insertBefore(b.gutterBackground, b.text);
      }
      e = b.line.gutterMarkers;
      if (a2.options.lineNumbers || e) {
        var f = Sb(b), g = b.gutter = v("div", null, "CodeMirror-gutter-wrapper", "left: " + (a2.options.fixedGutter ? c.fixedPos : -c.gutterTotalWidth) + "px");
        g.setAttribute("aria-hidden", "true");
        a2.display.input.setUneditable(g);
        f.insertBefore(g, b.text);
        b.line.gutterClass && (g.className += " " + b.line.gutterClass);
        !a2.options.lineNumbers || e && e["CodeMirror-linenumbers"] || (b.lineNumber = g.appendChild(v("div", qd(a2.options, d2), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + c.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + a2.display.lineNumInnerWidth + "px")));
        if (e)
          for (b = 0; b < a2.display.gutterSpecs.length; ++b)
            d2 = a2.display.gutterSpecs[b].className, (f = e.hasOwnProperty(d2) && e[d2]) && g.appendChild(v("div", [f], "CodeMirror-gutter-elt", "left: " + c.gutterLeft[d2] + "px; width: " + c.gutterWidth[d2] + "px"));
      }
    }
    function Pg(a2, b, d2, c) {
      var e = Pe(a2, b);
      b.text = b.node = e.pre;
      e.bgClass && (b.bgClass = e.bgClass);
      e.textClass && (b.textClass = e.textClass);
      Cd(a2, b);
      Qe(a2, b, d2, c);
      Re(a2, b, c);
      return b.node;
    }
    function Re(a2, b, d2) {
      Se(a2, b.line, b, d2, true);
      if (b.rest)
        for (var c = 0; c < b.rest.length; c++)
          Se(
            a2,
            b.rest[c],
            b,
            d2,
            false
          );
    }
    function Se(a2, b, d2, c, e) {
      if (b.widgets) {
        var f = Sb(d2), g = 0;
        for (b = b.widgets; g < b.length; ++g) {
          var h2 = b[g], k = v("div", [h2.node], "CodeMirror-linewidget" + (h2.className ? " " + h2.className : ""));
          h2.handleMouseEvents || k.setAttribute("cm-ignore-events", "true");
          var l = h2, m2 = k, n = c;
          if (l.noHScroll) {
            (d2.alignable || (d2.alignable = [])).push(m2);
            var p = n.wrapperWidth;
            m2.style.left = n.fixedPos + "px";
            l.coverGutter || (p -= n.gutterTotalWidth, m2.style.paddingLeft = n.gutterTotalWidth + "px");
            m2.style.width = p + "px";
          }
          l.coverGutter && (m2.style.zIndex = 5, m2.style.position = "relative", l.noHScroll || (m2.style.marginLeft = -n.gutterTotalWidth + "px"));
          a2.display.input.setUneditable(k);
          e && h2.above ? f.insertBefore(k, d2.gutter || d2.text) : f.appendChild(k);
          aa(h2, "redraw");
        }
      }
    }
    function Tb(a2) {
      if (null != a2.height)
        return a2.height;
      var b = a2.doc.cm;
      if (!b)
        return 0;
      if (!ja(document.body, a2.node)) {
        var d2 = "position: relative;";
        a2.coverGutter && (d2 += "margin-left: -" + b.display.gutters.offsetWidth + "px;");
        a2.noHScroll && (d2 += "width: " + b.display.wrapper.clientWidth + "px;");
        D(b.display.measure, v(
          "div",
          [a2.node],
          null,
          d2
        ));
      }
      return a2.height = a2.node.parentNode.offsetHeight;
    }
    function La(a2, b) {
      for (b = b.target || b.srcElement; b != a2.wrapper; b = b.parentNode)
        if (!b || 1 == b.nodeType && "true" == b.getAttribute("cm-ignore-events") || b.parentNode == a2.sizer && b != a2.mover)
          return true;
    }
    function Dd(a2) {
      return a2.mover.offsetHeight - a2.lineSpace.offsetHeight;
    }
    function Te(a2) {
      if (a2.cachedPaddingH)
        return a2.cachedPaddingH;
      var b = D(a2.measure, v("pre", "x", "CodeMirror-line-like"));
      b = window.getComputedStyle ? window.getComputedStyle(b) : b.currentStyle;
      b = {
        left: parseInt(b.paddingLeft),
        right: parseInt(b.paddingRight)
      };
      isNaN(b.left) || isNaN(b.right) || (a2.cachedPaddingH = b);
      return b;
    }
    function Ha(a2) {
      return 50 - a2.display.nativeBarWidth;
    }
    function cb(a2) {
      return a2.display.scroller.clientWidth - Ha(a2) - a2.display.barWidth;
    }
    function Ed(a2) {
      return a2.display.scroller.clientHeight - Ha(a2) - a2.display.barHeight;
    }
    function Ue(a2, b, d2) {
      if (a2.line == b)
        return { map: a2.measure.map, cache: a2.measure.cache };
      if (a2.rest) {
        for (var c = 0; c < a2.rest.length; c++)
          if (a2.rest[c] == b)
            return { map: a2.measure.maps[c], cache: a2.measure.caches[c] };
        for (b = 0; b < a2.rest.length; b++)
          if (N(a2.rest[b]) > d2)
            return { map: a2.measure.maps[b], cache: a2.measure.caches[b], before: true };
      }
    }
    function Fd(a2, b) {
      if (b >= a2.display.viewFrom && b < a2.display.viewTo)
        return a2.display.view[db(a2, b)];
      if ((a2 = a2.display.externalMeasured) && b >= a2.lineN && b < a2.lineN + a2.size)
        return a2;
    }
    function eb(a2, b) {
      var d2 = N(b), c = Fd(a2, d2);
      c && !c.text ? c = null : c && c.changes && (Oe(a2, c, d2, Gd(a2)), a2.curOp.forceUpdate = true);
      if (!c) {
        var e = za(b);
        c = N(e);
        e = a2.display.externalMeasured = new Ne(a2.doc, e, c);
        e.lineN = c;
        c = e.built = Le(a2, e);
        e.text = c.pre;
        D(
          a2.display.lineMeasure,
          c.pre
        );
        c = e;
      }
      a2 = Ue(c, b, d2);
      return { line: b, view: c, rect: null, map: a2.map, cache: a2.cache, before: a2.before, hasHeights: false };
    }
    function Aa(a2, b, d2, c, e) {
      b.before && (d2 = -1);
      var f = d2 + (c || "");
      if (b.cache.hasOwnProperty(f))
        a2 = b.cache[f];
      else {
        b.rect || (b.rect = b.view.text.getBoundingClientRect());
        if (!b.hasHeights) {
          var g = b.view, h2 = b.rect, k = a2.options.lineWrapping, l = k && cb(a2);
          if (!g.measure.heights || k && g.measure.width != l) {
            var m2 = g.measure.heights = [];
            if (k)
              for (g.measure.width = l, g = g.text.firstChild.getClientRects(), k = 0; k < g.length - 1; k++) {
                l = g[k];
                var n = g[k + 1];
                2 < Math.abs(l.bottom - n.bottom) && m2.push((l.bottom + n.top) / 2 - h2.top);
              }
            m2.push(h2.bottom - h2.top);
          }
          b.hasHeights = true;
        }
        m2 = c;
        g = Ve(b.map, d2, m2);
        c = g.node;
        h2 = g.start;
        k = g.end;
        d2 = g.collapse;
        if (3 == c.nodeType) {
          for (var p = 0; 4 > p; p++) {
            for (; h2 && kd(b.line.text.charAt(g.coverStart + h2)); )
              --h2;
            for (; g.coverStart + k < g.coverEnd && kd(b.line.text.charAt(g.coverStart + k)); )
              ++k;
            if (G && 9 > T && 0 == h2 && k == g.coverEnd - g.coverStart)
              var q = c.parentNode.getBoundingClientRect();
            else {
              q = Qb(c, h2, k).getClientRects();
              k = We;
              if ("left" == m2)
                for (l = 0; l < q.length && (k = q[l]).left == k.right; l++)
                  ;
              else
                for (l = q.length - 1; 0 <= l && (k = q[l]).left == k.right; l--)
                  ;
              q = k;
            }
            if (q.left || q.right || 0 == h2)
              break;
            k = h2;
            --h2;
            d2 = "right";
          }
          G && 11 > T && ((p = !window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI) || (null != Hd ? p = Hd : (m2 = D(a2.display.measure, v("span", "x")), p = m2.getBoundingClientRect(), m2 = Qb(m2, 0, 1).getBoundingClientRect(), p = Hd = 1 < Math.abs(p.left - m2.left)), p = !p), p || (p = screen.logicalXDPI / screen.deviceXDPI, m2 = screen.logicalYDPI / screen.deviceYDPI, q = {
            left: q.left * p,
            right: q.right * p,
            top: q.top * m2,
            bottom: q.bottom * m2
          }));
        } else
          0 < h2 && (d2 = m2 = "right"), q = a2.options.lineWrapping && 1 < (p = c.getClientRects()).length ? p["right" == m2 ? p.length - 1 : 0] : c.getBoundingClientRect();
        !(G && 9 > T) || h2 || q && (q.left || q.right) || (q = (q = c.parentNode.getClientRects()[0]) ? { left: q.left, right: q.left + ub(a2.display), top: q.top, bottom: q.bottom } : We);
        c = q.top - b.rect.top;
        h2 = q.bottom - b.rect.top;
        p = (c + h2) / 2;
        m2 = b.view.measure.heights;
        for (g = 0; g < m2.length - 1 && !(p < m2[g]); g++)
          ;
        d2 = { left: ("right" == d2 ? q.right : q.left) - b.rect.left, right: ("left" == d2 ? q.left : q.right) - b.rect.left, top: g ? m2[g - 1] : 0, bottom: m2[g] };
        q.left || q.right || (d2.bogus = true);
        a2.options.singleCursorHeightPerLine || (d2.rtop = c, d2.rbottom = h2);
        a2 = d2;
        a2.bogus || (b.cache[f] = a2);
      }
      return { left: a2.left, right: a2.right, top: e ? a2.rtop : a2.top, bottom: e ? a2.rbottom : a2.bottom };
    }
    function Ve(a2, b, d2) {
      for (var c, e, f, g, h2, k, l = 0; l < a2.length; l += 3) {
        h2 = a2[l];
        k = a2[l + 1];
        if (b < h2)
          e = 0, f = 1, g = "left";
        else if (b < k)
          e = b - h2, f = e + 1;
        else if (l == a2.length - 3 || b == k && a2[l + 3] > b)
          f = k - h2, e = f - 1, b >= k && (g = "right");
        if (null != e) {
          c = a2[l + 2];
          h2 == k && d2 == (c.insertLeft ? "left" : "right") && (g = d2);
          if ("left" == d2 && 0 == e)
            for (; l && a2[l - 2] == a2[l - 3] && a2[l - 1].insertLeft; )
              c = a2[(l -= 3) + 2], g = "left";
          if ("right" == d2 && e == k - h2)
            for (; l < a2.length - 3 && a2[l + 3] == a2[l + 4] && !a2[l + 5].insertLeft; )
              c = a2[(l += 3) + 2], g = "right";
          break;
        }
      }
      return { node: c, start: e, end: f, collapse: g, coverStart: h2, coverEnd: k };
    }
    function Xe(a2) {
      if (a2.measure && (a2.measure.cache = {}, a2.measure.heights = null, a2.rest))
        for (var b = 0; b < a2.rest.length; b++)
          a2.measure.caches[b] = {};
    }
    function Ye(a2) {
      a2.display.externalMeasure = null;
      E(a2.display.lineMeasure);
      for (var b = 0; b < a2.display.view.length; b++)
        Xe(a2.display.view[b]);
    }
    function Ub(a2) {
      Ye(a2);
      a2.display.cachedCharWidth = a2.display.cachedTextHeight = a2.display.cachedPaddingH = null;
      a2.options.lineWrapping || (a2.display.maxLineChanged = true);
      a2.display.lineNumChars = null;
    }
    function Ze(a2) {
      return Qa && Gc ? -(a2.body.getBoundingClientRect().left - parseInt(getComputedStyle(a2.body).marginLeft)) : a2.defaultView.pageXOffset || (a2.documentElement || a2.body).scrollLeft;
    }
    function $e(a2) {
      return Qa && Gc ? -(a2.body.getBoundingClientRect().top - parseInt(getComputedStyle(a2.body).marginTop)) : a2.defaultView.pageYOffset || (a2.documentElement || a2.body).scrollTop;
    }
    function Id(a2) {
      a2 = za(a2).widgets;
      var b = 0;
      if (a2)
        for (var d2 = 0; d2 < a2.length; ++d2)
          a2[d2].above && (b += Tb(a2[d2]));
      return b;
    }
    function Hc(a2, b, d2, c, e) {
      e || (e = Id(b), d2.top += e, d2.bottom += e);
      if ("line" == c)
        return d2;
      c || (c = "local");
      b = Ga(b);
      b = "local" == c ? b + a2.display.lineSpace.offsetTop : b - a2.display.viewOffset;
      if ("page" == c || "window" == c)
        e = a2.display.lineSpace.getBoundingClientRect(), b += e.top + ("window" == c ? 0 : $e(qa(a2))), a2 = e.left + ("window" == c ? 0 : Ze(qa(a2))), d2.left += a2, d2.right += a2;
      d2.top += b;
      d2.bottom += b;
      return d2;
    }
    function af(a2, b, d2) {
      if ("div" == d2)
        return b;
      var c = b.left;
      b = b.top;
      "page" == d2 ? (c -= Ze(qa(a2)), b -= $e(qa(a2))) : "local" != d2 && d2 || (d2 = a2.display.sizer.getBoundingClientRect(), c += d2.left, b += d2.top);
      a2 = a2.display.lineSpace.getBoundingClientRect();
      return { left: c - a2.left, top: b - a2.top };
    }
    function Ic(a2, b, d2, c, e) {
      c || (c = w(a2.doc, b.line));
      var f = c;
      b = b.ch;
      c = Aa(a2, eb(a2, c), b, e);
      return Hc(a2, f, c, d2);
    }
    function Ba(a2, b, d2, c, e, f) {
      function g(p, q) {
        p = Aa(a2, e, p, q ? "right" : "left", f);
        q ? p.left = p.right : p.right = p.left;
        return Hc(a2, c, p, d2);
      }
      function h2(p, q, r) {
        return g(r ? p - 1 : p, 1 == k[q].level != r);
      }
      c = c || w(a2.doc, b.line);
      e || (e = eb(a2, c));
      var k = Ja(c, a2.doc.direction), l = b.ch;
      b = b.sticky;
      l >= c.text.length ? (l = c.text.length, b = "before") : 0 >= l && (l = 0, b = "after");
      if (!k)
        return g("before" == b ? l - 1 : l, "before" == b);
      var m2 = Kb(k, l, b), n = Lb;
      m2 = h2(l, m2, "before" == b);
      null != n && (m2.other = h2(l, n, "before" != b));
      return m2;
    }
    function bf(a2, b) {
      var d2 = 0;
      b = C(a2.doc, b);
      a2.options.lineWrapping || (d2 = ub(a2.display) * b.ch);
      b = w(a2.doc, b.line);
      a2 = Ga(b) + a2.display.lineSpace.offsetTop;
      return { left: d2, right: d2, top: a2, bottom: a2 + b.height };
    }
    function Jd(a2, b, d2, c, e) {
      a2 = t(a2, b, d2);
      a2.xRel = e;
      c && (a2.outside = c);
      return a2;
    }
    function Kd(a2, b, d2) {
      var c = a2.doc;
      d2 += a2.display.viewOffset;
      if (0 > d2)
        return Jd(c.first, 0, null, -1, -1);
      var e = bb(c, d2), f = c.first + c.size - 1;
      if (e > f)
        return Jd(c.first + c.size - 1, w(c, f).text.length, null, 1, 1);
      0 > b && (b = 0);
      for (var g = w(c, e); ; ) {
        f = Qg(a2, g, e, b, d2);
        var h2 = void 0;
        var k = f.ch + (0 < f.xRel || 0 < f.outside ? 1 : 0);
        if (g = Ka && g.markedSpans)
          for (var l = 0; l < g.length; ++l) {
            var m2 = g[l];
            m2.marker.collapsed && (null == m2.from || m2.from < k) && (null == m2.to || m2.to > k) && (!h2 || 0 > wd(h2, m2.marker)) && (h2 = m2.marker);
          }
        if (!h2)
          return f;
        f = h2.find(1);
        if (f.line == e)
          return f;
        g = w(c, e = f.line);
      }
    }
    function cf(a2, b, d2, c) {
      c -= Id(b);
      b = b.text.length;
      var e = Jb(function(f) {
        return Aa(a2, d2, f - 1).bottom <= c;
      }, b, 0);
      b = Jb(function(f) {
        return Aa(a2, d2, f).top > c;
      }, e, b);
      return { begin: e, end: b };
    }
    function df(a2, b, d2, c) {
      d2 || (d2 = eb(a2, b));
      c = Hc(a2, b, Aa(a2, d2, c), "line").top;
      return cf(a2, b, d2, c);
    }
    function Ld(a2, b, d2, c) {
      return a2.bottom <= d2 ? false : a2.top > d2 ? true : (c ? a2.left : a2.right) > b;
    }
    function Qg(a2, b, d2, c, e) {
      e -= Ga(b);
      var f = eb(a2, b), g = Id(b), h2 = 0, k = b.text.length, l = true, m2 = Ja(b, a2.doc.direction);
      m2 && (m2 = (a2.options.lineWrapping ? Rg : Sg)(a2, b, d2, f, m2, c, e), h2 = (l = 1 != m2.level) ? m2.from : m2.to - 1, k = l ? m2.to : m2.from - 1);
      var n = null, p = null;
      m2 = Jb(function(r) {
        var u = Aa(a2, f, r);
        u.top += g;
        u.bottom += g;
        if (!Ld(u, c, e, false))
          return false;
        u.top <= e && u.left <= c && (n = r, p = u);
        return true;
      }, h2, k);
      var q = false;
      p ? (h2 = c - p.left < p.right - c, l = h2 == l, m2 = n + (l ? 0 : 1), l = l ? "after" : "before", h2 = h2 ? p.left : p.right) : (l || m2 != k && m2 != h2 || m2++, l = 0 == m2 ? "after" : m2 == b.text.length ? "before" : Aa(a2, f, m2 - (l ? 1 : 0)).bottom + g <= e == l ? "after" : "before", q = Ba(a2, t(d2, m2, l), "line", b, f), h2 = q.left, q = e < q.top ? -1 : e >= q.bottom ? 1 : 0);
      m2 = se(b.text, m2, 1);
      return Jd(d2, m2, l, q, c - h2);
    }
    function Sg(a2, b, d2, c, e, f, g) {
      var h2 = Jb(function(m2) {
        m2 = e[m2];
        var n = 1 != m2.level;
        return Ld(Ba(a2, t(d2, n ? m2.to : m2.from, n ? "before" : "after"), "line", b, c), f, g, true);
      }, 0, e.length - 1), k = e[h2];
      if (0 < h2) {
        var l = 1 != k.level;
        l = Ba(a2, t(d2, l ? k.from : k.to, l ? "after" : "before"), "line", b, c);
        Ld(l, f, g, true) && l.top > g && (k = e[h2 - 1]);
      }
      return k;
    }
    function Rg(a2, b, d2, c, e, f, g) {
      g = cf(a2, b, c, g);
      d2 = g.begin;
      g = g.end;
      /\s/.test(b.text.charAt(g - 1)) && g--;
      for (var h2 = b = null, k = 0; k < e.length; k++) {
        var l = e[k];
        if (!(l.from >= g || l.to <= d2)) {
          var m2 = Aa(a2, c, 1 != l.level ? Math.min(g, l.to) - 1 : Math.max(d2, l.from)).right;
          m2 = m2 < f ? f - m2 + 1e9 : m2 - f;
          if (!b || h2 > m2)
            b = l, h2 = m2;
        }
      }
      b || (b = e[e.length - 1]);
      b.from < d2 && (b = { from: d2, to: b.to, level: b.level });
      b.to > g && (b = { from: b.from, to: g, level: b.level });
      return b;
    }
    function vb(a2) {
      if (null != a2.cachedTextHeight)
        return a2.cachedTextHeight;
      if (null == fb) {
        fb = v("pre", null, "CodeMirror-line-like");
        for (var b = 0; 49 > b; ++b)
          fb.appendChild(document.createTextNode("x")), fb.appendChild(v("br"));
        fb.appendChild(document.createTextNode("x"));
      }
      D(
        a2.measure,
        fb
      );
      b = fb.offsetHeight / 50;
      3 < b && (a2.cachedTextHeight = b);
      E(a2.measure);
      return b || 1;
    }
    function ub(a2) {
      if (null != a2.cachedCharWidth)
        return a2.cachedCharWidth;
      var b = v("span", "xxxxxxxxxx"), d2 = v("pre", [b], "CodeMirror-line-like");
      D(a2.measure, d2);
      b = b.getBoundingClientRect();
      b = (b.right - b.left) / 10;
      2 < b && (a2.cachedCharWidth = b);
      return b || 10;
    }
    function Gd(a2) {
      for (var b = a2.display, d2 = {}, c = {}, e = b.gutters.clientLeft, f = b.gutters.firstChild, g = 0; f; f = f.nextSibling, ++g) {
        var h2 = a2.display.gutterSpecs[g].className;
        d2[h2] = f.offsetLeft + f.clientLeft + e;
        c[h2] = f.clientWidth;
      }
      return { fixedPos: Md(b), gutterTotalWidth: b.gutters.offsetWidth, gutterLeft: d2, gutterWidth: c, wrapperWidth: b.wrapper.clientWidth };
    }
    function Md(a2) {
      return a2.scroller.getBoundingClientRect().left - a2.sizer.getBoundingClientRect().left;
    }
    function ef(a2) {
      var b = vb(a2.display), d2 = a2.options.lineWrapping, c = d2 && Math.max(5, a2.display.scroller.clientWidth / ub(a2.display) - 3);
      return function(e) {
        if (Pa(a2.doc, e))
          return 0;
        var f = 0;
        if (e.widgets)
          for (var g = 0; g < e.widgets.length; g++)
            e.widgets[g].height && (f += e.widgets[g].height);
        return d2 ? f + (Math.ceil(e.text.length / c) || 1) * b : f + b;
      };
    }
    function Nd(a2) {
      var b = a2.doc, d2 = ef(a2);
      b.iter(function(c) {
        var e = d2(c);
        e != c.height && Ea(c, e);
      });
    }
    function gb(a2, b, d2, c) {
      var e = a2.display;
      if (!d2 && "true" == (b.target || b.srcElement).getAttribute("cm-not-content"))
        return null;
      d2 = e.lineSpace.getBoundingClientRect();
      try {
        var f = b.clientX - d2.left;
        var g = b.clientY - d2.top;
      } catch (k) {
        return null;
      }
      b = Kd(a2, f, g);
      var h2;
      c && 0 < b.xRel && (h2 = w(a2.doc, b.line).text).length == b.ch && (c = wa(h2, h2.length, a2.options.tabSize) - h2.length, b = t(b.line, Math.max(
        0,
        Math.round((f - Te(a2.display).left) / ub(a2.display)) - c
      )));
      return b;
    }
    function db(a2, b) {
      if (b >= a2.display.viewTo)
        return null;
      b -= a2.display.viewFrom;
      if (0 > b)
        return null;
      a2 = a2.display.view;
      for (var d2 = 0; d2 < a2.length; d2++)
        if (b -= a2[d2].size, 0 > b)
          return d2;
    }
    function ma(a2, b, d2, c) {
      null == b && (b = a2.doc.first);
      null == d2 && (d2 = a2.doc.first + a2.doc.size);
      c || (c = 0);
      var e = a2.display;
      c && d2 < e.viewTo && (null == e.updateLineNumbers || e.updateLineNumbers > b) && (e.updateLineNumbers = b);
      a2.curOp.viewChanged = true;
      if (b >= e.viewTo)
        Ka && xd(a2.doc, b) < e.viewTo && Ra(a2);
      else if (d2 <= e.viewFrom)
        Ka && Je(a2.doc, d2 + c) > e.viewFrom ? Ra(a2) : (e.viewFrom += c, e.viewTo += c);
      else if (b <= e.viewFrom && d2 >= e.viewTo)
        Ra(a2);
      else if (b <= e.viewFrom) {
        var f = Jc(a2, d2, d2 + c, 1);
        f ? (e.view = e.view.slice(f.index), e.viewFrom = f.lineN, e.viewTo += c) : Ra(a2);
      } else if (d2 >= e.viewTo)
        (f = Jc(a2, b, b, -1)) ? (e.view = e.view.slice(0, f.index), e.viewTo = f.lineN) : Ra(a2);
      else {
        f = Jc(a2, b, b, -1);
        var g = Jc(a2, d2, d2 + c, 1);
        f && g ? (e.view = e.view.slice(0, f.index).concat(Fc(a2, f.lineN, g.lineN)).concat(e.view.slice(g.index)), e.viewTo += c) : Ra(a2);
      }
      if (a2 = e.externalMeasured)
        d2 < a2.lineN ? a2.lineN += c : b < a2.lineN + a2.size && (e.externalMeasured = null);
    }
    function Sa(a2, b, d2) {
      a2.curOp.viewChanged = true;
      var c = a2.display, e = a2.display.externalMeasured;
      e && b >= e.lineN && b < e.lineN + e.size && (c.externalMeasured = null);
      b < c.viewFrom || b >= c.viewTo || (a2 = c.view[db(a2, b)], null != a2.node && (a2 = a2.changes || (a2.changes = []), -1 == ea(a2, d2) && a2.push(d2)));
    }
    function Ra(a2) {
      a2.display.viewFrom = a2.display.viewTo = a2.doc.first;
      a2.display.view = [];
      a2.display.viewOffset = 0;
    }
    function Jc(a2, b, d2, c) {
      var e = db(a2, b), f = a2.display.view;
      if (!Ka || d2 == a2.doc.first + a2.doc.size)
        return { index: e, lineN: d2 };
      for (var g = a2.display.viewFrom, h2 = 0; h2 < e; h2++)
        g += f[h2].size;
      if (g != b) {
        if (0 < c) {
          if (e == f.length - 1)
            return null;
          b = g + f[e].size - b;
          e++;
        } else
          b = g - b;
        d2 += b;
      }
      for (; xd(a2.doc, d2) != d2; ) {
        if (e == (0 > c ? 0 : f.length - 1))
          return null;
        d2 += c * f[e - (0 > c ? 1 : 0)].size;
        e += c;
      }
      return { index: e, lineN: d2 };
    }
    function ff(a2) {
      a2 = a2.display.view;
      for (var b = 0, d2 = 0; d2 < a2.length; d2++) {
        var c = a2[d2];
        c.hidden || c.node && !c.changes || ++b;
      }
      return b;
    }
    function Vb(a2) {
      a2.display.input.showSelection(a2.display.input.prepareSelection());
    }
    function gf(a2, b) {
      void 0 === b && (b = true);
      var d2 = a2.doc, c = {}, e = c.cursors = document.createDocumentFragment(), f = c.selection = document.createDocumentFragment(), g = a2.options.$customCursor;
      g && (b = true);
      for (var h2 = 0; h2 < d2.sel.ranges.length; h2++)
        if (b || h2 != d2.sel.primIndex) {
          var k = d2.sel.ranges[h2];
          if (!(k.from().line >= a2.display.viewTo || k.to().line < a2.display.viewFrom)) {
            var l = k.empty();
            if (g) {
              var m2 = g(a2, k);
              m2 && Od(a2, m2, e);
            } else
              (l || a2.options.showCursorWhenSelecting) && Od(a2, k.head, e);
            l || Tg(a2, k, f);
          }
        }
      return c;
    }
    function Od(a2, b, d2) {
      var c = Ba(a2, b, "div", null, null, !a2.options.singleCursorHeightPerLine), e = d2.appendChild(v("div", "¬†", "CodeMirror-cursor"));
      e.style.left = c.left + "px";
      e.style.top = c.top + "px";
      e.style.height = Math.max(0, c.bottom - c.top) * a2.options.cursorHeight + "px";
      /\bcm-fat-cursor\b/.test(a2.getWrapperElement().className) && (b = Ic(a2, b, "div", null, null), b = b.right - b.left, e.style.width = (0 < b ? b : a2.defaultCharWidth()) + "px");
      c.other && (a2 = d2.appendChild(v("div", "¬†", "CodeMirror-cursor CodeMirror-secondarycursor")), a2.style.display = "", a2.style.left = c.other.left + "px", a2.style.top = c.other.top + "px", a2.style.height = 0.85 * (c.other.bottom - c.other.top) + "px");
    }
    function Kc(a2, b) {
      return a2.top - b.top || a2.left - b.left;
    }
    function Tg(a2, b, d2) {
      function c(q, r, u, A) {
        0 > r && (r = 0);
        r = Math.round(r);
        A = Math.round(A);
        h2.appendChild(v("div", null, "CodeMirror-selected", "position: absolute; left: " + q + "px;\n                             top: " + r + "px; width: " + (null == u ? m2 - q : u) + "px;\n                             height: " + (A - r) + "px"));
      }
      function e(q, r, u) {
        function A(F, R2) {
          return Ic(a2, t(q, F), "div", x2, R2);
        }
        function Y(F, R2, H) {
          F = df(a2, x2, null, F);
          R2 = "ltr" == R2 == ("after" == H) ? "left" : "right";
          H = "after" == H ? F.begin : F.end - (/\s/.test(x2.text.charAt(F.end - 1)) ? 2 : 1);
          return A(H, R2)[R2];
        }
        var x2 = w(g, q), P = x2.text.length, K, Q, S = Ja(x2, g.direction);
        Bg(S, r || 0, null == u ? P : u, function(F, R2, H, L) {
          var ha = "ltr" == H, na = A(F, ha ? "left" : "right"), ua = A(R2 - 1, ha ? "right" : "left"), hb = null == r && 0 == F, ib = null == u && R2 == P, Pd = 0 == L;
          L = !S || L == S.length - 1;
          3 >= ua.top - na.top ? (R2 = (n ? hb : ib) && Pd ? l : (ha ? na : ua).left, c(R2, na.top, ((n ? ib : hb) && L ? m2 : (ha ? ua : na).right) - R2, na.bottom)) : (ha ? (ha = n && hb && Pd ? l : na.left, hb = n ? m2 : Y(F, H, "before"), F = n ? l : Y(
            R2,
            H,
            "after"
          ), ib = n && ib && L ? m2 : ua.right) : (ha = n ? Y(F, H, "before") : l, hb = !n && hb && Pd ? m2 : na.right, F = !n && ib && L ? l : ua.left, ib = n ? Y(R2, H, "after") : m2), c(ha, na.top, hb - ha, na.bottom), na.bottom < ua.top && c(l, na.bottom, null, ua.top), c(F, ua.top, ib - F, ua.bottom));
          if (!K || 0 > Kc(na, K))
            K = na;
          0 > Kc(ua, K) && (K = ua);
          if (!Q || 0 > Kc(na, Q))
            Q = na;
          0 > Kc(ua, Q) && (Q = ua);
        });
        return { start: K, end: Q };
      }
      var f = a2.display, g = a2.doc, h2 = document.createDocumentFragment(), k = Te(a2.display), l = k.left, m2 = Math.max(f.sizerWidth, cb(a2) - f.sizer.offsetLeft) - k.right, n = "ltr" == g.direction;
      f = b.from();
      b = b.to();
      if (f.line == b.line)
        e(f.line, f.ch, b.ch);
      else {
        var p = w(g, f.line);
        k = w(g, b.line);
        k = za(p) == za(k);
        f = e(f.line, f.ch, k ? p.text.length + 1 : null).end;
        b = e(b.line, k ? 0 : null, b.ch).start;
        k && (f.top < b.top - 2 ? (c(f.right, f.top, null, f.bottom), c(l, b.top, b.left, b.bottom)) : c(f.right, f.top, b.left - f.right, f.bottom));
        f.bottom < b.top && c(l, f.bottom, null, b.top);
      }
      d2.appendChild(h2);
    }
    function Qd(a2) {
      if (a2.state.focused) {
        var b = a2.display;
        clearInterval(b.blinker);
        var d2 = true;
        b.cursorDiv.style.visibility = "";
        0 < a2.options.cursorBlinkRate ? b.blinker = setInterval(function() {
          a2.hasFocus() || wb(a2);
          b.cursorDiv.style.visibility = (d2 = !d2) ? "" : "hidden";
        }, a2.options.cursorBlinkRate) : 0 > a2.options.cursorBlinkRate && (b.cursorDiv.style.visibility = "hidden");
      }
    }
    function hf(a2) {
      a2.hasFocus() || (a2.display.input.focus(), a2.state.focused || Rd(a2));
    }
    function Sd(a2) {
      a2.state.delayingBlurEvent = true;
      setTimeout(function() {
        a2.state.delayingBlurEvent && (a2.state.delayingBlurEvent = false, a2.state.focused && wb(a2));
      }, 100);
    }
    function Rd(a2, b) {
      a2.state.delayingBlurEvent && !a2.state.draggingText && (a2.state.delayingBlurEvent = false);
      "nocursor" != a2.options.readOnly && (a2.state.focused || (W(a2, "focus", a2, b), a2.state.focused = true, Ya(a2.display.wrapper, "CodeMirror-focused"), a2.curOp || a2.display.selForContextMenu == a2.doc.sel || (a2.display.input.reset(), fa && setTimeout(function() {
        return a2.display.input.reset(true);
      }, 20)), a2.display.input.receivedFocus()), Qd(a2));
    }
    function wb(a2, b) {
      a2.state.delayingBlurEvent || (a2.state.focused && (W(a2, "blur", a2, b), a2.state.focused = false, jb(a2.display.wrapper, "CodeMirror-focused")), clearInterval(a2.display.blinker), setTimeout(function() {
        a2.state.focused || (a2.display.shift = false);
      }, 150));
    }
    function Lc(a2) {
      for (var b = a2.display, d2 = b.lineDiv.offsetTop, c = Math.max(0, b.scroller.getBoundingClientRect().top), e = b.lineDiv.getBoundingClientRect().top, f = 0, g = 0; g < b.view.length; g++) {
        var h2 = b.view[g], k = a2.options.lineWrapping, l = 0;
        if (!h2.hidden) {
          e += h2.line.height;
          if (G && 8 > T) {
            k = h2.node.offsetTop + h2.node.offsetHeight;
            var m2 = k - d2;
            d2 = k;
          } else {
            var n = h2.node.getBoundingClientRect();
            m2 = n.bottom - n.top;
            !k && h2.text.firstChild && (l = h2.text.firstChild.getBoundingClientRect().right - n.left - 1);
          }
          k = h2.line.height - m2;
          if (5e-3 < k || -5e-3 > k) {
            if (e < c && (f -= k), Ea(h2.line, m2), jf(h2.line), h2.rest)
              for (m2 = 0; m2 < h2.rest.length; m2++)
                jf(h2.rest[m2]);
          }
          l > a2.display.sizerWidth && (l = Math.ceil(l / ub(a2.display)), l > a2.display.maxLineLength && (a2.display.maxLineLength = l, a2.display.maxLine = h2.line, a2.display.maxLineChanged = true));
        }
      }
      2 < Math.abs(f) && (b.scroller.scrollTop += f);
    }
    function jf(a2) {
      if (a2.widgets)
        for (var b = 0; b < a2.widgets.length; ++b) {
          var d2 = a2.widgets[b], c = d2.node.parentNode;
          c && (d2.height = c.offsetHeight);
        }
    }
    function Mc(a2, b, d2) {
      var c = d2 && null != d2.top ? Math.max(0, d2.top) : a2.scroller.scrollTop;
      c = Math.floor(c - a2.lineSpace.offsetTop);
      var e = d2 && null != d2.bottom ? d2.bottom : c + a2.wrapper.clientHeight;
      c = bb(b, c);
      e = bb(b, e);
      if (d2 && d2.ensure) {
        var f = d2.ensure.from.line;
        d2 = d2.ensure.to.line;
        f < c ? (c = f, e = bb(b, Ga(w(b, f)) + a2.wrapper.clientHeight)) : Math.min(d2, b.lastLine()) >= e && (c = bb(b, Ga(w(b, d2)) - a2.wrapper.clientHeight), e = d2);
      }
      return { from: c, to: Math.max(e, c + 1) };
    }
    function Td(a2, b) {
      var d2 = a2.display, c = vb(a2.display);
      0 > b.top && (b.top = 0);
      var e = a2.curOp && null != a2.curOp.scrollTop ? a2.curOp.scrollTop : d2.scroller.scrollTop, f = Ed(a2), g = {};
      b.bottom - b.top > f && (b.bottom = b.top + f);
      var h2 = a2.doc.height + Dd(d2), k = b.top < c;
      c = b.bottom > h2 - c;
      b.top < e ? g.scrollTop = k ? 0 : b.top : b.bottom > e + f && (f = Math.min(b.top, (c ? h2 : b.bottom) - f), f != e && (g.scrollTop = f));
      e = a2.options.fixedGutter ? 0 : d2.gutters.offsetWidth;
      f = a2.curOp && null != a2.curOp.scrollLeft ? a2.curOp.scrollLeft : d2.scroller.scrollLeft - e;
      a2 = cb(a2) - d2.gutters.offsetWidth;
      if (d2 = b.right - b.left > a2)
        b.right = b.left + a2;
      10 > b.left ? g.scrollLeft = 0 : b.left < f ? g.scrollLeft = Math.max(0, b.left + e - (d2 ? 0 : 10)) : b.right > a2 + f - 3 && (g.scrollLeft = b.right + (d2 ? 0 : 10) - a2);
      return g;
    }
    function Nc(a2, b) {
      null != b && (Oc(a2), a2.curOp.scrollTop = (null == a2.curOp.scrollTop ? a2.doc.scrollTop : a2.curOp.scrollTop) + b);
    }
    function xb(a2) {
      Oc(a2);
      var b = a2.getCursor();
      a2.curOp.scrollToPos = { from: b, to: b, margin: a2.options.cursorScrollMargin };
    }
    function Wb(a2, b, d2) {
      null == b && null == d2 || Oc(a2);
      null != b && (a2.curOp.scrollLeft = b);
      null != d2 && (a2.curOp.scrollTop = d2);
    }
    function Oc(a2) {
      var b = a2.curOp.scrollToPos;
      if (b) {
        a2.curOp.scrollToPos = null;
        var d2 = bf(a2, b.from), c = bf(a2, b.to);
        kf(a2, d2, c, b.margin);
      }
    }
    function kf(a2, b, d2, c) {
      b = Td(a2, { left: Math.min(b.left, d2.left), top: Math.min(b.top, d2.top) - c, right: Math.max(b.right, d2.right), bottom: Math.max(b.bottom, d2.bottom) + c });
      Wb(a2, b.scrollLeft, b.scrollTop);
    }
    function Xb(a2, b) {
      2 > Math.abs(a2.doc.scrollTop - b) || (Ma || Ud(a2, { top: b }), lf(a2, b, true), Ma && Ud(a2), Yb(a2, 100));
    }
    function lf(a2, b, d2) {
      b = Math.max(0, Math.min(a2.display.scroller.scrollHeight - a2.display.scroller.clientHeight, b));
      if (a2.display.scroller.scrollTop != b || d2)
        a2.doc.scrollTop = b, a2.display.scrollbars.setScrollTop(b), a2.display.scroller.scrollTop != b && (a2.display.scroller.scrollTop = b);
    }
    function kb(a2, b, d2, c) {
      b = Math.max(0, Math.min(b, a2.display.scroller.scrollWidth - a2.display.scroller.clientWidth));
      (d2 ? b == a2.doc.scrollLeft : 2 > Math.abs(a2.doc.scrollLeft - b)) && !c || (a2.doc.scrollLeft = b, mf(a2), a2.display.scroller.scrollLeft != b && (a2.display.scroller.scrollLeft = b), a2.display.scrollbars.setScrollLeft(b));
    }
    function Zb(a2) {
      var b = a2.display, d2 = b.gutters.offsetWidth, c = Math.round(a2.doc.height + Dd(a2.display));
      return {
        clientHeight: b.scroller.clientHeight,
        viewHeight: b.wrapper.clientHeight,
        scrollWidth: b.scroller.scrollWidth,
        clientWidth: b.scroller.clientWidth,
        viewWidth: b.wrapper.clientWidth,
        barLeft: a2.options.fixedGutter ? d2 : 0,
        docHeight: c,
        scrollHeight: c + Ha(a2) + b.barHeight,
        nativeBarWidth: b.nativeBarWidth,
        gutterWidth: d2
      };
    }
    function yb(a2, b) {
      b || (b = Zb(a2));
      var d2 = a2.display.barWidth, c = a2.display.barHeight;
      nf(a2, b);
      for (b = 0; 4 > b && d2 != a2.display.barWidth || c != a2.display.barHeight; b++)
        d2 != a2.display.barWidth && a2.options.lineWrapping && Lc(a2), nf(a2, Zb(a2)), d2 = a2.display.barWidth, c = a2.display.barHeight;
    }
    function nf(a2, b) {
      var d2 = a2.display, c = d2.scrollbars.update(b);
      d2.sizer.style.paddingRight = (d2.barWidth = c.right) + "px";
      d2.sizer.style.paddingBottom = (d2.barHeight = c.bottom) + "px";
      d2.heightForcer.style.borderBottom = c.bottom + "px solid transparent";
      c.right && c.bottom ? (d2.scrollbarFiller.style.display = "block", d2.scrollbarFiller.style.height = c.bottom + "px", d2.scrollbarFiller.style.width = c.right + "px") : d2.scrollbarFiller.style.display = "";
      c.bottom && a2.options.coverGutterNextToScrollbar && a2.options.fixedGutter ? (d2.gutterFiller.style.display = "block", d2.gutterFiller.style.height = c.bottom + "px", d2.gutterFiller.style.width = b.gutterWidth + "px") : d2.gutterFiller.style.display = "";
    }
    function of(a2) {
      a2.display.scrollbars && (a2.display.scrollbars.clear(), a2.display.scrollbars.addClass && jb(a2.display.wrapper, a2.display.scrollbars.addClass));
      a2.display.scrollbars = new pf[a2.options.scrollbarStyle](function(b) {
        a2.display.wrapper.insertBefore(b, a2.display.scrollbarFiller);
        z(b, "mousedown", function() {
          a2.state.focused && setTimeout(function() {
            return a2.display.input.focus();
          }, 0);
        });
        b.setAttribute("cm-not-content", "true");
      }, function(b, d2) {
        "horizontal" == d2 ? kb(a2, b) : Xb(a2, b);
      }, a2);
      a2.display.scrollbars.addClass && Ya(a2.display.wrapper, a2.display.scrollbars.addClass);
    }
    function lb(a2) {
      a2.curOp = { cm: a2, viewChanged: false, startHeight: a2.doc.height, forceUpdate: false, updateInput: 0, typing: false, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: false, updateMaxLine: false, scrollLeft: null, scrollTop: null, scrollToPos: null, focus: false, id: ++Ug, markArrays: null };
      a2 = a2.curOp;
      tb ? tb.ops.push(a2) : a2.ownsGroup = tb = { ops: [a2], delayedCallbacks: [] };
    }
    function mb(a2) {
      (a2 = a2.curOp) && Ng(a2, function(b) {
        for (var d2 = 0; d2 < b.ops.length; d2++)
          b.ops[d2].cm.curOp = null;
        b = b.ops;
        for (d2 = 0; d2 < b.length; d2++) {
          var c = b[d2], e = c.cm, f = e.display, g = e.display;
          !g.scrollbarsClipped && g.scroller.offsetWidth && (g.nativeBarWidth = g.scroller.offsetWidth - g.scroller.clientWidth, g.heightForcer.style.height = Ha(e) + "px", g.sizer.style.marginBottom = -g.nativeBarWidth + "px", g.sizer.style.borderRightWidth = Ha(e) + "px", g.scrollbarsClipped = true);
          c.updateMaxLine && zd(e);
          c.mustUpdate = c.viewChanged || c.forceUpdate || null != c.scrollTop || c.scrollToPos && (c.scrollToPos.from.line < f.viewFrom || c.scrollToPos.to.line >= f.viewTo) || f.maxLineChanged && e.options.lineWrapping;
          c.update = c.mustUpdate && new Pc(e, c.mustUpdate && { top: c.scrollTop, ensure: c.scrollToPos }, c.forceUpdate);
        }
        for (d2 = 0; d2 < b.length; d2++)
          c = b[d2], c.updatedDisplay = c.mustUpdate && Vd(c.cm, c.update);
        for (d2 = 0; d2 < b.length; d2++)
          if (c = b[d2], e = c.cm, f = e.display, c.updatedDisplay && Lc(e), c.barMeasure = Zb(e), f.maxLineChanged && !e.options.lineWrapping && (g = f.maxLine.text.length, g = Aa(e, eb(e, f.maxLine), g, void 0), c.adjustWidthTo = g.left + 3, e.display.sizerWidth = c.adjustWidthTo, c.barMeasure.scrollWidth = Math.max(f.scroller.clientWidth, f.sizer.offsetLeft + c.adjustWidthTo + Ha(e) + e.display.barWidth), c.maxScrollLeft = Math.max(0, f.sizer.offsetLeft + c.adjustWidthTo - cb(e))), c.updatedDisplay || c.selectionChanged)
            c.preparedSelection = f.input.prepareSelection();
        for (d2 = 0; d2 < b.length; d2++)
          c = b[d2], e = c.cm, null != c.adjustWidthTo && (e.display.sizer.style.minWidth = c.adjustWidthTo + "px", c.maxScrollLeft < e.doc.scrollLeft && kb(e, Math.min(e.display.scroller.scrollLeft, c.maxScrollLeft), true), e.display.maxLineChanged = false), f = c.focus && c.focus == ka(qa(e)), c.preparedSelection && e.display.input.showSelection(c.preparedSelection, f), (c.updatedDisplay || c.startHeight != e.doc.height) && yb(e, c.barMeasure), c.updatedDisplay && Wd(e, c.barMeasure), c.selectionChanged && Qd(e), e.state.focused && c.updateInput && e.display.input.reset(c.typing), f && hf(c.cm);
        for (d2 = 0; d2 < b.length; d2++) {
          var h2 = void 0;
          c = b[d2];
          e = c.cm;
          f = e.display;
          g = e.doc;
          c.updatedDisplay && qf(e, c.update);
          null == f.wheelStartX || null == c.scrollTop && null == c.scrollLeft && !c.scrollToPos || (f.wheelStartX = f.wheelStartY = null);
          null != c.scrollTop && lf(e, c.scrollTop, c.forceScroll);
          null != c.scrollLeft && kb(e, c.scrollLeft, true, true);
          if (c.scrollToPos) {
            var k = C(g, c.scrollToPos.from);
            var l = C(g, c.scrollToPos.to);
            var m2 = c.scrollToPos.margin;
            null == m2 && (m2 = 0);
            e.options.lineWrapping || k != l || (l = "before" == k.sticky ? t(k.line, k.ch + 1, "before") : k, k = k.ch ? t(k.line, "before" == k.sticky ? k.ch - 1 : k.ch, "after") : k);
            for (var n = 0; 5 > n; n++) {
              var p = false;
              h2 = Ba(
                e,
                k
              );
              var q = l && l != k ? Ba(e, l) : h2;
              h2 = { left: Math.min(h2.left, q.left), top: Math.min(h2.top, q.top) - m2, right: Math.max(h2.left, q.left), bottom: Math.max(h2.bottom, q.bottom) + m2 };
              q = Td(e, h2);
              var r = e.doc.scrollTop, u = e.doc.scrollLeft;
              null != q.scrollTop && (Xb(e, q.scrollTop), 1 < Math.abs(e.doc.scrollTop - r) && (p = true));
              null != q.scrollLeft && (kb(e, q.scrollLeft), 1 < Math.abs(e.doc.scrollLeft - u) && (p = true));
              if (!p)
                break;
            }
            l = h2;
            Z(e, "scrollCursorIntoView") || (m2 = e.display, n = m2.sizer.getBoundingClientRect(), k = null, p = m2.wrapper.ownerDocument, 0 > l.top + n.top ? k = true : l.bottom + n.top > (p.defaultView.innerHeight || p.documentElement.clientHeight) && (k = false), null == k || Vg || (l = v("div", "‚Äã", null, "position: absolute;\n                         top: " + (l.top - m2.viewOffset - e.display.lineSpace.offsetTop) + "px;\n                         height: " + (l.bottom - l.top + Ha(e) + m2.barHeight) + "px;\n                         left: " + l.left + "px; width: " + Math.max(2, l.right - l.left) + "px;"), e.display.lineSpace.appendChild(l), l.scrollIntoView(k), e.display.lineSpace.removeChild(l)));
          }
          l = c.maybeHiddenMarkers;
          k = c.maybeUnhiddenMarkers;
          if (l)
            for (m2 = 0; m2 < l.length; ++m2)
              l[m2].lines.length || W(l[m2], "hide");
          if (k)
            for (l = 0; l < k.length; ++l)
              k[l].lines.length && W(k[l], "unhide");
          f.wrapper.offsetHeight && (g.scrollTop = e.display.scroller.scrollTop);
          c.changeObjs && W(e, "changes", e, c.changeObjs);
          c.update && c.update.finish();
        }
      });
    }
    function ra(a2, b) {
      if (a2.curOp)
        return b();
      lb(a2);
      try {
        return b();
      } finally {
        mb(a2);
      }
    }
    function ba(a2, b) {
      return function() {
        if (a2.curOp)
          return b.apply(a2, arguments);
        lb(a2);
        try {
          return b.apply(a2, arguments);
        } finally {
          mb(a2);
        }
      };
    }
    function ia(a2) {
      return function() {
        if (this.curOp)
          return a2.apply(
            this,
            arguments
          );
        lb(this);
        try {
          return a2.apply(this, arguments);
        } finally {
          mb(this);
        }
      };
    }
    function ca(a2) {
      return function() {
        var b = this.cm;
        if (!b || b.curOp)
          return a2.apply(this, arguments);
        lb(b);
        try {
          return a2.apply(this, arguments);
        } finally {
          mb(b);
        }
      };
    }
    function Yb(a2, b) {
      a2.doc.highlightFrontier < a2.display.viewTo && a2.state.highlight.set(b, gd(Wg, a2));
    }
    function Wg(a2) {
      var b = a2.doc;
      if (!(b.highlightFrontier >= a2.display.viewTo)) {
        var d2 = +/* @__PURE__ */ new Date() + a2.options.workTime, c = Ob(a2, b.highlightFrontier), e = [];
        b.iter(c.line, Math.min(b.first + b.size, a2.display.viewTo + 500), function(f) {
          if (c.line >= a2.display.viewFrom) {
            var g = f.styles, h2 = f.text.length > a2.options.maxHighlightLength ? $a(b.mode, c.state) : null, k = ye(a2, f, c, true);
            h2 && (c.state = h2);
            f.styles = k.styles;
            h2 = f.styleClasses;
            (k = k.classes) ? f.styleClasses = k : h2 && (f.styleClasses = null);
            k = !g || g.length != f.styles.length || h2 != k && (!h2 || !k || h2.bgClass != k.bgClass || h2.textClass != k.textClass);
            for (h2 = 0; !k && h2 < g.length; ++h2)
              k = g[h2] != f.styles[h2];
            k && e.push(c.line);
            f.stateAfter = c.save();
          } else
            f.text.length <= a2.options.maxHighlightLength && td(a2, f.text, c), f.stateAfter = 0 == c.line % 5 ? c.save() : null;
          c.nextLine();
          if (+/* @__PURE__ */ new Date() > d2)
            return Yb(a2, a2.options.workDelay), true;
        });
        b.highlightFrontier = c.line;
        b.modeFrontier = Math.max(b.modeFrontier, c.line);
        e.length && ra(a2, function() {
          for (var f = 0; f < e.length; f++)
            Sa(a2, e[f], "text");
        });
      }
    }
    function Vd(a2, b) {
      var d2 = a2.display, c = a2.doc;
      if (b.editorIsHidden)
        return Ra(a2), false;
      if (!b.force && b.visible.from >= d2.viewFrom && b.visible.to <= d2.viewTo && (null == d2.updateLineNumbers || d2.updateLineNumbers >= d2.viewTo) && d2.renderedView == d2.view && 0 == ff(a2))
        return false;
      rf(a2) && (Ra(a2), b.dims = Gd(a2));
      var e = c.first + c.size, f = Math.max(b.visible.from - a2.options.viewportMargin, c.first), g = Math.min(e, b.visible.to + a2.options.viewportMargin);
      d2.viewFrom < f && 20 > f - d2.viewFrom && (f = Math.max(c.first, d2.viewFrom));
      d2.viewTo > g && 20 > d2.viewTo - g && (g = Math.min(e, d2.viewTo));
      Ka && (f = xd(a2.doc, f), g = Je(a2.doc, g));
      c = f != d2.viewFrom || g != d2.viewTo || d2.lastWrapHeight != b.wrapperHeight || d2.lastWrapWidth != b.wrapperWidth;
      e = a2.display;
      0 == e.view.length || f >= e.viewTo || g <= e.viewFrom ? (e.view = Fc(a2, f, g), e.viewFrom = f) : (e.viewFrom > f ? e.view = Fc(a2, f, e.viewFrom).concat(e.view) : e.viewFrom < f && (e.view = e.view.slice(db(a2, f))), e.viewFrom = f, e.viewTo < g ? e.view = e.view.concat(Fc(a2, e.viewTo, g)) : e.viewTo > g && (e.view = e.view.slice(0, db(a2, g))));
      e.viewTo = g;
      d2.viewOffset = Ga(w(a2.doc, d2.viewFrom));
      a2.display.mover.style.top = d2.viewOffset + "px";
      g = ff(a2);
      if (!c && 0 == g && !b.force && d2.renderedView == d2.view && (null == d2.updateLineNumbers || d2.updateLineNumbers >= d2.viewTo))
        return false;
      a2.hasFocus() ? f = null : (f = ka(qa(a2))) && ja(a2.display.lineDiv, f) ? (f = { activeElt: f }, window.getSelection && (e = qa(a2).defaultView.getSelection(), e.anchorNode && e.extend && ja(a2.display.lineDiv, e.anchorNode) && (f.anchorNode = e.anchorNode, f.anchorOffset = e.anchorOffset, f.focusNode = e.focusNode, f.focusOffset = e.focusOffset))) : f = null;
      4 < g && (d2.lineDiv.style.display = "none");
      Xg(a2, d2.updateLineNumbers, b.dims);
      4 < g && (d2.lineDiv.style.display = "");
      d2.renderedView = d2.view;
      (g = f) && g.activeElt && g.activeElt != ka(g.activeElt.ownerDocument) && (g.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(g.activeElt.nodeName) && g.anchorNode && ja(
        document.body,
        g.anchorNode
      ) && ja(document.body, g.focusNode) && (e = g.activeElt.ownerDocument, f = e.defaultView.getSelection(), e = e.createRange(), e.setEnd(g.anchorNode, g.anchorOffset), e.collapse(false), f.removeAllRanges(), f.addRange(e), f.extend(g.focusNode, g.focusOffset)));
      E(d2.cursorDiv);
      E(d2.selectionDiv);
      d2.gutters.style.height = d2.sizer.style.minHeight = 0;
      c && (d2.lastWrapHeight = b.wrapperHeight, d2.lastWrapWidth = b.wrapperWidth, Yb(a2, 400));
      d2.updateLineNumbers = null;
      return true;
    }
    function qf(a2, b) {
      for (var d2 = b.viewport, c = true; ; c = false) {
        if (c && a2.options.lineWrapping && b.oldDisplayWidth != cb(a2))
          c && (b.visible = Mc(a2.display, a2.doc, d2));
        else if (d2 && null != d2.top && (d2 = { top: Math.min(a2.doc.height + Dd(a2.display) - Ed(a2), d2.top) }), b.visible = Mc(a2.display, a2.doc, d2), b.visible.from >= a2.display.viewFrom && b.visible.to <= a2.display.viewTo)
          break;
        if (!Vd(a2, b))
          break;
        Lc(a2);
        c = Zb(a2);
        Vb(a2);
        yb(a2, c);
        Wd(a2, c);
        b.force = false;
      }
      b.signal(a2, "update", a2);
      if (a2.display.viewFrom != a2.display.reportedViewFrom || a2.display.viewTo != a2.display.reportedViewTo)
        b.signal(a2, "viewportChange", a2, a2.display.viewFrom, a2.display.viewTo), a2.display.reportedViewFrom = a2.display.viewFrom, a2.display.reportedViewTo = a2.display.viewTo;
    }
    function Ud(a2, b) {
      b = new Pc(a2, b);
      if (Vd(a2, b)) {
        Lc(a2);
        qf(a2, b);
        var d2 = Zb(a2);
        Vb(a2);
        yb(a2, d2);
        Wd(a2, d2);
        b.finish();
      }
    }
    function Xg(a2, b, d2) {
      function c(p) {
        var q = p.nextSibling;
        fa && ya && a2.display.currentWheelTarget == p ? p.style.display = "none" : p.parentNode.removeChild(p);
        return q;
      }
      var e = a2.display, f = a2.options.lineNumbers, g = e.lineDiv, h2 = g.firstChild, k = e.view;
      e = e.viewFrom;
      for (var l = 0; l < k.length; l++) {
        var m2 = k[l];
        if (!m2.hidden)
          if (m2.node && m2.node.parentNode == g) {
            for (; h2 != m2.node; )
              h2 = c(h2);
            h2 = f && null != b && b <= e && m2.lineNumber;
            m2.changes && (-1 < ea(m2.changes, "gutter") && (h2 = false), Oe(a2, m2, e, d2));
            h2 && (E(m2.lineNumber), m2.lineNumber.appendChild(document.createTextNode(qd(a2.options, e))));
            h2 = m2.node.nextSibling;
          } else {
            var n = Pg(a2, m2, e, d2);
            g.insertBefore(n, h2);
          }
        e += m2.size;
      }
      for (; h2; )
        h2 = c(h2);
    }
    function Xd(a2) {
      a2.sizer.style.marginLeft = a2.gutters.offsetWidth + "px";
      aa(a2, "gutterChanged", a2);
    }
    function Wd(a2, b) {
      a2.display.sizer.style.minHeight = b.docHeight + "px";
      a2.display.heightForcer.style.top = b.docHeight + "px";
      a2.display.gutters.style.height = b.docHeight + a2.display.barHeight + Ha(a2) + "px";
    }
    function mf(a2) {
      var b = a2.display, d2 = b.view;
      if (b.alignWidgets || b.gutters.firstChild && a2.options.fixedGutter) {
        for (var c = Md(b) - b.scroller.scrollLeft + a2.doc.scrollLeft, e = b.gutters.offsetWidth, f = c + "px", g = 0; g < d2.length; g++)
          if (!d2[g].hidden) {
            a2.options.fixedGutter && (d2[g].gutter && (d2[g].gutter.style.left = f), d2[g].gutterBackground && (d2[g].gutterBackground.style.left = f));
            var h2 = d2[g].alignable;
            if (h2)
              for (var k = 0; k < h2.length; k++)
                h2[k].style.left = f;
          }
        a2.options.fixedGutter && (b.gutters.style.left = c + e + "px");
      }
    }
    function rf(a2) {
      if (!a2.options.lineNumbers)
        return false;
      var b = a2.doc;
      b = qd(a2.options, b.first + b.size - 1);
      var d2 = a2.display;
      if (b.length != d2.lineNumChars) {
        var c = d2.measure.appendChild(v("div", [v("div", b)], "CodeMirror-linenumber CodeMirror-gutter-elt")), e = c.firstChild.offsetWidth;
        c = c.offsetWidth - e;
        d2.lineGutter.style.width = "";
        d2.lineNumInnerWidth = Math.max(e, d2.lineGutter.offsetWidth - c) + 1;
        d2.lineNumWidth = d2.lineNumInnerWidth + c;
        d2.lineNumChars = d2.lineNumInnerWidth ? b.length : -1;
        d2.lineGutter.style.width = d2.lineNumWidth + "px";
        Xd(a2.display);
        return true;
      }
      return false;
    }
    function Yd(a2, b) {
      for (var d2 = [], c = false, e = 0; e < a2.length; e++) {
        var f = a2[e], g = null;
        "string" != typeof f && (g = f.style, f = f.className);
        if ("CodeMirror-linenumbers" == f)
          if (b)
            c = true;
          else
            continue;
        d2.push({ className: f, style: g });
      }
      b && !c && d2.push({ className: "CodeMirror-linenumbers", style: null });
      return d2;
    }
    function sf(a2) {
      var b = a2.gutters, d2 = a2.gutterSpecs;
      E(b);
      a2.lineGutter = null;
      for (var c = 0; c < d2.length; ++c) {
        var e = d2[c], f = e.className;
        e = e.style;
        var g = b.appendChild(v("div", null, "CodeMirror-gutter " + f));
        e && (g.style.cssText = e);
        "CodeMirror-linenumbers" == f && (a2.lineGutter = g, g.style.width = (a2.lineNumWidth || 1) + "px");
      }
      b.style.display = d2.length ? "" : "none";
      Xd(a2);
    }
    function $b(a2) {
      sf(a2.display);
      ma(a2);
      mf(a2);
    }
    function Yg(a2, b, d2, c) {
      this.input = d2;
      this.scrollbarFiller = v("div", null, "CodeMirror-scrollbar-filler");
      this.scrollbarFiller.setAttribute("cm-not-content", "true");
      this.gutterFiller = v("div", null, "CodeMirror-gutter-filler");
      this.gutterFiller.setAttribute("cm-not-content", "true");
      this.lineDiv = M("div", null, "CodeMirror-code");
      this.selectionDiv = v("div", null, null, "position: relative; z-index: 1");
      this.cursorDiv = v("div", null, "CodeMirror-cursors");
      this.measure = v("div", null, "CodeMirror-measure");
      this.lineMeasure = v("div", null, "CodeMirror-measure");
      this.lineSpace = M("div", [this.measure, this.lineMeasure, this.selectionDiv, this.cursorDiv, this.lineDiv], null, "position: relative; outline: none");
      var e = M("div", [this.lineSpace], "CodeMirror-lines");
      this.mover = v("div", [e], null, "position: relative");
      this.sizer = v("div", [this.mover], "CodeMirror-sizer");
      this.sizerWidth = null;
      this.heightForcer = v("div", null, null, "position: absolute; height: 50px; width: 1px;");
      this.gutters = v("div", null, "CodeMirror-gutters");
      this.lineGutter = null;
      this.scroller = v("div", [this.sizer, this.heightForcer, this.gutters], "CodeMirror-scroll");
      this.scroller.setAttribute("tabIndex", "-1");
      this.wrapper = v("div", [this.scrollbarFiller, this.gutterFiller, this.scroller], "CodeMirror");
      Qa && 105 <= tf && (this.wrapper.style.clipPath = "inset(0px)");
      this.wrapper.setAttribute("translate", "no");
      G && 8 > T && (this.gutters.style.zIndex = -1, this.scroller.style.paddingRight = 0);
      fa || Ma && ac || (this.scroller.draggable = true);
      a2 && (a2.appendChild ? a2.appendChild(this.wrapper) : a2(this.wrapper));
      this.reportedViewFrom = this.reportedViewTo = this.viewFrom = this.viewTo = b.first;
      this.view = [];
      this.externalMeasured = this.renderedView = null;
      this.lastWrapHeight = this.lastWrapWidth = this.viewOffset = 0;
      this.updateLineNumbers = null;
      this.nativeBarWidth = this.barHeight = this.barWidth = 0;
      this.scrollbarsClipped = false;
      this.lineNumWidth = this.lineNumInnerWidth = this.lineNumChars = null;
      this.alignWidgets = false;
      this.maxLine = this.cachedCharWidth = this.cachedTextHeight = this.cachedPaddingH = null;
      this.maxLineLength = 0;
      this.maxLineChanged = false;
      this.wheelDX = this.wheelDY = this.wheelStartX = this.wheelStartY = null;
      this.shift = false;
      this.activeTouch = this.selForContextMenu = null;
      this.gutterSpecs = Yd(c.gutters, c.lineNumbers);
      sf(this);
      d2.init(this);
    }
    function uf(a2) {
      var b = a2.wheelDeltaX, d2 = a2.wheelDeltaY;
      null == b && a2.detail && a2.axis == a2.HORIZONTAL_AXIS && (b = a2.detail);
      null == d2 && a2.detail && a2.axis == a2.VERTICAL_AXIS ? d2 = a2.detail : null == d2 && (d2 = a2.wheelDelta);
      return { x: b, y: d2 };
    }
    function Zg(a2) {
      a2 = uf(a2);
      a2.x *= Na;
      a2.y *= Na;
      return a2;
    }
    function vf(a2, b) {
      Qa && 102 == tf && (null == a2.display.chromeScrollHack ? a2.display.sizer.style.pointerEvents = "none" : clearTimeout(a2.display.chromeScrollHack), a2.display.chromeScrollHack = setTimeout(function() {
        a2.display.chromeScrollHack = null;
        a2.display.sizer.style.pointerEvents = "";
      }, 100));
      var d2 = uf(b), c = d2.x;
      d2 = d2.y;
      var e = Na;
      0 === b.deltaMode && (c = b.deltaX, d2 = b.deltaY, e = 1);
      var f = a2.display, g = f.scroller, h2 = g.scrollWidth > g.clientWidth, k = g.scrollHeight > g.clientHeight;
      if (c && h2 || d2 && k) {
        if (d2 && ya && fa) {
          h2 = b.target;
          var l = f.view;
          a:
            for (; h2 != g; h2 = h2.parentNode)
              for (var m2 = 0; m2 < l.length; m2++)
                if (l[m2].node == h2) {
                  a2.display.currentWheelTarget = h2;
                  break a;
                }
        }
        !c || Ma || Ca || null == e ? (d2 && null != e && (e *= d2, k = a2.doc.scrollTop, h2 = k + f.wrapper.clientHeight, 0 > e ? k = Math.max(0, k + e - 50) : h2 = Math.min(a2.doc.height, h2 + e + 50), Ud(a2, { top: k, bottom: h2 })), 20 > Qc && 0 !== b.deltaMode && (null == f.wheelStartX ? (f.wheelStartX = g.scrollLeft, f.wheelStartY = g.scrollTop, f.wheelDX = c, f.wheelDY = d2, setTimeout(function() {
          if (null != f.wheelStartX) {
            var n = g.scrollLeft - f.wheelStartX, p = g.scrollTop - f.wheelStartY;
            n = p && f.wheelDY && p / f.wheelDY || n && f.wheelDX && n / f.wheelDX;
            f.wheelStartX = f.wheelStartY = null;
            n && (Na = (Na * Qc + n) / (Qc + 1), ++Qc);
          }
        }, 200)) : (f.wheelDX += c, f.wheelDY += d2))) : (d2 && k && Xb(a2, Math.max(0, g.scrollTop + d2 * e)), kb(a2, Math.max(0, g.scrollLeft + c * e)), (!d2 || d2 && k) && la(b), f.wheelStartX = null);
      }
    }
    function Da(a2, b, d2) {
      a2 = a2 && a2.options.selectionsMayTouch;
      d2 = b[d2];
      b.sort(function(k, l) {
        return B(k.from(), l.from());
      });
      d2 = ea(b, d2);
      for (var c = 1; c < b.length; c++) {
        var e = b[c], f = b[c - 1], g = B(f.to(), e.from());
        if (a2 && !e.empty() ? 0 < g : 0 <= g) {
          g = Bc(f.from(), e.from());
          var h2 = Ac(f.to(), e.to());
          e = f.empty() ? e.from() == e.head : f.from() == f.head;
          c <= d2 && --d2;
          b.splice(--c, 2, new I(e ? h2 : g, e ? g : h2));
        }
      }
      return new va(b, d2);
    }
    function Oa(a2, b) {
      return new va([new I(a2, b || a2)], 0);
    }
    function Ta(a2) {
      return a2.text ? t(a2.from.line + a2.text.length - 1, J(a2.text).length + (1 == a2.text.length ? a2.from.ch : 0)) : a2.to;
    }
    function wf(a2, b) {
      if (0 > B(a2, b.from))
        return a2;
      if (0 >= B(a2, b.to))
        return Ta(b);
      var d2 = a2.line + b.text.length - (b.to.line - b.from.line) - 1, c = a2.ch;
      a2.line == b.to.line && (c += Ta(b).ch - b.to.ch);
      return t(d2, c);
    }
    function Zd(a2, b) {
      for (var d2 = [], c = 0; c < a2.sel.ranges.length; c++) {
        var e = a2.sel.ranges[c];
        d2.push(new I(wf(e.anchor, b), wf(e.head, b)));
      }
      return Da(a2.cm, d2, a2.sel.primIndex);
    }
    function xf(a2, b, d2) {
      return a2.line == b.line ? t(d2.line, a2.ch - b.ch + d2.ch) : t(d2.line + (a2.line - b.line), a2.ch);
    }
    function $d(a2) {
      a2.doc.mode = nd(a2.options, a2.doc.modeOption);
      bc(a2);
    }
    function bc(a2) {
      a2.doc.iter(function(b) {
        b.stateAfter && (b.stateAfter = null);
        b.styles && (b.styles = null);
      });
      a2.doc.modeFrontier = a2.doc.highlightFrontier = a2.doc.first;
      Yb(a2, 100);
      a2.state.modeGen++;
      a2.curOp && ma(a2);
    }
    function yf(a2, b) {
      return 0 == b.from.ch && 0 == b.to.ch && "" == J(b.text) && (!a2.cm || a2.cm.options.wholeLineUpdateBefore);
    }
    function ae(a2, b, d2, c) {
      function e(r, u, A) {
        r.text = u;
        r.stateAfter && (r.stateAfter = null);
        r.styles && (r.styles = null);
        null != r.order && (r.order = null);
        Ge(r);
        He(r, A);
        u = c ? c(r) : 1;
        u != r.height && Ea(r, u);
        aa(r, "change", r, b);
      }
      function f(r, u) {
        for (var A = []; r < u; ++r)
          A.push(new zb(k[r], d2 ? d2[r] : null, c));
        return A;
      }
      var g = b.from, h2 = b.to, k = b.text, l = w(a2, g.line), m2 = w(a2, h2.line), n = J(k), p = d2 ? d2[k.length - 1] : null, q = h2.line - g.line;
      b.full ? (a2.insert(0, f(0, k.length)), a2.remove(k.length, a2.size - k.length)) : yf(a2, b) ? (h2 = f(0, k.length - 1), e(m2, m2.text, p), q && a2.remove(g.line, q), h2.length && a2.insert(g.line, h2)) : l == m2 ? 1 == k.length ? e(l, l.text.slice(0, g.ch) + n + l.text.slice(h2.ch), p) : (q = f(1, k.length - 1), q.push(new zb(n + l.text.slice(h2.ch), p, c)), e(l, l.text.slice(0, g.ch) + k[0], d2 ? d2[0] : null), a2.insert(g.line + 1, q)) : 1 == k.length ? (e(l, l.text.slice(0, g.ch) + k[0] + m2.text.slice(h2.ch), d2 ? d2[0] : null), a2.remove(g.line + 1, q)) : (e(l, l.text.slice(0, g.ch) + k[0], d2 ? d2[0] : null), e(m2, n + m2.text.slice(h2.ch), p), p = f(1, k.length - 1), 1 < q && a2.remove(g.line + 1, q - 1), a2.insert(g.line + 1, p));
      aa(a2, "change", a2, b);
    }
    function Ua(a2, b, d2) {
      function c(e, f, g) {
        if (e.linked)
          for (var h2 = 0; h2 < e.linked.length; ++h2) {
            var k = e.linked[h2];
            if (k.doc != f) {
              var l = g && k.sharedHist;
              if (!d2 || l)
                b(k.doc, l), c(k.doc, e, l);
            }
          }
      }
      c(a2, null, true);
    }
    function zf(a2, b) {
      if (b.cm)
        throw Error("This document is already in use.");
      a2.doc = b;
      b.cm = a2;
      Nd(a2);
      $d(a2);
      Af(a2);
      a2.options.direction = b.direction;
      a2.options.lineWrapping || zd(a2);
      a2.options.mode = b.modeOption;
      ma(a2);
    }
    function Af(a2) {
      ("rtl" == a2.doc.direction ? Ya : jb)(a2.display.lineDiv, "CodeMirror-rtl");
    }
    function $g(a2) {
      ra(a2, function() {
        Af(a2);
        ma(a2);
      });
    }
    function Rc(a2) {
      this.done = [];
      this.undone = [];
      this.undoDepth = a2 ? a2.undoDepth : Infinity;
      this.lastModTime = this.lastSelTime = 0;
      this.lastOrigin = this.lastSelOrigin = this.lastOp = this.lastSelOp = null;
      this.generation = this.maxGeneration = a2 ? a2.maxGeneration : 1;
    }
    function be(a2, b) {
      var d2 = { from: sd(b.from), to: Ta(b), text: ab(a2, b.from, b.to) };
      Bf(a2, d2, b.from.line, b.to.line + 1);
      Ua(a2, function(c) {
        return Bf(c, d2, b.from.line, b.to.line + 1);
      }, true);
      return d2;
    }
    function Cf(a2) {
      for (; a2.length; )
        if (J(a2).ranges)
          a2.pop();
        else
          break;
    }
    function Df(a2, b, d2, c) {
      var e = a2.history;
      e.undone.length = 0;
      var f = +/* @__PURE__ */ new Date(), g;
      if (g = e.lastOp == c || e.lastOrigin == b.origin && b.origin && ("+" == b.origin.charAt(0) && e.lastModTime > f - (a2.cm ? a2.cm.options.historyEventDelay : 500) || "*" == b.origin.charAt(0))) {
        if (e.lastOp == c) {
          Cf(e.done);
          var h2 = J(e.done);
        } else
          e.done.length && !J(e.done).ranges ? h2 = J(e.done) : 1 < e.done.length && !e.done[e.done.length - 2].ranges ? (e.done.pop(), h2 = J(e.done)) : h2 = void 0;
        g = h2;
      }
      if (g) {
        var k = J(h2.changes);
        0 == B(b.from, b.to) && 0 == B(b.from, k.to) ? k.to = Ta(b) : h2.changes.push(be(a2, b));
      } else
        for ((h2 = J(e.done)) && h2.ranges || Sc(a2.sel, e.done), h2 = { changes: [be(a2, b)], generation: e.generation }, e.done.push(h2); e.done.length > e.undoDepth; )
          e.done.shift(), e.done[0].ranges || e.done.shift();
      e.done.push(d2);
      e.generation = ++e.maxGeneration;
      e.lastModTime = e.lastSelTime = f;
      e.lastOp = e.lastSelOp = c;
      e.lastOrigin = e.lastSelOrigin = b.origin;
      k || W(a2, "historyAdded");
    }
    function Sc(a2, b) {
      var d2 = J(b);
      d2 && d2.ranges && d2.equals(a2) || b.push(a2);
    }
    function Bf(a2, b, d2, c) {
      var e = b["spans_" + a2.id], f = 0;
      a2.iter(Math.max(a2.first, d2), Math.min(a2.first + a2.size, c), function(g) {
        g.markedSpans && ((e || (e = b["spans_" + a2.id] = {}))[f] = g.markedSpans);
        ++f;
      });
    }
    function Ef(a2, b) {
      var d2;
      if (d2 = b["spans_" + a2.id]) {
        for (var c = [], e = 0; e < b.text.length; ++e) {
          var f = c, g = f.push;
          var h2 = void 0;
          var k = d2[e];
          if (k) {
            for (var l = 0; l < k.length; ++l)
              k[l].marker.explicitlyCleared ? h2 || (h2 = k.slice(0, l)) : h2 && h2.push(k[l]);
            h2 = h2 ? h2.length ? h2 : null : k;
          } else
            h2 = null;
          g.call(f, h2);
        }
        d2 = c;
      } else
        d2 = null;
      a2 = vd(a2, b);
      if (!d2)
        return a2;
      if (!a2)
        return d2;
      for (b = 0; b < d2.length; ++b)
        if (c = d2[b], e = a2[b], c && e)
          a:
            for (f = 0; f < e.length; ++f) {
              g = e[f];
              for (h2 = 0; h2 < c.length; ++h2)
                if (c[h2].marker == g.marker)
                  continue a;
              c.push(g);
            }
        else
          e && (d2[b] = e);
      return d2;
    }
    function Ab(a2, b, d2) {
      for (var c = [], e = 0; e < a2.length; ++e) {
        var f = a2[e];
        if (f.ranges)
          c.push(d2 ? va.prototype.deepCopy.call(f) : f);
        else {
          f = f.changes;
          var g = [];
          c.push({ changes: g });
          for (var h2 = 0; h2 < f.length; ++h2) {
            var k = f[h2], l;
            g.push({ from: k.from, to: k.to, text: k.text });
            if (b)
              for (var m2 in k)
                (l = m2.match(/^spans_(\d+)$/)) && -1 < ea(b, Number(l[1])) && (J(g)[m2] = k[m2], delete k[m2]);
          }
        }
      }
      return c;
    }
    function ce(a2, b, d2, c) {
      return c ? (a2 = a2.anchor, d2 && (c = 0 > B(b, a2), c != 0 > B(d2, a2) ? (a2 = b, b = d2) : c != 0 > B(b, d2) && (b = d2)), new I(a2, b)) : new I(d2 || b, b);
    }
    function Tc(a2, b, d2, c, e) {
      null == e && (e = a2.cm && (a2.cm.display.shift || a2.extend));
      da(a2, new va([ce(a2.sel.primary(), b, d2, e)], 0), c);
    }
    function Ff(a2, b, d2) {
      for (var c = [], e = a2.cm && (a2.cm.display.shift || a2.extend), f = 0; f < a2.sel.ranges.length; f++)
        c[f] = ce(a2.sel.ranges[f], b[f], null, e);
      b = Da(a2.cm, c, a2.sel.primIndex);
      da(
        a2,
        b,
        d2
      );
    }
    function de(a2, b, d2, c) {
      var e = a2.sel.ranges.slice(0);
      e[b] = d2;
      da(a2, Da(a2.cm, e, a2.sel.primIndex), c);
    }
    function ah(a2, b, d2) {
      d2 = { ranges: b.ranges, update: function(c) {
        this.ranges = [];
        for (var e = 0; e < c.length; e++)
          this.ranges[e] = new I(C(a2, c[e].anchor), C(a2, c[e].head));
      }, origin: d2 && d2.origin };
      W(a2, "beforeSelectionChange", a2, d2);
      a2.cm && W(a2.cm, "beforeSelectionChange", a2.cm, d2);
      return d2.ranges != b.ranges ? Da(a2.cm, d2.ranges, d2.ranges.length - 1) : b;
    }
    function Gf(a2, b, d2) {
      var c = a2.history.done, e = J(c);
      e && e.ranges ? (c[c.length - 1] = b, Uc(a2, b, d2)) : da(
        a2,
        b,
        d2
      );
    }
    function da(a2, b, d2) {
      Uc(a2, b, d2);
      b = a2.sel;
      var c = a2.cm ? a2.cm.curOp.id : NaN, e = a2.history, f = d2 && d2.origin, g;
      if (!(g = c == e.lastSelOp) && (g = f && e.lastSelOrigin == f) && !(g = e.lastModTime == e.lastSelTime && e.lastOrigin == f)) {
        g = J(e.done);
        var h2 = f.charAt(0);
        g = "*" == h2 || "+" == h2 && g.ranges.length == b.ranges.length && g.somethingSelected() == b.somethingSelected() && /* @__PURE__ */ new Date() - a2.history.lastSelTime <= (a2.cm ? a2.cm.options.historyEventDelay : 500);
      }
      g ? e.done[e.done.length - 1] = b : Sc(b, e.done);
      e.lastSelTime = +/* @__PURE__ */ new Date();
      e.lastSelOrigin = f;
      e.lastSelOp = c;
      d2 && false !== d2.clearRedo && Cf(e.undone);
    }
    function Uc(a2, b, d2) {
      if (xa(a2, "beforeSelectionChange") || a2.cm && xa(a2.cm, "beforeSelectionChange"))
        b = ah(a2, b, d2);
      var c = d2 && d2.bias || (0 > B(b.primary().head, a2.sel.primary().head) ? -1 : 1);
      Hf(a2, If(a2, b, c, true));
      d2 && false === d2.scroll || !a2.cm || "nocursor" == a2.cm.getOption("readOnly") || xb(a2.cm);
    }
    function Hf(a2, b) {
      b.equals(a2.sel) || (a2.sel = b, a2.cm && (a2.cm.curOp.updateInput = 1, a2.cm.curOp.selectionChanged = true, te(a2.cm)), aa(a2, "cursorActivity", a2));
    }
    function Jf(a2) {
      Hf(a2, If(a2, a2.sel, null, false));
    }
    function If(a2, b, d2, c) {
      for (var e, f = 0; f < b.ranges.length; f++) {
        var g = b.ranges[f], h2 = b.ranges.length == a2.sel.ranges.length && a2.sel.ranges[f], k = Vc(a2, g.anchor, h2 && h2.anchor, d2, c);
        h2 = g.head == g.anchor ? k : Vc(a2, g.head, h2 && h2.head, d2, c);
        if (e || k != g.anchor || h2 != g.head)
          e || (e = b.ranges.slice(0, f)), e[f] = new I(k, h2);
      }
      return e ? Da(a2.cm, e, b.primIndex) : b;
    }
    function Bb(a2, b, d2, c, e) {
      var f = w(a2, b.line);
      if (f.markedSpans)
        for (var g = 0; g < f.markedSpans.length; ++g) {
          var h2 = f.markedSpans[g], k = h2.marker, l = "selectLeft" in k ? !k.selectLeft : k.inclusiveLeft, m2 = "selectRight" in k ? !k.selectRight : k.inclusiveRight;
          if ((null == h2.from || (l ? h2.from <= b.ch : h2.from < b.ch)) && (null == h2.to || (m2 ? h2.to >= b.ch : h2.to > b.ch))) {
            if (e && (W(k, "beforeCursorEnter"), k.explicitlyCleared))
              if (f.markedSpans) {
                --g;
                continue;
              } else
                break;
            if (k.atomic) {
              if (d2) {
                g = k.find(0 > c ? 1 : -1);
                h2 = void 0;
                if (0 > c ? m2 : l)
                  g = Kf(a2, g, -c, g && g.line == b.line ? f : null);
                if (g && g.line == b.line && (h2 = B(g, d2)) && (0 > c ? 0 > h2 : 0 < h2))
                  return Bb(a2, g, b, c, e);
              }
              d2 = k.find(0 > c ? -1 : 1);
              if (0 > c ? l : m2)
                d2 = Kf(a2, d2, c, d2.line == b.line ? f : null);
              return d2 ? Bb(a2, d2, b, c, e) : null;
            }
          }
        }
      return b;
    }
    function Vc(a2, b, d2, c, e) {
      c = c || 1;
      b = Bb(a2, b, d2, c, e) || !e && Bb(a2, b, d2, c, true) || Bb(a2, b, d2, -c, e) || !e && Bb(a2, b, d2, -c, true);
      return b ? b : (a2.cantEdit = true, t(a2.first, 0));
    }
    function Kf(a2, b, d2, c) {
      return 0 > d2 && 0 == b.ch ? b.line > a2.first ? C(a2, t(b.line - 1)) : null : 0 < d2 && b.ch == (c || w(a2, b.line)).text.length ? b.line < a2.first + a2.size - 1 ? t(b.line + 1, 0) : null : new t(b.line, b.ch + d2);
    }
    function Lf(a2) {
      a2.setSelection(t(a2.firstLine(), 0), t(a2.lastLine()), Ia);
    }
    function Mf(a2, b, d2) {
      var c = { canceled: false, from: b.from, to: b.to, text: b.text, origin: b.origin, cancel: function() {
        return c.canceled = true;
      } };
      d2 && (c.update = function(e, f, g, h2) {
        e && (c.from = C(a2, e));
        f && (c.to = C(a2, f));
        g && (c.text = g);
        void 0 !== h2 && (c.origin = h2);
      });
      W(a2, "beforeChange", a2, c);
      a2.cm && W(a2.cm, "beforeChange", a2.cm, c);
      return c.canceled ? (a2.cm && (a2.cm.curOp.updateInput = 2), null) : { from: c.from, to: c.to, text: c.text, origin: c.origin };
    }
    function Cb(a2, b, d2) {
      if (a2.cm) {
        if (!a2.cm.curOp)
          return ba(a2.cm, Cb)(a2, b, d2);
        if (a2.cm.state.suppressEdits)
          return;
      }
      if (xa(a2, "beforeChange") || a2.cm && xa(a2.cm, "beforeChange")) {
        if (b = Mf(a2, b, true), !b)
          return;
      }
      if (d2 = Nf && !d2 && Hg(a2, b.from, b.to))
        for (var c = d2.length - 1; 0 <= c; --c)
          Of(a2, { from: d2[c].from, to: d2[c].to, text: c ? [""] : b.text, origin: b.origin });
      else
        Of(a2, b);
    }
    function Of(a2, b) {
      if (1 != b.text.length || "" != b.text[0] || 0 != B(b.from, b.to)) {
        var d2 = Zd(a2, b);
        Df(a2, b, d2, a2.cm ? a2.cm.curOp.id : NaN);
        cc(a2, b, d2, vd(a2, b));
        var c = [];
        Ua(a2, function(e, f) {
          f || -1 != ea(c, e.history) || (Pf(e.history, b), c.push(e.history));
          cc(e, b, null, vd(e, b));
        });
      }
    }
    function Wc(a2, b, d2) {
      var c = a2.cm && a2.cm.state.suppressEdits;
      if (!c || d2) {
        for (var e = a2.history, f, g = a2.sel, h2 = "undo" == b ? e.done : e.undone, k = "undo" == b ? e.undone : e.done, l = 0; l < h2.length && (f = h2[l], d2 ? !f.ranges || f.equals(a2.sel) : f.ranges); l++)
          ;
        if (l != h2.length) {
          for (e.lastOrigin = e.lastSelOrigin = null; ; )
            if (f = h2.pop(), f.ranges) {
              Sc(f, k);
              if (d2 && !f.equals(a2.sel)) {
                da(a2, f, { clearRedo: false });
                return;
              }
              g = f;
            } else {
              if (c) {
                h2.push(f);
                return;
              }
              break;
            }
          var m2 = [];
          Sc(g, k);
          k.push({ changes: m2, generation: e.generation });
          e.generation = f.generation || ++e.maxGeneration;
          var n = xa(a2, "beforeChange") || a2.cm && xa(a2.cm, "beforeChange");
          d2 = function(p) {
            var q = f.changes[p];
            q.origin = b;
            if (n && !Mf(a2, q, false))
              return h2.length = 0, {};
            m2.push(be(a2, q));
            var r = p ? Zd(a2, q) : J(h2);
            cc(a2, q, r, Ef(a2, q));
            !p && a2.cm && a2.cm.scrollIntoView({ from: q.from, to: Ta(q) });
            var u = [];
            Ua(a2, function(A, Y) {
              Y || -1 != ea(u, A.history) || (Pf(A.history, q), u.push(A.history));
              cc(A, q, null, Ef(A, q));
            });
          };
          for (c = f.changes.length - 1; 0 <= c; --c)
            if (e = d2(c))
              return e.v;
        }
      }
    }
    function Qf(a2, b) {
      if (0 != b && (a2.first += b, a2.sel = new va(wc(a2.sel.ranges, function(e) {
        return new I(t(e.anchor.line + b, e.anchor.ch), t(e.head.line + b, e.head.ch));
      }), a2.sel.primIndex), a2.cm)) {
        ma(a2.cm, a2.first, a2.first - b, b);
        for (var d2 = a2.cm.display, c = d2.viewFrom; c < d2.viewTo; c++)
          Sa(
            a2.cm,
            c,
            "gutter"
          );
      }
    }
    function cc(a2, b, d2, c) {
      if (a2.cm && !a2.cm.curOp)
        return ba(a2.cm, cc)(a2, b, d2, c);
      if (b.to.line < a2.first)
        Qf(a2, b.text.length - 1 - (b.to.line - b.from.line));
      else if (!(b.from.line > a2.lastLine())) {
        if (b.from.line < a2.first) {
          var e = b.text.length - 1 - (a2.first - b.from.line);
          Qf(a2, e);
          b = { from: t(a2.first, 0), to: t(b.to.line + e, b.to.ch), text: [J(b.text)], origin: b.origin };
        }
        e = a2.lastLine();
        b.to.line > e && (b = { from: b.from, to: t(e, w(a2, e).text.length), text: [b.text[0]], origin: b.origin });
        b.removed = ab(a2, b.from, b.to);
        d2 || (d2 = Zd(a2, b));
        a2.cm ? bh(
          a2.cm,
          b,
          c
        ) : ae(a2, b, c);
        Uc(a2, d2, Ia);
        a2.cantEdit && Vc(a2, t(a2.firstLine(), 0)) && (a2.cantEdit = false);
      }
    }
    function bh(a2, b, d2) {
      var c = a2.doc, e = a2.display, f = b.from, g = b.to, h2 = false, k = f.line;
      a2.options.lineWrapping || (k = N(za(w(c, f.line))), c.iter(k, g.line + 1, function(l) {
        if (l == e.maxLine)
          return h2 = true;
      }));
      -1 < c.sel.contains(b.from, b.to) && te(a2);
      ae(c, b, d2, ef(a2));
      a2.options.lineWrapping || (c.iter(k, f.line + b.text.length, function(l) {
        var m2 = Ec(l);
        m2 > e.maxLineLength && (e.maxLine = l, e.maxLineLength = m2, e.maxLineChanged = true, h2 = false);
      }), h2 && (a2.curOp.updateMaxLine = true));
      Gg(c, f.line);
      Yb(a2, 400);
      d2 = b.text.length - (g.line - f.line) - 1;
      b.full ? ma(a2) : f.line != g.line || 1 != b.text.length || yf(a2.doc, b) ? ma(a2, f.line, g.line + 1, d2) : Sa(a2, f.line, "text");
      d2 = xa(a2, "changes");
      if ((c = xa(a2, "change")) || d2)
        b = { from: f, to: g, text: b.text, removed: b.removed, origin: b.origin }, c && aa(a2, "change", a2, b), d2 && (a2.curOp.changeObjs || (a2.curOp.changeObjs = [])).push(b);
      a2.display.selForContextMenu = null;
    }
    function Db(a2, b, d2, c, e) {
      c || (c = d2);
      0 > B(c, d2) && (c = [c, d2], d2 = c[0], c = c[1]);
      "string" == typeof b && (b = a2.splitLines(b));
      Cb(a2, {
        from: d2,
        to: c,
        text: b,
        origin: e
      });
    }
    function Rf(a2, b, d2, c) {
      d2 < a2.line ? a2.line += c : b < a2.line && (a2.line = b, a2.ch = 0);
    }
    function Sf(a2, b, d2, c) {
      for (var e = 0; e < a2.length; ++e) {
        var f = a2[e], g = true;
        if (f.ranges)
          for (f.copied || (f = a2[e] = f.deepCopy(), f.copied = true), g = 0; g < f.ranges.length; g++)
            Rf(f.ranges[g].anchor, b, d2, c), Rf(f.ranges[g].head, b, d2, c);
        else {
          for (var h2 = 0; h2 < f.changes.length; ++h2) {
            var k = f.changes[h2];
            if (d2 < k.from.line)
              k.from = t(k.from.line + c, k.from.ch), k.to = t(k.to.line + c, k.to.ch);
            else if (b <= k.to.line) {
              g = false;
              break;
            }
          }
          g || (a2.splice(0, e + 1), e = 0);
        }
      }
    }
    function Pf(a2, b) {
      var d2 = b.from.line, c = b.to.line;
      b = b.text.length - (c - d2) - 1;
      Sf(a2.done, d2, c, b);
      Sf(a2.undone, d2, c, b);
    }
    function dc(a2, b, d2, c) {
      var e = b, f = b;
      "number" == typeof b ? f = w(a2, Math.max(a2.first, Math.min(b, a2.first + a2.size - 1))) : e = N(b);
      if (null == e)
        return null;
      c(f, e) && a2.cm && Sa(a2.cm, e, d2);
      return f;
    }
    function ec(a2) {
      this.lines = a2;
      this.parent = null;
      for (var b = 0, d2 = 0; d2 < a2.length; ++d2)
        a2[d2].parent = this, b += a2[d2].height;
      this.height = b;
    }
    function fc(a2) {
      this.children = a2;
      for (var b = 0, d2 = 0, c = 0; c < a2.length; ++c) {
        var e = a2[c];
        b += e.chunkSize();
        d2 += e.height;
        e.parent = this;
      }
      this.size = b;
      this.height = d2;
      this.parent = null;
    }
    function ch(a2, b, d2, c) {
      var e = new gc(a2, d2, c), f = a2.cm;
      f && e.noHScroll && (f.display.alignWidgets = true);
      dc(a2, b, "widget", function(g) {
        var h2 = g.widgets || (g.widgets = []);
        null == e.insertAt ? h2.push(e) : h2.splice(Math.min(h2.length, Math.max(0, e.insertAt)), 0, e);
        e.line = g;
        f && !Pa(a2, g) && (h2 = Ga(g) < a2.scrollTop, Ea(g, g.height + Tb(e)), h2 && Nc(f, e.height), f.curOp.forceUpdate = true);
        return true;
      });
      f && aa(f, "lineWidgetAdded", f, e, "number" == typeof b ? b : N(b));
      return e;
    }
    function Eb(a2, b, d2, c, e) {
      if (c && c.shared)
        return dh(
          a2,
          b,
          d2,
          c,
          e
        );
      if (a2.cm && !a2.cm.curOp)
        return ba(a2.cm, Eb)(a2, b, d2, c, e);
      var f = new Va(a2, e);
      e = B(b, d2);
      c && Za(c, f, false);
      if (0 < e || 0 == e && false !== f.clearWhenEmpty)
        return f;
      f.replacedWith && (f.collapsed = true, f.widgetNode = M("span", [f.replacedWith], "CodeMirror-widget"), c.handleMouseEvents || f.widgetNode.setAttribute("cm-ignore-events", "true"), c.insertLeft && (f.widgetNode.insertLeft = true));
      if (f.collapsed) {
        if (Ie(a2, b.line, b, d2, f) || b.line != d2.line && Ie(a2, d2.line, b, d2, f))
          throw Error("Inserting collapsed marker partially overlapping an existing one");
        Ka = true;
      }
      f.addToHistory && Df(a2, { from: b, to: d2, origin: "markText" }, a2.sel, NaN);
      var g = b.line, h2 = a2.cm, k;
      a2.iter(g, d2.line + 1, function(l) {
        h2 && f.collapsed && !h2.options.lineWrapping && za(l) == h2.display.maxLine && (k = true);
        f.collapsed && g != b.line && Ea(l, 0);
        var m2 = new Dc(f, g == b.line ? b.ch : null, g == d2.line ? d2.ch : null), n = a2.cm && a2.cm.curOp;
        (n = n && window.WeakSet && (n.markedSpans || (n.markedSpans = /* @__PURE__ */ new WeakSet()))) && l.markedSpans && n.has(l.markedSpans) ? l.markedSpans.push(m2) : (l.markedSpans = l.markedSpans ? l.markedSpans.concat([m2]) : [m2], n && n.add(l.markedSpans));
        m2.marker.attachLine(l);
        ++g;
      });
      f.collapsed && a2.iter(b.line, d2.line + 1, function(l) {
        Pa(a2, l) && Ea(l, 0);
      });
      f.clearOnEnter && z(f, "beforeCursorEnter", function() {
        return f.clear();
      });
      f.readOnly && (Nf = true, (a2.history.done.length || a2.history.undone.length) && a2.clearHistory());
      f.collapsed && (f.id = ++Tf, f.atomic = true);
      if (h2) {
        k && (h2.curOp.updateMaxLine = true);
        if (f.collapsed)
          ma(h2, b.line, d2.line + 1);
        else if (f.className || f.startStyle || f.endStyle || f.css || f.attributes || f.title)
          for (c = b.line; c <= d2.line; c++)
            Sa(h2, c, "text");
        f.atomic && Jf(h2.doc);
        aa(h2, "markerAdded", h2, f);
      }
      return f;
    }
    function dh(a2, b, d2, c, e) {
      c = Za(c);
      c.shared = false;
      var f = [Eb(a2, b, d2, c, e)], g = f[0], h2 = c.widgetNode;
      Ua(a2, function(k) {
        h2 && (c.widgetNode = h2.cloneNode(true));
        f.push(Eb(k, C(k, b), C(k, d2), c, e));
        for (var l = 0; l < k.linked.length; ++l)
          if (k.linked[l].isParent)
            return;
        g = J(f);
      });
      return new hc(f, g);
    }
    function Uf(a2) {
      return a2.findMarks(t(a2.first, 0), a2.clipPos(t(a2.lastLine())), function(b) {
        return b.parent;
      });
    }
    function eh(a2) {
      for (var b = function(c) {
        c = a2[c];
        var e = [c.primary.doc];
        Ua(c.primary.doc, function(h2) {
          return e.push(h2);
        });
        for (var f = 0; f < c.markers.length; f++) {
          var g = c.markers[f];
          -1 == ea(e, g.doc) && (g.parent = null, c.markers.splice(f--, 1));
        }
      }, d2 = 0; d2 < a2.length; d2++)
        b(d2);
    }
    function fh(a2) {
      var b = this;
      Vf(b);
      if (!Z(b, a2) && !La(b.display, a2)) {
        la(a2);
        G && (Wf = +/* @__PURE__ */ new Date());
        var d2 = gb(b, a2, true), c = a2.dataTransfer.files;
        if (d2 && !b.isReadOnly())
          if (c && c.length && window.FileReader && window.File)
            for (var e = c.length, f = Array(e), g = 0, h2 = function() {
              ++g == e && ba(b, function() {
                d2 = C(b.doc, d2);
                var m2 = {
                  from: d2,
                  to: d2,
                  text: b.doc.splitLines(f.filter(function(n) {
                    return null != n;
                  }).join(b.doc.lineSeparator())),
                  origin: "paste"
                };
                Cb(b.doc, m2);
                Gf(b.doc, Oa(C(b.doc, d2), C(b.doc, Ta(m2))));
              })();
            }, k = function(m2, n) {
              if (b.options.allowDropFileTypes && -1 == ea(b.options.allowDropFileTypes, m2.type))
                h2();
              else {
                var p = new FileReader();
                p.onerror = function() {
                  return h2();
                };
                p.onload = function() {
                  var q = p.result;
                  /[\x00-\x08\x0e-\x1f]{2}/.test(q) || (f[n] = q);
                  h2();
                };
                p.readAsText(m2);
              }
            }, l = 0; l < c.length; l++)
              k(c[l], l);
          else if (b.state.draggingText && -1 < b.doc.sel.contains(d2))
            b.state.draggingText(a2), setTimeout(function() {
              return b.display.input.focus();
            }, 20);
          else
            try {
              if (k = a2.dataTransfer.getData("Text")) {
                b.state.draggingText && !b.state.draggingText.copy && (l = b.listSelections());
                Uc(b.doc, Oa(d2, d2));
                if (l)
                  for (c = 0; c < l.length; ++c)
                    Db(b.doc, "", l[c].anchor, l[c].head, "drag");
                b.replaceSelection(k, "around", "paste");
                b.display.input.focus();
              }
            } catch (m2) {
            }
      }
    }
    function Vf(a2) {
      a2.display.dragCursor && (a2.display.lineSpace.removeChild(a2.display.dragCursor), a2.display.dragCursor = null);
    }
    function Xf(a2) {
      if (document.getElementsByClassName) {
        for (var b = document.getElementsByClassName("CodeMirror"), d2 = [], c = 0; c < b.length; c++) {
          var e = b[c].CodeMirror;
          e && d2.push(e);
        }
        d2.length && d2[0].operation(function() {
          for (var f = 0; f < d2.length; f++)
            a2(d2[f]);
        });
      }
    }
    function gh() {
      var a2;
      z(window, "resize", function() {
        null == a2 && (a2 = setTimeout(function() {
          a2 = null;
          Xf(hh);
        }, 100));
      });
      z(window, "blur", function() {
        return Xf(wb);
      });
    }
    function hh(a2) {
      var b = a2.display;
      b.cachedCharWidth = b.cachedTextHeight = b.cachedPaddingH = null;
      b.scrollbarsClipped = false;
      a2.setSize();
    }
    function ih(a2) {
      var b = a2.split(/-(?!$)/);
      a2 = b[b.length - 1];
      for (var d2, c, e, f, g = 0; g < b.length - 1; g++) {
        var h2 = b[g];
        if (/^(cmd|meta|m)$/i.test(h2))
          f = true;
        else if (/^a(lt)?$/i.test(h2))
          d2 = true;
        else if (/^(c|ctrl|control)$/i.test(h2))
          c = true;
        else if (/^s(hift)?$/i.test(h2))
          e = true;
        else
          throw Error("Unrecognized modifier name: " + h2);
      }
      d2 && (a2 = "Alt-" + a2);
      c && (a2 = "Ctrl-" + a2);
      f && (a2 = "Cmd-" + a2);
      e && (a2 = "Shift-" + a2);
      return a2;
    }
    function jh(a2) {
      var b = {}, d2;
      for (d2 in a2)
        if (a2.hasOwnProperty(d2)) {
          var c = a2[d2];
          if (!/^(name|fallthrough|(de|at)tach)$/.test(d2)) {
            if ("..." != c)
              for (var e = wc(d2.split(" "), ih), f = 0; f < e.length; f++) {
                if (f == e.length - 1) {
                  var g = e.join(" ");
                  var h2 = c;
                } else
                  g = e.slice(0, f + 1).join(" "), h2 = "...";
                var k = b[g];
                if (!k)
                  b[g] = h2;
                else if (k != h2)
                  throw Error("Inconsistent bindings for " + g);
              }
            delete a2[d2];
          }
        }
      for (var l in b)
        a2[l] = b[l];
      return a2;
    }
    function Fb(a2, b, d2, c) {
      b = Xc(b);
      var e = b.call ? b.call(a2, c) : b[a2];
      if (false === e)
        return "nothing";
      if ("..." === e)
        return "multi";
      if (null != e && d2(e))
        return "handled";
      if (b.fallthrough) {
        if ("[object Array]" != Object.prototype.toString.call(b.fallthrough))
          return Fb(a2, b.fallthrough, d2, c);
        for (e = 0; e < b.fallthrough.length; e++) {
          var f = Fb(a2, b.fallthrough[e], d2, c);
          if (f)
            return f;
        }
      }
    }
    function Yf(a2) {
      a2 = "string" == typeof a2 ? a2 : Wa[a2.keyCode];
      return "Ctrl" == a2 || "Alt" == a2 || "Shift" == a2 || "Mod" == a2;
    }
    function Zf(a2, b, d2) {
      var c = a2;
      b.altKey && "Alt" != c && (a2 = "Alt-" + a2);
      ($f ? b.metaKey : b.ctrlKey) && "Ctrl" != c && (a2 = "Ctrl-" + a2);
      ($f ? b.ctrlKey : b.metaKey) && "Mod" != c && (a2 = "Cmd-" + a2);
      !d2 && b.shiftKey && "Shift" != c && (a2 = "Shift-" + a2);
      return a2;
    }
    function ag(a2, b) {
      if (Ca && 34 == a2.keyCode && a2["char"])
        return false;
      var d2 = Wa[a2.keyCode];
      if (null == d2 || a2.altGraphKey)
        return false;
      3 == a2.keyCode && a2.code && (d2 = a2.code);
      return Zf(d2, a2, b);
    }
    function Xc(a2) {
      return "string" == typeof a2 ? ic[a2] : a2;
    }
    function Gb(a2, b) {
      for (var d2 = a2.doc.sel.ranges, c = [], e = 0; e < d2.length; e++) {
        for (var f = b(d2[e]); c.length && 0 >= B(f.from, J(c).to); ) {
          var g = c.pop();
          if (0 > B(g.from, f.from)) {
            f.from = g.from;
            break;
          }
        }
        c.push(f);
      }
      ra(a2, function() {
        for (var h2 = c.length - 1; 0 <= h2; h2--)
          Db(a2.doc, "", c[h2].from, c[h2].to, "+delete");
        xb(a2);
      });
    }
    function ee(a2, b, d2) {
      b = se(a2.text, b + d2, d2);
      return 0 > b || b > a2.text.length ? null : b;
    }
    function fe(a2, b, d2) {
      a2 = ee(a2, b.ch, d2);
      return null == a2 ? null : new t(b.line, a2, 0 > d2 ? "after" : "before");
    }
    function ge(a2, b, d2, c, e) {
      if (a2 && ("rtl" == b.doc.direction && (e = -e), a2 = Ja(d2, b.doc.direction))) {
        a2 = 0 > e ? J(a2) : a2[0];
        var f = 0 > e == (1 == a2.level) ? "after" : "before";
        if (0 < a2.level || "rtl" == b.doc.direction) {
          var g = eb(b, d2);
          var h2 = 0 > e ? d2.text.length - 1 : 0;
          var k = Aa(b, g, h2).top;
          h2 = Jb(function(l) {
            return Aa(b, g, l).top == k;
          }, 0 > e == (1 == a2.level) ? a2.from : a2.to - 1, h2);
          "before" == f && (h2 = ee(d2, h2, 1));
        } else
          h2 = 0 > e ? a2.to : a2.from;
        return new t(c, h2, f);
      }
      return new t(c, 0 > e ? d2.text.length : 0, 0 > e ? "before" : "after");
    }
    function kh(a2, b, d2, c) {
      var e = Ja(b, a2.doc.direction);
      if (!e)
        return fe(b, d2, c);
      d2.ch >= b.text.length ? (d2.ch = b.text.length, d2.sticky = "before") : 0 >= d2.ch && (d2.ch = 0, d2.sticky = "after");
      var f = Kb(e, d2.ch, d2.sticky), g = e[f];
      if ("ltr" == a2.doc.direction && 0 == g.level % 2 && (0 < c ? g.to > d2.ch : g.from < d2.ch))
        return fe(b, d2, c);
      var h2 = function(q, r) {
        return ee(b, q instanceof t ? q.ch : q, r);
      }, k, l = function(q) {
        if (!a2.options.lineWrapping)
          return { begin: 0, end: b.text.length };
        k = k || eb(a2, b);
        return df(a2, b, k, q);
      }, m2 = l("before" == d2.sticky ? h2(d2, -1) : d2.ch);
      if ("rtl" == a2.doc.direction || 1 == g.level) {
        var n = 1 == g.level == 0 > c, p = h2(d2, n ? 1 : -1);
        if (null != p && (n ? p <= g.to && p <= m2.end : p >= g.from && p >= m2.begin))
          return new t(d2.line, p, n ? "before" : "after");
      }
      g = function(q, r, u) {
        for (var A = function(K, Q) {
          return Q ? new t(d2.line, h2(K, 1), "before") : new t(d2.line, K, "after");
        }; 0 <= q && q < e.length; q += r) {
          var Y = e[q], x2 = 0 < r == (1 != Y.level), P = x2 ? u.begin : h2(u.end, -1);
          if (Y.from <= P && P < Y.to)
            return A(P, x2);
          P = x2 ? Y.from : h2(Y.to, -1);
          if (u.begin <= P && P < u.end)
            return A(P, x2);
        }
      };
      if (f = g(f + c, c, m2))
        return f;
      m2 = 0 < c ? m2.end : h2(m2.begin, -1);
      return null == m2 || 0 < c && m2 == b.text.length || !(f = g(0 < c ? 0 : e.length - 1, c, l(m2))) ? null : f;
    }
    function bg(a2, b) {
      var d2 = w(
        a2.doc,
        b
      ), c = za(d2);
      c != d2 && (b = N(c));
      return ge(true, a2, c, b, 1);
    }
    function cg(a2, b) {
      var d2 = bg(a2, b.line), c = w(a2.doc, d2.line);
      a2 = Ja(c, a2.doc.direction);
      return a2 && 0 != a2[0].level ? d2 : (c = Math.max(d2.ch, c.text.search(/\S/)), t(d2.line, b.line == d2.line && b.ch <= c && b.ch ? 0 : c, d2.sticky));
    }
    function Yc(a2, b, d2) {
      if ("string" == typeof b && (b = jc[b], !b))
        return false;
      a2.display.input.ensurePolled();
      var c = a2.display.shift, e = false;
      try {
        a2.isReadOnly() && (a2.state.suppressEdits = true), d2 && (a2.display.shift = false), e = b(a2) != Zc;
      } finally {
        a2.display.shift = c, a2.state.suppressEdits = false;
      }
      return e;
    }
    function kc(a2, b, d2, c) {
      var e = a2.state.keySeq;
      if (e) {
        if (Yf(b))
          return "handled";
        /'$/.test(b) ? a2.state.keySeq = null : lh.set(50, function() {
          a2.state.keySeq == e && (a2.state.keySeq = null, a2.display.input.reset());
        });
        if (dg(a2, e + " " + b, d2, c))
          return true;
      }
      return dg(a2, b, d2, c);
    }
    function dg(a2, b, d2, c) {
      a: {
        for (var e = 0; e < a2.state.keyMaps.length; e++) {
          var f = Fb(b, a2.state.keyMaps[e], c, a2);
          if (f) {
            c = f;
            break a;
          }
        }
        c = a2.options.extraKeys && Fb(b, a2.options.extraKeys, c, a2) || Fb(b, a2.options.keyMap, c, a2);
      }
      "multi" == c && (a2.state.keySeq = b);
      "handled" == c && aa(
        a2,
        "keyHandled",
        a2,
        b,
        d2
      );
      if ("handled" == c || "multi" == c)
        la(d2), Qd(a2);
      return !!c;
    }
    function eg(a2, b) {
      var d2 = ag(b, true);
      return d2 ? b.shiftKey && !a2.state.keySeq ? kc(a2, "Shift-" + d2, b, function(c) {
        return Yc(a2, c, true);
      }) || kc(a2, d2, b, function(c) {
        if ("string" == typeof c ? /^go[A-Z]/.test(c) : c.motion)
          return Yc(a2, c);
      }) : kc(a2, d2, b, function(c) {
        return Yc(a2, c);
      }) : false;
    }
    function mh(a2, b, d2) {
      return kc(a2, "'" + d2 + "'", b, function(c) {
        return Yc(a2, c, true);
      });
    }
    function fg(a2) {
      if (!a2.target || a2.target == this.display.input.getField()) {
        if (this.curOp.focus = ka(qa(this)), !Z(this, a2)) {
          G && 11 > T && 27 == a2.keyCode && (a2.returnValue = false);
          var b = a2.keyCode;
          this.display.shift = 16 == b || a2.shiftKey;
          var d2 = eg(this, a2);
          Ca && (he = d2 ? b : null, !d2 && 88 == b && !nh && (ya ? a2.metaKey : a2.ctrlKey) && this.replaceSelection("", null, "cut"));
          Ma && !ya && !d2 && 46 == b && a2.shiftKey && !a2.ctrlKey && document.execCommand && document.execCommand("cut");
          18 != b || /\bCodeMirror-crosshair\b/.test(this.display.lineDiv.className) || oh(this);
        }
      }
    }
    function oh(a2) {
      function b(c) {
        18 != c.keyCode && c.altKey || (jb(d2, "CodeMirror-crosshair"), ta(document, "keyup", b), ta(
          document,
          "mouseover",
          b
        ));
      }
      var d2 = a2.display.lineDiv;
      Ya(d2, "CodeMirror-crosshair");
      z(document, "keyup", b);
      z(document, "mouseover", b);
    }
    function gg(a2) {
      16 == a2.keyCode && (this.doc.sel.shift = false);
      Z(this, a2);
    }
    function hg(a2) {
      if (!(a2.target && a2.target != this.display.input.getField() || La(this.display, a2) || Z(this, a2) || a2.ctrlKey && !a2.altKey || ya && a2.metaKey)) {
        var b = a2.keyCode, d2 = a2.charCode;
        if (Ca && b == he)
          he = null, la(a2);
        else if (!Ca || a2.which && !(10 > a2.which) || !eg(this, a2)) {
          if (b = String.fromCharCode(null == d2 ? b : d2), "\b" != b && !mh(this, a2, b))
            this.display.input.onKeyPress(a2);
        }
      }
    }
    function ph(a2, b) {
      var d2 = +/* @__PURE__ */ new Date();
      if (lc && lc.compare(d2, a2, b))
        return mc = lc = null, "triple";
      if (mc && mc.compare(d2, a2, b))
        return lc = new ie(d2, a2, b), mc = null, "double";
      mc = new ie(d2, a2, b);
      lc = null;
      return "single";
    }
    function ig(a2) {
      var b = this.display;
      if (!(Z(this, a2) || b.activeTouch && b.input.supportsTouch())) {
        if (b.input.ensurePolled(), b.shift = a2.shiftKey, La(b, a2))
          fa || (b.scroller.draggable = false, setTimeout(function() {
            return b.scroller.draggable = true;
          }, 100));
        else if (!$c(this, a2, "gutterClick", true)) {
          var d2 = gb(this, a2), c = ve(a2), e = d2 ? ph(d2, c) : "single";
          qa(this).defaultView.focus();
          1 == c && this.state.selectingText && this.state.selectingText(a2);
          if (!d2 || !qh(this, c, d2, e, a2)) {
            if (1 == c)
              d2 ? rh(this, d2, e, a2) : (a2.target || a2.srcElement) == b.scroller && la(a2);
            else if (2 == c)
              d2 && Tc(this.doc, d2), setTimeout(function() {
                return b.input.focus();
              }, 20);
            else if (3 == c)
              if (je)
                this.display.input.onContextMenu(a2);
              else
                Sd(this);
          }
        }
      }
    }
    function qh(a2, b, d2, c, e) {
      var f = "Click";
      "double" == c ? f = "Double" + f : "triple" == c && (f = "Triple" + f);
      return kc(a2, Zf((1 == b ? "Left" : 2 == b ? "Middle" : "Right") + f, e), e, function(g) {
        "string" == typeof g && (g = jc[g]);
        if (!g)
          return false;
        var h2 = false;
        try {
          a2.isReadOnly() && (a2.state.suppressEdits = true), h2 = g(a2, d2) != Zc;
        } finally {
          a2.state.suppressEdits = false;
        }
        return h2;
      });
    }
    function rh(a2, b, d2, c) {
      G ? setTimeout(gd(hf, a2), 0) : a2.curOp.focus = ka(qa(a2));
      var e = a2.getOption("configureMouse");
      e = e ? e(a2, d2, c) : {};
      null == e.unit && (e.unit = (sh ? c.shiftKey && c.metaKey : c.altKey) ? "rectangle" : "single" == d2 ? "char" : "double" == d2 ? "word" : "line");
      if (null == e.extend || a2.doc.extend)
        e.extend = a2.doc.extend || c.shiftKey;
      null == e.addNew && (e.addNew = ya ? c.metaKey : c.ctrlKey);
      null == e.moveOnDrag && (e.moveOnDrag = !(ya ? c.altKey : c.ctrlKey));
      var f = a2.doc.sel, g;
      a2.options.dragDrop && th && !a2.isReadOnly() && "single" == d2 && -1 < (g = f.contains(b)) && (0 > B((g = f.ranges[g]).from(), b) || 0 < b.xRel) && (0 < B(g.to(), b) || 0 > b.xRel) ? uh(a2, c, b, e) : vh(a2, c, b, e);
    }
    function uh(a2, b, d2, c) {
      var e = a2.display, f = false, g = ba(a2, function(l) {
        fa && (e.scroller.draggable = false);
        a2.state.draggingText = false;
        a2.state.delayingBlurEvent && (a2.hasFocus() ? a2.state.delayingBlurEvent = false : Sd(a2));
        ta(e.wrapper.ownerDocument, "mouseup", g);
        ta(
          e.wrapper.ownerDocument,
          "mousemove",
          h2
        );
        ta(e.scroller, "dragstart", k);
        ta(e.scroller, "drop", g);
        f || (la(l), c.addNew || Tc(a2.doc, d2, null, null, c.extend), fa && !ad || G && 9 == T ? setTimeout(function() {
          e.wrapper.ownerDocument.body.focus({ preventScroll: true });
          e.input.focus();
        }, 20) : e.input.focus());
      }), h2 = function(l) {
        f = f || 10 <= Math.abs(b.clientX - l.clientX) + Math.abs(b.clientY - l.clientY);
      }, k = function() {
        return f = true;
      };
      fa && (e.scroller.draggable = true);
      a2.state.draggingText = g;
      g.copy = !c.moveOnDrag;
      z(e.wrapper.ownerDocument, "mouseup", g);
      z(
        e.wrapper.ownerDocument,
        "mousemove",
        h2
      );
      z(e.scroller, "dragstart", k);
      z(e.scroller, "drop", g);
      a2.state.delayingBlurEvent = true;
      setTimeout(function() {
        return e.input.focus();
      }, 20);
      e.scroller.dragDrop && e.scroller.dragDrop();
    }
    function jg(a2, b, d2) {
      if ("char" == d2)
        return new I(b, b);
      if ("word" == d2)
        return a2.findWordAt(b);
      if ("line" == d2)
        return new I(t(b.line, 0), C(a2.doc, t(b.line + 1, 0)));
      a2 = d2(a2, b);
      return new I(a2.from, a2.to);
    }
    function vh(a2, b, d2, c) {
      function e(x2) {
        if (0 != B(q, x2))
          if (q = x2, "rectangle" == c.unit) {
            var P = [], K = a2.options.tabSize, Q = wa(
              w(k, d2.line).text,
              d2.ch,
              K
            ), S = wa(w(k, x2.line).text, x2.ch, K), F = Math.min(Q, S);
            Q = Math.max(Q, S);
            S = Math.min(d2.line, x2.line);
            for (var R2 = Math.min(a2.lastLine(), Math.max(d2.line, x2.line)); S <= R2; S++) {
              var H = w(k, S).text, L = hd(H, F, K);
              F == Q ? P.push(new I(t(S, L), t(S, L))) : H.length > L && P.push(new I(t(S, L), t(S, hd(H, Q, K))));
            }
            P.length || P.push(new I(d2, d2));
            da(k, Da(a2, l.ranges.slice(0, n).concat(P), n), { origin: "*mouse", scroll: false });
            a2.scrollIntoView(x2);
          } else
            P = p, F = jg(a2, x2, c.unit), x2 = P.anchor, 0 < B(F.anchor, x2) ? (K = F.head, x2 = Bc(P.from(), F.anchor)) : (K = F.anchor, x2 = Ac(
              P.to(),
              F.head
            )), P = l.ranges.slice(0), P[n] = wh(a2, new I(C(k, x2), K)), da(k, Da(a2, P, n), ke);
      }
      function f(x2) {
        var P = ++u, K = gb(a2, x2, true, "rectangle" == c.unit);
        if (K)
          if (0 != B(K, q)) {
            a2.curOp.focus = ka(qa(a2));
            e(K);
            var Q = Mc(h2, k);
            (K.line >= Q.to || K.line < Q.from) && setTimeout(ba(a2, function() {
              u == P && f(x2);
            }), 150);
          } else {
            var S = x2.clientY < r.top ? -20 : x2.clientY > r.bottom ? 20 : 0;
            S && setTimeout(ba(a2, function() {
              u == P && (h2.scroller.scrollTop += S, f(x2));
            }), 50);
          }
      }
      function g(x2) {
        a2.state.selectingText = false;
        u = Infinity;
        x2 && (la(x2), h2.input.focus());
        ta(
          h2.wrapper.ownerDocument,
          "mousemove",
          A
        );
        ta(h2.wrapper.ownerDocument, "mouseup", Y);
        k.history.lastSelOrigin = null;
      }
      G && Sd(a2);
      var h2 = a2.display, k = a2.doc;
      la(b);
      var l = k.sel, m2 = l.ranges;
      if (c.addNew && !c.extend) {
        var n = k.sel.contains(d2);
        var p = -1 < n ? m2[n] : new I(d2, d2);
      } else
        p = k.sel.primary(), n = k.sel.primIndex;
      "rectangle" == c.unit ? (c.addNew || (p = new I(d2, d2)), d2 = gb(a2, b, true, true), n = -1) : (b = jg(a2, d2, c.unit), p = c.extend ? ce(p, b.anchor, b.head, c.extend) : b);
      c.addNew ? -1 == n ? (n = m2.length, da(k, Da(a2, m2.concat([p]), n), { scroll: false, origin: "*mouse" })) : 1 < m2.length && m2[n].empty() && "char" == c.unit && !c.extend ? (da(k, Da(a2, m2.slice(0, n).concat(m2.slice(n + 1)), 0), { scroll: false, origin: "*mouse" }), l = k.sel) : de(k, n, p, ke) : (n = 0, da(k, new va([p], 0), ke), l = k.sel);
      var q = d2, r = h2.wrapper.getBoundingClientRect(), u = 0, A = ba(a2, function(x2) {
        0 !== x2.buttons && ve(x2) ? f(x2) : g(x2);
      }), Y = ba(a2, g);
      a2.state.selectingText = Y;
      z(h2.wrapper.ownerDocument, "mousemove", A);
      z(h2.wrapper.ownerDocument, "mouseup", Y);
    }
    function wh(a2, b) {
      var d2 = b.anchor, c = b.head, e = w(a2.doc, d2.line);
      if (0 == B(d2, c) && d2.sticky == c.sticky)
        return b;
      e = Ja(e);
      if (!e)
        return b;
      var f = Kb(e, d2.ch, d2.sticky), g = e[f];
      if (g.from != d2.ch && g.to != d2.ch)
        return b;
      var h2 = f + (g.from == d2.ch == (1 != g.level) ? 0 : 1);
      if (0 == h2 || h2 == e.length)
        return b;
      c.line != d2.line ? a2 = 0 < (c.line - d2.line) * ("ltr" == a2.doc.direction ? 1 : -1) : (a2 = Kb(e, c.ch, c.sticky), f = a2 - f || (c.ch - d2.ch) * (1 == g.level ? -1 : 1), a2 = a2 == h2 - 1 || a2 == h2 ? 0 > f : 0 < f);
      e = e[h2 + (a2 ? -1 : 0)];
      e = (h2 = a2 == (1 == e.level)) ? e.from : e.to;
      h2 = h2 ? "after" : "before";
      return d2.ch == e && d2.sticky == h2 ? b : new I(new t(d2.line, e, h2), c);
    }
    function $c(a2, b, d2, c) {
      if (b.touches) {
        var e = b.touches[0].clientX;
        var f = b.touches[0].clientY;
      } else
        try {
          e = b.clientX, f = b.clientY;
        } catch (k) {
          return false;
        }
      if (e >= Math.floor(a2.display.gutters.getBoundingClientRect().right))
        return false;
      c && la(b);
      c = a2.display;
      var g = c.lineDiv.getBoundingClientRect();
      if (f > g.bottom || !xa(a2, d2))
        return ld(b);
      f -= g.top - c.viewOffset;
      for (g = 0; g < a2.display.gutterSpecs.length; ++g) {
        var h2 = c.gutters.childNodes[g];
        if (h2 && h2.getBoundingClientRect().right >= e)
          return e = bb(a2.doc, f), W(a2, d2, a2, e, a2.display.gutterSpecs[g].className, b), ld(b);
      }
    }
    function kg(a2, b) {
      var d2;
      (d2 = La(a2.display, b)) || (d2 = xa(a2, "gutterContextMenu") ? $c(
        a2,
        b,
        "gutterContextMenu",
        false
      ) : false);
      if (!d2 && !Z(a2, b, "contextmenu") && !je)
        a2.display.input.onContextMenu(b);
    }
    function lg(a2) {
      a2.display.wrapper.className = a2.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + a2.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
      Ub(a2);
    }
    function xh(a2, b, d2) {
      !b != !(d2 && d2 != Hb) && (d2 = a2.display.dragFunctions, b = b ? z : ta, b(a2.display.scroller, "dragstart", d2.start), b(a2.display.scroller, "dragenter", d2.enter), b(a2.display.scroller, "dragover", d2.over), b(a2.display.scroller, "dragleave", d2.leave), b(
        a2.display.scroller,
        "drop",
        d2.drop
      ));
    }
    function yh(a2) {
      a2.options.lineWrapping ? (Ya(a2.display.wrapper, "CodeMirror-wrap"), a2.display.sizer.style.minWidth = "", a2.display.sizerWidth = null) : (jb(a2.display.wrapper, "CodeMirror-wrap"), zd(a2));
      Nd(a2);
      ma(a2);
      Ub(a2);
      setTimeout(function() {
        return yb(a2);
      }, 100);
    }
    function U(a2, b) {
      var d2 = this;
      if (!(this instanceof U))
        return new U(a2, b);
      this.options = b = b ? Za(b) : {};
      Za(mg, b, false);
      var c = b.value;
      "string" == typeof c ? c = new oa(c, b.mode, null, b.lineSeparator, b.direction) : b.mode && (c.modeOption = b.mode);
      this.doc = c;
      var e = new U.inputStyles[b.inputStyle](this);
      a2 = this.display = new Yg(a2, c, e, b);
      a2.wrapper.CodeMirror = this;
      lg(this);
      b.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap");
      of(this);
      this.state = { keyMaps: [], overlays: [], modeGen: 0, overwrite: false, delayingBlurEvent: false, focused: false, suppressEdits: false, pasteIncoming: -1, cutIncoming: -1, selectingText: false, draggingText: false, highlight: new Xa(), keySeq: null, specialChars: null };
      b.autofocus && !ac && a2.input.focus();
      G && 11 > T && setTimeout(
        function() {
          return d2.display.input.reset(true);
        },
        20
      );
      zh(this);
      ng || (gh(), ng = true);
      lb(this);
      this.curOp.forceUpdate = true;
      zf(this, c);
      b.autofocus && !ac || this.hasFocus() ? setTimeout(function() {
        d2.hasFocus() && !d2.state.focused && Rd(d2);
      }, 20) : wb(this);
      for (var f in bd)
        if (bd.hasOwnProperty(f))
          bd[f](this, b[f], Hb);
      rf(this);
      b.finishInit && b.finishInit(this);
      for (c = 0; c < le.length; ++c)
        le[c](this);
      mb(this);
      fa && b.lineWrapping && "optimizelegibility" == getComputedStyle(a2.lineDiv).textRendering && (a2.lineDiv.style.textRendering = "auto");
    }
    function zh(a2) {
      function b() {
        c.activeTouch && (e = setTimeout(function() {
          return c.activeTouch = null;
        }, 1e3), f = c.activeTouch, f.end = +/* @__PURE__ */ new Date());
      }
      function d2(h2, k) {
        if (null == k.left)
          return true;
        var l = k.left - h2.left;
        h2 = k.top - h2.top;
        return 400 < l * l + h2 * h2;
      }
      var c = a2.display;
      z(c.scroller, "mousedown", ba(a2, ig));
      G && 11 > T ? z(c.scroller, "dblclick", ba(a2, function(h2) {
        if (!Z(a2, h2)) {
          var k = gb(a2, h2);
          !k || $c(a2, h2, "gutterClick", true) || La(a2.display, h2) || (la(h2), h2 = a2.findWordAt(k), Tc(a2.doc, h2.anchor, h2.head));
        }
      })) : z(c.scroller, "dblclick", function(h2) {
        return Z(a2, h2) || la(h2);
      });
      z(c.scroller, "contextmenu", function(h2) {
        return kg(
          a2,
          h2
        );
      });
      z(c.input.getField(), "contextmenu", function(h2) {
        c.scroller.contains(h2.target) || kg(a2, h2);
      });
      var e, f = { end: 0 };
      z(c.scroller, "touchstart", function(h2) {
        var k;
        if (k = !Z(a2, h2))
          1 != h2.touches.length ? k = false : (k = h2.touches[0], k = 1 >= k.radiusX && 1 >= k.radiusY), k = !k;
        k && !$c(a2, h2, "gutterClick", true) && (c.input.ensurePolled(), clearTimeout(e), k = +/* @__PURE__ */ new Date(), c.activeTouch = { start: k, moved: false, prev: 300 >= k - f.end ? f : null }, 1 == h2.touches.length && (c.activeTouch.left = h2.touches[0].pageX, c.activeTouch.top = h2.touches[0].pageY));
      });
      z(
        c.scroller,
        "touchmove",
        function() {
          c.activeTouch && (c.activeTouch.moved = true);
        }
      );
      z(c.scroller, "touchend", function(h2) {
        var k = c.activeTouch;
        if (k && !La(c, h2) && null != k.left && !k.moved && 300 > /* @__PURE__ */ new Date() - k.start) {
          var l = a2.coordsChar(c.activeTouch, "page");
          k = !k.prev || d2(k, k.prev) ? new I(l, l) : !k.prev.prev || d2(k, k.prev.prev) ? a2.findWordAt(l) : new I(t(l.line, 0), C(a2.doc, t(l.line + 1, 0)));
          a2.setSelection(k.anchor, k.head);
          a2.focus();
          la(h2);
        }
        b();
      });
      z(c.scroller, "touchcancel", b);
      z(c.scroller, "scroll", function() {
        c.scroller.clientHeight && (Xb(a2, c.scroller.scrollTop), kb(a2, c.scroller.scrollLeft, true), W(a2, "scroll", a2));
      });
      z(c.scroller, "mousewheel", function(h2) {
        return vf(a2, h2);
      });
      z(c.scroller, "DOMMouseScroll", function(h2) {
        return vf(a2, h2);
      });
      z(c.wrapper, "scroll", function() {
        return c.wrapper.scrollTop = c.wrapper.scrollLeft = 0;
      });
      c.dragFunctions = { enter: function(h2) {
        Z(a2, h2) || Mb(h2);
      }, over: function(h2) {
        if (!Z(a2, h2)) {
          var k = gb(a2, h2);
          if (k) {
            var l = document.createDocumentFragment();
            Od(a2, k, l);
            a2.display.dragCursor || (a2.display.dragCursor = v("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), a2.display.lineSpace.insertBefore(
              a2.display.dragCursor,
              a2.display.cursorDiv
            ));
            D(a2.display.dragCursor, l);
          }
          Mb(h2);
        }
      }, start: function(h2) {
        if (G && (!a2.state.draggingText || 100 > +/* @__PURE__ */ new Date() - Wf))
          Mb(h2);
        else if (!Z(a2, h2) && !La(a2.display, h2) && (h2.dataTransfer.setData("Text", a2.getSelection()), h2.dataTransfer.effectAllowed = "copyMove", h2.dataTransfer.setDragImage && !ad)) {
          var k = v("img", null, null, "position: fixed; left: 0; top: 0;");
          k.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          Ca && (k.width = k.height = 1, a2.display.wrapper.appendChild(k), k._top = k.offsetTop);
          h2.dataTransfer.setDragImage(k, 0, 0);
          Ca && k.parentNode.removeChild(k);
        }
      }, drop: ba(a2, fh), leave: function(h2) {
        Z(a2, h2) || Vf(a2);
      } };
      var g = c.input.getField();
      z(g, "keyup", function(h2) {
        return gg.call(a2, h2);
      });
      z(g, "keydown", ba(a2, fg));
      z(g, "keypress", ba(a2, hg));
      z(g, "focus", function(h2) {
        return Rd(a2, h2);
      });
      z(g, "blur", function(h2) {
        return wb(a2, h2);
      });
    }
    function nc(a2, b, d2, c) {
      var e = a2.doc, f;
      null == d2 && (d2 = "add");
      "smart" == d2 && (e.mode.indent ? f = Ob(a2, b).state : d2 = "prev");
      var g = a2.options.tabSize, h2 = w(e, b), k = wa(h2.text, null, g);
      h2.stateAfter && (h2.stateAfter = null);
      var l = h2.text.match(/^\s*/)[0];
      if (!c && !/\S/.test(h2.text)) {
        var m2 = 0;
        d2 = "not";
      } else if ("smart" == d2 && (m2 = e.mode.indent(f, h2.text.slice(l.length), h2.text), m2 == Zc || 150 < m2)) {
        if (!c)
          return;
        d2 = "prev";
      }
      "prev" == d2 ? m2 = b > e.first ? wa(w(e, b - 1).text, null, g) : 0 : "add" == d2 ? m2 = k + a2.options.indentUnit : "subtract" == d2 ? m2 = k - a2.options.indentUnit : "number" == typeof d2 && (m2 = k + d2);
      m2 = Math.max(0, m2);
      d2 = "";
      c = 0;
      if (a2.options.indentWithTabs)
        for (a2 = Math.floor(m2 / g); a2; --a2)
          c += g, d2 += "	";
      c < m2 && (d2 += id2(m2 - c));
      if (d2 != l)
        return Db(e, d2, t(b, 0), t(b, l.length), "+input"), h2.stateAfter = null, true;
      for (g = 0; g < e.sel.ranges.length; g++)
        if (h2 = e.sel.ranges[g], h2.head.line == b && h2.head.ch < l.length) {
          b = t(b, l.length);
          de(e, g, new I(b, b));
          break;
        }
    }
    function me(a2, b, d2, c, e) {
      var f = a2.doc;
      a2.display.shift = false;
      c || (c = f.sel);
      var g = +/* @__PURE__ */ new Date() - 200, h2 = "paste" == e || a2.state.pasteIncoming > g, k = ne(b), l = null;
      if (h2 && 1 < c.ranges.length)
        if (sa && sa.text.join("\n") == b) {
          if (0 == c.ranges.length % sa.text.length) {
            l = [];
            for (var m2 = 0; m2 < sa.text.length; m2++)
              l.push(f.splitLines(sa.text[m2]));
          }
        } else
          k.length == c.ranges.length && a2.options.pasteLinesPerSelection && (l = wc(k, function(u) {
            return [u];
          }));
      m2 = a2.curOp.updateInput;
      for (var n = c.ranges.length - 1; 0 <= n; n--) {
        var p = c.ranges[n], q = p.from(), r = p.to();
        p.empty() && (d2 && 0 < d2 ? q = t(q.line, q.ch - d2) : a2.state.overwrite && !h2 ? r = t(r.line, Math.min(w(f, r.line).text.length, r.ch + J(k).length)) : h2 && sa && sa.lineWise && sa.text.join("\n") == k.join("\n") && (q = r = t(q.line, 0)));
        p = { from: q, to: r, text: l ? l[n % l.length] : k, origin: e || (h2 ? "paste" : a2.state.cutIncoming > g ? "cut" : "+input") };
        Cb(a2.doc, p);
        aa(a2, "inputRead", a2, p);
      }
      b && !h2 && og(a2, b);
      xb(a2);
      2 > a2.curOp.updateInput && (a2.curOp.updateInput = m2);
      a2.curOp.typing = true;
      a2.state.pasteIncoming = a2.state.cutIncoming = -1;
    }
    function pg(a2, b) {
      var d2 = a2.clipboardData && a2.clipboardData.getData("Text");
      if (d2)
        return a2.preventDefault(), b.isReadOnly() || b.options.disableInput || !b.hasFocus() || ra(b, function() {
          return me(b, d2, 0, null, "paste");
        }), true;
    }
    function og(a2, b) {
      if (a2.options.electricChars && a2.options.smartIndent)
        for (var d2 = a2.doc.sel, c = d2.ranges.length - 1; 0 <= c; c--) {
          var e = d2.ranges[c];
          if (!(100 < e.head.ch || c && d2.ranges[c - 1].head.line == e.head.line)) {
            var f = a2.getModeAt(e.head), g = false;
            if (f.electricChars)
              for (var h2 = 0; h2 < f.electricChars.length; h2++) {
                if (-1 < b.indexOf(f.electricChars.charAt(h2))) {
                  g = nc(a2, e.head.line, "smart");
                  break;
                }
              }
            else
              f.electricInput && f.electricInput.test(w(a2.doc, e.head.line).text.slice(0, e.head.ch)) && (g = nc(a2, e.head.line, "smart"));
            g && aa(a2, "electricInput", a2, e.head.line);
          }
        }
    }
    function qg(a2) {
      for (var b = [], d2 = [], c = 0; c < a2.doc.sel.ranges.length; c++) {
        var e = a2.doc.sel.ranges[c].head.line;
        e = { anchor: t(e, 0), head: t(e + 1, 0) };
        d2.push(e);
        b.push(a2.getRange(e.anchor, e.head));
      }
      return {
        text: b,
        ranges: d2
      };
    }
    function rg(a2, b, d2, c) {
      a2.setAttribute("autocorrect", d2 ? "" : "off");
      a2.setAttribute("autocapitalize", c ? "" : "off");
      a2.setAttribute("spellcheck", !!b);
    }
    function sg() {
      var a2 = v("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"), b = v("div", [a2], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
      fa ? a2.style.width = "1000px" : a2.setAttribute("wrap", "off");
      oc && (a2.style.border = "1px solid black");
      rg(a2);
      return b;
    }
    function oe(a2, b, d2, c, e) {
      function f(u) {
        if ("codepoint" == c) {
          var A = k.text.charCodeAt(b.ch + (0 < d2 ? 0 : -1));
          A = isNaN(A) ? null : new t(b.line, Math.max(0, Math.min(k.text.length, b.ch + d2 * ((0 < d2 ? 55296 <= A && 56320 > A : 56320 <= A && 57343 > A) ? 2 : 1))), -d2);
        } else
          A = e ? kh(a2.cm, k, b, d2) : fe(k, b, d2);
        if (null == A) {
          if (u = !u)
            u = b.line + l, u < a2.first || u >= a2.first + a2.size ? u = false : (b = new t(u, b.ch, b.sticky), u = k = w(a2, u));
          if (u)
            b = ge(e, a2.cm, k, b.line, l);
          else
            return false;
        } else
          b = A;
        return true;
      }
      var g = b, h2 = d2, k = w(a2, b.line), l = e && "rtl" == a2.direction ? -d2 : d2;
      if ("char" == c || "codepoint" == c)
        f();
      else if ("column" == c)
        f(true);
      else if ("word" == c || "group" == c)
        for (var m2 = null, n = "group" == c, p = a2.cm && a2.cm.getHelper(b, "wordChars"), q = true; !(0 > d2) || f(!q); q = false) {
          var r = k.text.charAt(b.ch) || "\n";
          r = xc(r, p) ? "w" : n && "\n" == r ? "n" : !n || /\s/.test(r) ? null : "p";
          !n || q || r || (r = "s");
          if (m2 && m2 != r) {
            0 > d2 && (d2 = 1, f(), b.sticky = "after");
            break;
          }
          r && (m2 = r);
          if (0 < d2 && !f(!q))
            break;
        }
      h2 = Vc(a2, b, g, h2, true);
      rd(g, h2) && (h2.hitSide = true);
      return h2;
    }
    function tg(a2, b, d2, c) {
      var e = a2.doc, f = b.left;
      if ("page" == c) {
        var g = Math.min(a2.display.wrapper.clientHeight, qa(a2).defaultView.innerHeight || e(a2).documentElement.clientHeight);
        g = Math.max(g - 0.5 * vb(a2.display), 3);
        g = (0 < d2 ? b.bottom : b.top) + d2 * g;
      } else
        "line" == c && (g = 0 < d2 ? b.bottom + 3 : b.top - 3);
      for (; ; ) {
        b = Kd(a2, f, g);
        if (!b.outside)
          break;
        if (0 > d2 ? 0 >= g : g >= e.height) {
          b.hitSide = true;
          break;
        }
        g += 5 * d2;
      }
      return b;
    }
    function ug(a2, b) {
      var d2 = Fd(a2, b.line);
      if (!d2 || d2.hidden)
        return null;
      var c = w(a2.doc, b.line);
      d2 = Ue(d2, c, b.line);
      a2 = Ja(c, a2.doc.direction);
      c = "left";
      a2 && (c = Kb(a2, b.ch) % 2 ? "right" : "left");
      b = Ve(d2.map, b.ch, c);
      b.offset = "right" == b.collapse ? b.end : b.start;
      return b;
    }
    function Ah(a2) {
      for (; a2; a2 = a2.parentNode)
        if (/CodeMirror-gutter-wrapper/.test(a2.className))
          return true;
      return false;
    }
    function Ib(a2, b) {
      b && (a2.bad = true);
      return a2;
    }
    function Bh(a2, b, d2, c, e) {
      function f(q) {
        return function(r) {
          return r.id == q;
        };
      }
      function g() {
        m2 && (l += n, p && (l += n), m2 = p = false);
      }
      function h2(q) {
        q && (g(), l += q);
      }
      function k(q) {
        if (1 == q.nodeType) {
          var r = q.getAttribute("cm-text");
          if (r)
            h2(r);
          else {
            r = q.getAttribute("cm-marker");
            var u;
            if (r)
              q = a2.findMarks(t(c, 0), t(e + 1, 0), f(+r)), q.length && (u = q[0].find(0)) && h2(ab(a2.doc, u.from, u.to).join(n));
            else if ("false" != q.getAttribute("contenteditable") && (u = /^(pre|div|p|li|table|br)$/i.test(q.nodeName), /^br$/i.test(q.nodeName) || 0 != q.textContent.length)) {
              u && g();
              for (r = 0; r < q.childNodes.length; r++)
                k(q.childNodes[r]);
              /^(pre|p)$/i.test(q.nodeName) && (p = true);
              u && (m2 = true);
            }
          }
        } else
          3 == q.nodeType && h2(q.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
      for (var l = "", m2 = false, n = a2.doc.lineSeparator(), p = false; ; ) {
        k(b);
        if (b == d2)
          break;
        b = b.nextSibling;
        p = false;
      }
      return l;
    }
    function cd(a2, b, d2) {
      if (b == a2.display.lineDiv) {
        var c = a2.display.lineDiv.childNodes[d2];
        if (!c)
          return Ib(a2.clipPos(t(a2.display.viewTo - 1)), true);
        b = null;
        d2 = 0;
      } else
        for (c = b; ; c = c.parentNode) {
          if (!c || c == a2.display.lineDiv)
            return null;
          if (c.parentNode && c.parentNode == a2.display.lineDiv)
            break;
        }
      for (var e = 0; e < a2.display.view.length; e++) {
        var f = a2.display.view[e];
        if (f.node == c)
          return Ch(f, b, d2);
      }
    }
    function Ch(a2, b, d2) {
      function c(m2, n, p) {
        for (var q = -1; q < (l ? l.length : 0); q++)
          for (var r = 0 > q ? k.map : l[q], u = 0; u < r.length; u += 3) {
            var A = r[u + 2];
            if (A == m2 || A == n) {
              n = N(0 > q ? a2.line : a2.rest[q]);
              q = r[u] + p;
              if (0 > p || A != m2)
                q = r[u + (p ? 1 : 0)];
              return t(n, q);
            }
          }
      }
      var e = a2.text.firstChild, f = false;
      if (!b || !ja(e, b))
        return Ib(t(N(a2.line), 0), true);
      if (b == e && (f = true, b = e.childNodes[d2], d2 = 0, !b))
        return d2 = a2.rest ? J(a2.rest) : a2.line, Ib(t(N(d2), d2.text.length), f);
      var g = 3 == b.nodeType ? b : null, h2 = b;
      g || 1 != b.childNodes.length || 3 != b.firstChild.nodeType || (g = b.firstChild, d2 && (d2 = g.nodeValue.length));
      for (; h2.parentNode != e; )
        h2 = h2.parentNode;
      var k = a2.measure, l = k.maps;
      if (b = c(g, h2, d2))
        return Ib(b, f);
      e = h2.nextSibling;
      for (g = g ? g.nodeValue.length - d2 : 0; e; e = e.nextSibling) {
        if (b = c(e, e.firstChild, 0))
          return Ib(t(b.line, b.ch - g), f);
        g += e.textContent.length;
      }
      for (h2 = h2.previousSibling; h2; h2 = h2.previousSibling) {
        if (b = c(h2, h2.firstChild, -1))
          return Ib(t(b.line, b.ch + d2), f);
        d2 += h2.textContent.length;
      }
    }
    var pa = navigator.userAgent, vg = navigator.platform, Ma = /gecko\/\d/i.test(pa), wg = /MSIE \d/.test(pa), xg = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(pa), dd = /Edge\/(\d+)/.exec(pa), G = wg || xg || dd, T = G && (wg ? document.documentMode || 6 : +(dd || xg)[1]), fa = !dd && /WebKit\//.test(pa), Dh = fa && /Qt\/\d+\.\d+/.test(pa), Qa = !dd && /Chrome\/(\d+)/.exec(pa), tf = Qa && +Qa[1], Ca = /Opera\//.test(pa), ad = /Apple Computer/.test(navigator.vendor), Eh = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(pa), Vg = /PhantomJS/.test(pa), oc = ad && (/Mobile\/\w+/.test(pa) || 2 < navigator.maxTouchPoints), Gc = /Android/.test(pa), ac = oc || Gc || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(pa), ya = oc || /Mac/.test(vg), sh = /\bCrOS\b/.test(pa), Fh = /win/i.test(vg), nb = Ca && pa.match(/Version\/(\d*\.\d*)/);
    nb && (nb = Number(nb[1]));
    nb && 15 <= nb && (Ca = false, fa = true);
    var $f = ya && (Dh || Ca && (null == nb || 12.11 > nb)), je = Ma || G && 9 <= T, jb = function(a2, b) {
      var d2 = a2.className;
      if (b = y2(b).exec(d2)) {
        var c = d2.slice(b.index + b[0].length);
        a2.className = d2.slice(0, b.index) + (c ? b[1] + c : "");
      }
    };
    var Qb = document.createRange ? function(a2, b, d2, c) {
      var e = document.createRange();
      e.setEnd(c || a2, d2);
      e.setStart(a2, b);
      return e;
    } : function(a2, b, d2) {
      var c = document.body.createTextRange();
      try {
        c.moveToElementText(a2.parentNode);
      } catch (e) {
        return c;
      }
      c.collapse(true);
      c.moveEnd("character", d2);
      c.moveStart("character", b);
      return c;
    };
    var pc = function(a2) {
      a2.select();
    };
    oc ? pc = function(a2) {
      a2.selectionStart = 0;
      a2.selectionEnd = a2.value.length;
    } : G && (pc = function(a2) {
      try {
        a2.select();
      } catch (b) {
      }
    });
    var Xa = function() {
      this.f = this.id = null;
      this.time = 0;
      this.handler = gd(this.onTimeout, this);
    };
    Xa.prototype.onTimeout = function(a2) {
      a2.id = 0;
      a2.time <= +/* @__PURE__ */ new Date() ? a2.f() : setTimeout(a2.handler, a2.time - +/* @__PURE__ */ new Date());
    };
    Xa.prototype.set = function(a2, b) {
      this.f = b;
      b = +/* @__PURE__ */ new Date() + a2;
      if (!this.id || b < this.time)
        clearTimeout(this.id), this.id = setTimeout(this.handler, a2), this.time = b;
    };
    var Zc = { toString: function() {
      return "CodeMirror.Pass";
    } }, Ia = { scroll: false }, ke = { origin: "*mouse" }, qc = { origin: "+move" }, vc = [""], zg = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/, Ag = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/, Lb = null, Cg = function() {
      function a2(g, h2, k) {
        this.level = g;
        this.from = h2;
        this.to = k;
      }
      var b = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, d2 = /[stwN]/, c = /[LRr]/, e = /[Lb1n]/, f = /[1n]/;
      return function(g, h2) {
        var k = "ltr" == h2 ? "L" : "R";
        if (0 == g.length || "ltr" == h2 && !b.test(g))
          return false;
        for (var l = g.length, m2 = [], n = 0; n < l; ++n) {
          var p = m2, q = p.push;
          var r = g.charCodeAt(n);
          r = 247 >= r ? "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(r) : 1424 <= r && 1524 >= r ? "R" : 1536 <= r && 1785 >= r ? "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(r - 1536) : 1774 <= r && 2220 >= r ? "r" : 8192 <= r && 8203 >= r ? "w" : 8204 == r ? "b" : "L";
          q.call(p, r);
        }
        n = 0;
        for (p = k; n < l; ++n)
          q = m2[n], "m" == q ? m2[n] = p : p = q;
        n = 0;
        for (p = k; n < l; ++n)
          q = m2[n], "1" == q && "r" == p ? m2[n] = "n" : c.test(q) && (p = q, "r" == q && (m2[n] = "R"));
        n = 1;
        for (p = m2[0]; n < l - 1; ++n)
          q = m2[n], "+" == q && "1" == p && "1" == m2[n + 1] ? m2[n] = "1" : "," != q || p != m2[n + 1] || "1" != p && "n" != p || (m2[n] = p), p = q;
        for (n = 0; n < l; ++n)
          if (p = m2[n], "," == p)
            m2[n] = "N";
          else if ("%" == p) {
            for (p = n + 1; p < l && "%" == m2[p]; ++p)
              ;
            for (q = n && "!" == m2[n - 1] || p < l && "1" == m2[p] ? "1" : "N"; n < p; ++n)
              m2[n] = q;
            n = p - 1;
          }
        n = 0;
        for (p = k; n < l; ++n)
          q = m2[n], "L" == p && "1" == q ? m2[n] = "L" : c.test(q) && (p = q);
        for (p = 0; p < l; ++p)
          if (d2.test(m2[p])) {
            for (n = p + 1; n < l && d2.test(m2[n]); ++n)
              ;
            q = "L" == (p ? m2[p - 1] : k);
            for (q = q == ("L" == (n < l ? m2[n] : k)) ? q ? "L" : "R" : k; p < n; ++p)
              m2[p] = q;
            p = n - 1;
          }
        k = [];
        var u;
        for (n = 0; n < l; )
          if (e.test(m2[n])) {
            p = n;
            for (++n; n < l && e.test(m2[n]); ++n)
              ;
            k.push(new a2(0, p, n));
          } else {
            var A = n;
            p = k.length;
            q = "rtl" == h2 ? 1 : 0;
            for (++n; n < l && "L" != m2[n]; ++n)
              ;
            for (r = A; r < n; )
              if (f.test(m2[r])) {
                A < r && (k.splice(p, 0, new a2(1, A, r)), p += q);
                A = r;
                for (++r; r < n && f.test(m2[r]); ++r)
                  ;
                k.splice(p, 0, new a2(2, A, r));
                p += q;
                A = r;
              } else
                ++r;
            A < n && k.splice(p, 0, new a2(1, A, n));
          }
        "ltr" == h2 && (1 == k[0].level && (u = g.match(/^\s+/)) && (k[0].from = u[0].length, k.unshift(new a2(0, 0, u[0].length))), 1 == J(k).level && (u = g.match(/\s+$/)) && (J(k).to -= u[0].length, k.push(new a2(
          0,
          l - u[0].length,
          l
        ))));
        return "rtl" == h2 ? k.reverse() : k;
      };
    }(), yc = [], z = function(a2, b, d2) {
      a2.addEventListener ? a2.addEventListener(b, d2, false) : a2.attachEvent ? a2.attachEvent("on" + b, d2) : (a2 = a2._handlers || (a2._handlers = {}), a2[b] = (a2[b] || yc).concat(d2));
    }, th = function() {
      if (G && 9 > T)
        return false;
      var a2 = v("div");
      return "draggable" in a2 || "dragDrop" in a2;
    }(), Bd, Ad, ne = 3 != "\n\nb".split(/\n/).length ? function(a2) {
      for (var b = 0, d2 = [], c = a2.length; b <= c; ) {
        var e = a2.indexOf("\n", b);
        -1 == e && (e = a2.length);
        var f = a2.slice(b, "\r" == a2.charAt(e - 1) ? e - 1 : e), g = f.indexOf("\r");
        -1 != g ? (d2.push(f.slice(0, g)), b += g + 1) : (d2.push(f), b = e + 1);
      }
      return d2;
    } : function(a2) {
      return a2.split(/\r\n?|\n/);
    }, Gh = window.getSelection ? function(a2) {
      try {
        return a2.selectionStart != a2.selectionEnd;
      } catch (b) {
        return false;
      }
    } : function(a2) {
      try {
        var b = a2.ownerDocument.selection.createRange();
      } catch (d2) {
      }
      return b && b.parentElement() == a2 ? 0 != b.compareEndPoints("StartToEnd", b) : false;
    }, nh = function() {
      var a2 = v("div");
      if ("oncopy" in a2)
        return true;
      a2.setAttribute("oncopy", "return;");
      return "function" == typeof a2.oncopy;
    }(), Hd = null, md = {}, qb = {}, rb = {}, X = function(a2, b, d2) {
      this.pos = this.start = 0;
      this.string = a2;
      this.tabSize = b || 8;
      this.lineStart = this.lastColumnPos = this.lastColumnValue = 0;
      this.lineOracle = d2;
    };
    X.prototype.eol = function() {
      return this.pos >= this.string.length;
    };
    X.prototype.sol = function() {
      return this.pos == this.lineStart;
    };
    X.prototype.peek = function() {
      return this.string.charAt(this.pos) || void 0;
    };
    X.prototype.next = function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    };
    X.prototype.eat = function(a2) {
      var b = this.string.charAt(this.pos);
      if ("string" == typeof a2 ? b == a2 : b && (a2.test ? a2.test(b) : a2(b)))
        return ++this.pos, b;
    };
    X.prototype.eatWhile = function(a2) {
      for (var b = this.pos; this.eat(a2); )
        ;
      return this.pos > b;
    };
    X.prototype.eatSpace = function() {
      for (var a2 = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
        ++this.pos;
      return this.pos > a2;
    };
    X.prototype.skipToEnd = function() {
      this.pos = this.string.length;
    };
    X.prototype.skipTo = function(a2) {
      a2 = this.string.indexOf(a2, this.pos);
      if (-1 < a2)
        return this.pos = a2, true;
    };
    X.prototype.backUp = function(a2) {
      this.pos -= a2;
    };
    X.prototype.column = function() {
      this.lastColumnPos < this.start && (this.lastColumnValue = wa(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start);
      return this.lastColumnValue - (this.lineStart ? wa(this.string, this.lineStart, this.tabSize) : 0);
    };
    X.prototype.indentation = function() {
      return wa(this.string, null, this.tabSize) - (this.lineStart ? wa(this.string, this.lineStart, this.tabSize) : 0);
    };
    X.prototype.match = function(a2, b, d2) {
      if ("string" == typeof a2) {
        var c = function(f) {
          return d2 ? f.toLowerCase() : f;
        }, e = this.string.substr(this.pos, a2.length);
        if (c(e) == c(a2))
          return false !== b && (this.pos += a2.length), true;
      } else {
        if ((a2 = this.string.slice(this.pos).match(a2)) && 0 < a2.index)
          return null;
        a2 && false !== b && (this.pos += a2[0].length);
        return a2;
      }
    };
    X.prototype.current = function() {
      return this.string.slice(this.start, this.pos);
    };
    X.prototype.hideFirstChars = function(a2, b) {
      this.lineStart += a2;
      try {
        return b();
      } finally {
        this.lineStart -= a2;
      }
    };
    X.prototype.lookAhead = function(a2) {
      var b = this.lineOracle;
      return b && b.lookAhead(a2);
    };
    X.prototype.baseToken = function() {
      var a2 = this.lineOracle;
      return a2 && a2.baseToken(this.pos);
    };
    var Cc = function(a2, b) {
      this.state = a2;
      this.lookAhead = b;
    }, Fa = function(a2, b, d2, c) {
      this.state = b;
      this.doc = a2;
      this.line = d2;
      this.maxLookAhead = c || 0;
      this.baseTokens = null;
      this.baseTokenPos = 1;
    };
    Fa.prototype.lookAhead = function(a2) {
      var b = this.doc.getLine(this.line + a2);
      null != b && a2 > this.maxLookAhead && (this.maxLookAhead = a2);
      return b;
    };
    Fa.prototype.baseToken = function(a2) {
      if (!this.baseTokens)
        return null;
      for (; this.baseTokens[this.baseTokenPos] <= a2; )
        this.baseTokenPos += 2;
      var b = this.baseTokens[this.baseTokenPos + 1];
      return { type: b && b.replace(/( |^)overlay .*/, ""), size: this.baseTokens[this.baseTokenPos] - a2 };
    };
    Fa.prototype.nextLine = function() {
      this.line++;
      0 < this.maxLookAhead && this.maxLookAhead--;
    };
    Fa.fromSaved = function(a2, b, d2) {
      return b instanceof Cc ? new Fa(a2, $a(a2.mode, b.state), d2, b.lookAhead) : new Fa(a2, $a(a2.mode, b), d2);
    };
    Fa.prototype.save = function(a2) {
      a2 = false !== a2 ? $a(this.doc.mode, this.state) : this.state;
      return 0 < this.maxLookAhead ? new Cc(a2, this.maxLookAhead) : a2;
    };
    var De = function(a2, b, d2) {
      this.start = a2.start;
      this.end = a2.pos;
      this.string = a2.current();
      this.type = b || null;
      this.state = d2;
    }, Nf = false, Ka = false, zb = function(a2, b, d2) {
      this.text = a2;
      He(this, b);
      this.height = d2 ? d2(this) : 1;
    };
    zb.prototype.lineNo = function() {
      return N(this);
    };
    pb(zb);
    var Jg = {}, Ig = {}, tb = null, Rb = null, We = { left: 0, right: 0, top: 0, bottom: 0 }, fb, ob = function(a2, b, d2) {
      this.cm = d2;
      var c = this.vert = v("div", [v("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), e = this.horiz = v("div", [v("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
      c.tabIndex = e.tabIndex = -1;
      a2(c);
      a2(e);
      z(
        c,
        "scroll",
        function() {
          c.clientHeight && b(c.scrollTop, "vertical");
        }
      );
      z(e, "scroll", function() {
        e.clientWidth && b(e.scrollLeft, "horizontal");
      });
      this.checkedZeroWidth = false;
      G && 8 > T && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
    };
    ob.prototype.update = function(a2) {
      var b = a2.scrollWidth > a2.clientWidth + 1, d2 = a2.scrollHeight > a2.clientHeight + 1, c = a2.nativeBarWidth;
      d2 ? (this.vert.style.display = "block", this.vert.style.bottom = b ? c + "px" : "0", this.vert.firstChild.style.height = Math.max(0, a2.scrollHeight - a2.clientHeight + (a2.viewHeight - (b ? c : 0))) + "px") : (this.vert.scrollTop = 0, this.vert.style.display = "", this.vert.firstChild.style.height = "0");
      b ? (this.horiz.style.display = "block", this.horiz.style.right = d2 ? c + "px" : "0", this.horiz.style.left = a2.barLeft + "px", this.horiz.firstChild.style.width = Math.max(0, a2.scrollWidth - a2.clientWidth + (a2.viewWidth - a2.barLeft - (d2 ? c : 0))) + "px") : (this.horiz.style.display = "", this.horiz.firstChild.style.width = "0");
      !this.checkedZeroWidth && 0 < a2.clientHeight && (0 == c && this.zeroWidthHack(), this.checkedZeroWidth = true);
      return { right: d2 ? c : 0, bottom: b ? c : 0 };
    };
    ob.prototype.setScrollLeft = function(a2) {
      this.horiz.scrollLeft != a2 && (this.horiz.scrollLeft = a2);
      this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
    };
    ob.prototype.setScrollTop = function(a2) {
      this.vert.scrollTop != a2 && (this.vert.scrollTop = a2);
      this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
    };
    ob.prototype.zeroWidthHack = function() {
      this.horiz.style.height = this.vert.style.width = ya && !Eh ? "12px" : "18px";
      this.horiz.style.visibility = this.vert.style.visibility = "hidden";
      this.disableHoriz = new Xa();
      this.disableVert = new Xa();
    };
    ob.prototype.enableZeroWidthBar = function(a2, b, d2) {
      function c() {
        var e = a2.getBoundingClientRect();
        ("vert" == d2 ? document.elementFromPoint(e.right - 1, (e.top + e.bottom) / 2) : document.elementFromPoint((e.right + e.left) / 2, e.bottom - 1)) != a2 ? a2.style.visibility = "hidden" : b.set(1e3, c);
      }
      a2.style.visibility = "";
      b.set(1e3, c);
    };
    ob.prototype.clear = function() {
      var a2 = this.horiz.parentNode;
      a2.removeChild(this.horiz);
      a2.removeChild(this.vert);
    };
    var rc = function() {
    };
    rc.prototype.update = function() {
      return { bottom: 0, right: 0 };
    };
    rc.prototype.setScrollLeft = function() {
    };
    rc.prototype.setScrollTop = function() {
    };
    rc.prototype.clear = function() {
    };
    var pf = { "native": ob, "null": rc }, Ug = 0, Pc = function(a2, b, d2) {
      var c = a2.display;
      this.viewport = b;
      this.visible = Mc(c, a2.doc, b);
      this.editorIsHidden = !c.wrapper.offsetWidth;
      this.wrapperHeight = c.wrapper.clientHeight;
      this.wrapperWidth = c.wrapper.clientWidth;
      this.oldDisplayWidth = cb(a2);
      this.force = d2;
      this.dims = Gd(a2);
      this.events = [];
    };
    Pc.prototype.signal = function(a2, b) {
      xa(a2, b) && this.events.push(arguments);
    };
    Pc.prototype.finish = function() {
      for (var a2 = 0; a2 < this.events.length; a2++)
        W.apply(null, this.events[a2]);
    };
    var Qc = 0, Na = null;
    G ? Na = -0.53 : Ma ? Na = 15 : Qa ? Na = -0.7 : ad && (Na = -1 / 3);
    var va = function(a2, b) {
      this.ranges = a2;
      this.primIndex = b;
    };
    va.prototype.primary = function() {
      return this.ranges[this.primIndex];
    };
    va.prototype.equals = function(a2) {
      if (a2 == this)
        return true;
      if (a2.primIndex != this.primIndex || a2.ranges.length != this.ranges.length)
        return false;
      for (var b = 0; b < this.ranges.length; b++) {
        var d2 = this.ranges[b], c = a2.ranges[b];
        if (!rd(d2.anchor, c.anchor) || !rd(d2.head, c.head))
          return false;
      }
      return true;
    };
    va.prototype.deepCopy = function() {
      for (var a2 = [], b = 0; b < this.ranges.length; b++)
        a2[b] = new I(sd(this.ranges[b].anchor), sd(this.ranges[b].head));
      return new va(a2, this.primIndex);
    };
    va.prototype.somethingSelected = function() {
      for (var a2 = 0; a2 < this.ranges.length; a2++)
        if (!this.ranges[a2].empty())
          return true;
      return false;
    };
    va.prototype.contains = function(a2, b) {
      b || (b = a2);
      for (var d2 = 0; d2 < this.ranges.length; d2++) {
        var c = this.ranges[d2];
        if (0 <= B(b, c.from()) && 0 >= B(a2, c.to()))
          return d2;
      }
      return -1;
    };
    var I = function(a2, b) {
      this.anchor = a2;
      this.head = b;
    };
    I.prototype.from = function() {
      return Bc(this.anchor, this.head);
    };
    I.prototype.to = function() {
      return Ac(this.anchor, this.head);
    };
    I.prototype.empty = function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    };
    ec.prototype = { chunkSize: function() {
      return this.lines.length;
    }, removeInner: function(a2, b) {
      for (var d2 = a2, c = a2 + b; d2 < c; ++d2) {
        var e = this.lines[d2];
        this.height -= e.height;
        var f = e;
        f.parent = null;
        Ge(f);
        aa(e, "delete");
      }
      this.lines.splice(a2, b);
    }, collapse: function(a2) {
      a2.push.apply(
        a2,
        this.lines
      );
    }, insertInner: function(a2, b, d2) {
      this.height += d2;
      this.lines = this.lines.slice(0, a2).concat(b).concat(this.lines.slice(a2));
      for (a2 = 0; a2 < b.length; ++a2)
        b[a2].parent = this;
    }, iterN: function(a2, b, d2) {
      for (b = a2 + b; a2 < b; ++a2)
        if (d2(this.lines[a2]))
          return true;
    } };
    fc.prototype = { chunkSize: function() {
      return this.size;
    }, removeInner: function(a2, b) {
      this.size -= b;
      for (var d2 = 0; d2 < this.children.length; ++d2) {
        var c = this.children[d2], e = c.chunkSize();
        if (a2 < e) {
          var f = Math.min(b, e - a2), g = c.height;
          c.removeInner(a2, f);
          this.height -= g - c.height;
          e == f && (this.children.splice(
            d2--,
            1
          ), c.parent = null);
          if (0 == (b -= f))
            break;
          a2 = 0;
        } else
          a2 -= e;
      }
      25 > this.size - b && (1 < this.children.length || !(this.children[0] instanceof ec)) && (a2 = [], this.collapse(a2), this.children = [new ec(a2)], this.children[0].parent = this);
    }, collapse: function(a2) {
      for (var b = 0; b < this.children.length; ++b)
        this.children[b].collapse(a2);
    }, insertInner: function(a2, b, d2) {
      this.size += b.length;
      this.height += d2;
      for (var c = 0; c < this.children.length; ++c) {
        var e = this.children[c], f = e.chunkSize();
        if (a2 <= f) {
          e.insertInner(a2, b, d2);
          if (e.lines && 50 < e.lines.length) {
            for (b = a2 = e.lines.length % 25 + 25; b < e.lines.length; )
              d2 = new ec(e.lines.slice(b, b += 25)), e.height -= d2.height, this.children.splice(++c, 0, d2), d2.parent = this;
            e.lines = e.lines.slice(0, a2);
            this.maybeSpill();
          }
          break;
        }
        a2 -= f;
      }
    }, maybeSpill: function() {
      if (!(10 >= this.children.length)) {
        var a2 = this;
        do {
          var b = a2.children.splice(a2.children.length - 5, 5);
          b = new fc(b);
          if (a2.parent) {
            a2.size -= b.size;
            a2.height -= b.height;
            var d2 = ea(a2.parent.children, a2);
            a2.parent.children.splice(d2 + 1, 0, b);
          } else
            d2 = new fc(a2.children), d2.parent = a2, a2.children = [d2, b], a2 = d2;
          b.parent = a2.parent;
        } while (10 < a2.children.length);
        a2.parent.maybeSpill();
      }
    }, iterN: function(a2, b, d2) {
      for (var c = 0; c < this.children.length; ++c) {
        var e = this.children[c], f = e.chunkSize();
        if (a2 < f) {
          f = Math.min(b, f - a2);
          if (e.iterN(a2, f, d2))
            return true;
          if (0 == (b -= f))
            break;
          a2 = 0;
        } else
          a2 -= f;
      }
    } };
    var gc = function(a2, b, d2) {
      if (d2)
        for (var c in d2)
          d2.hasOwnProperty(c) && (this[c] = d2[c]);
      this.doc = a2;
      this.node = b;
    };
    gc.prototype.clear = function() {
      var a2 = this.doc.cm, b = this.line.widgets, d2 = this.line, c = N(d2);
      if (null != c && b) {
        for (var e = 0; e < b.length; ++e)
          b[e] == this && b.splice(e--, 1);
        b.length || (d2.widgets = null);
        var f = Tb(this);
        Ea(d2, Math.max(0, d2.height - f));
        a2 && (ra(a2, function() {
          var g = -f;
          Ga(d2) < (a2.curOp && a2.curOp.scrollTop || a2.doc.scrollTop) && Nc(a2, g);
          Sa(a2, c, "widget");
        }), aa(a2, "lineWidgetCleared", a2, this, c));
      }
    };
    gc.prototype.changed = function() {
      var a2 = this, b = this.height, d2 = this.doc.cm, c = this.line;
      this.height = null;
      var e = Tb(this) - b;
      e && (Pa(this.doc, c) || Ea(c, c.height + e), d2 && ra(d2, function() {
        d2.curOp.forceUpdate = true;
        Ga(c) < (d2.curOp && d2.curOp.scrollTop || d2.doc.scrollTop) && Nc(d2, e);
        aa(d2, "lineWidgetChanged", d2, a2, N(c));
      }));
    };
    pb(gc);
    var Tf = 0, Va = function(a2, b) {
      this.lines = [];
      this.type = b;
      this.doc = a2;
      this.id = ++Tf;
    };
    Va.prototype.clear = function() {
      if (!this.explicitlyCleared) {
        var a2 = this.doc.cm, b = a2 && !a2.curOp;
        b && lb(a2);
        if (xa(this, "clear")) {
          var d2 = this.find();
          d2 && aa(this, "clear", d2.from, d2.to);
        }
        for (var c = d2 = null, e = 0; e < this.lines.length; ++e) {
          var f = this.lines[e], g = Pb(f.markedSpans, this);
          a2 && !this.collapsed ? Sa(a2, N(f), "text") : a2 && (null != g.to && (c = N(f)), null != g.from && (d2 = N(f)));
          for (var h2 = f, k = void 0, l = f.markedSpans, m2 = g, n = 0; n < l.length; ++n)
            l[n] != m2 && (k || (k = [])).push(l[n]);
          h2.markedSpans = k;
          null == g.from && this.collapsed && !Pa(this.doc, f) && a2 && Ea(f, vb(a2.display));
        }
        if (a2 && this.collapsed && !a2.options.lineWrapping)
          for (e = 0; e < this.lines.length; ++e)
            f = za(this.lines[e]), g = Ec(f), g > a2.display.maxLineLength && (a2.display.maxLine = f, a2.display.maxLineLength = g, a2.display.maxLineChanged = true);
        null != d2 && a2 && this.collapsed && ma(a2, d2, c + 1);
        this.lines.length = 0;
        this.explicitlyCleared = true;
        this.atomic && this.doc.cantEdit && (this.doc.cantEdit = false, a2 && Jf(a2.doc));
        a2 && aa(
          a2,
          "markerCleared",
          a2,
          this,
          d2,
          c
        );
        b && mb(a2);
        this.parent && this.parent.clear();
      }
    };
    Va.prototype.find = function(a2, b) {
      null == a2 && "bookmark" == this.type && (a2 = 1);
      for (var d2, c, e = 0; e < this.lines.length; ++e) {
        var f = this.lines[e], g = Pb(f.markedSpans, this);
        if (null != g.from && (d2 = t(b ? f : N(f), g.from), -1 == a2))
          return d2;
        if (null != g.to && (c = t(b ? f : N(f), g.to), 1 == a2))
          return c;
      }
      return d2 && { from: d2, to: c };
    };
    Va.prototype.changed = function() {
      var a2 = this, b = this.find(-1, true), d2 = this, c = this.doc.cm;
      b && c && ra(c, function() {
        var e = b.line, f = N(b.line);
        if (f = Fd(c, f))
          Xe(f), c.curOp.selectionChanged = c.curOp.forceUpdate = true;
        c.curOp.updateMaxLine = true;
        Pa(d2.doc, e) || null == d2.height || (f = d2.height, d2.height = null, (f = Tb(d2) - f) && Ea(e, e.height + f));
        aa(c, "markerChanged", c, a2);
      });
    };
    Va.prototype.attachLine = function(a2) {
      if (!this.lines.length && this.doc.cm) {
        var b = this.doc.cm.curOp;
        b.maybeHiddenMarkers && -1 != ea(b.maybeHiddenMarkers, this) || (b.maybeUnhiddenMarkers || (b.maybeUnhiddenMarkers = [])).push(this);
      }
      this.lines.push(a2);
    };
    Va.prototype.detachLine = function(a2) {
      this.lines.splice(ea(this.lines, a2), 1);
      !this.lines.length && this.doc.cm && (a2 = this.doc.cm.curOp, (a2.maybeHiddenMarkers || (a2.maybeHiddenMarkers = [])).push(this));
    };
    pb(Va);
    var hc = function(a2, b) {
      this.markers = a2;
      this.primary = b;
      for (b = 0; b < a2.length; ++b)
        a2[b].parent = this;
    };
    hc.prototype.clear = function() {
      if (!this.explicitlyCleared) {
        this.explicitlyCleared = true;
        for (var a2 = 0; a2 < this.markers.length; ++a2)
          this.markers[a2].clear();
        aa(this, "clear");
      }
    };
    hc.prototype.find = function(a2, b) {
      return this.primary.find(a2, b);
    };
    pb(hc);
    var Hh = 0, oa = function(a2, b, d2, c, e) {
      if (!(this instanceof oa))
        return new oa(a2, b, d2, c, e);
      null == d2 && (d2 = 0);
      fc.call(this, [new ec([new zb("", null)])]);
      this.first = d2;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.cleanGeneration = 1;
      this.modeFrontier = this.highlightFrontier = d2;
      d2 = t(d2, 0);
      this.sel = Oa(d2);
      this.history = new Rc(null);
      this.id = ++Hh;
      this.modeOption = b;
      this.lineSep = c;
      this.direction = "rtl" == e ? "rtl" : "ltr";
      this.extend = false;
      "string" == typeof a2 && (a2 = this.splitLines(a2));
      ae(this, { from: d2, to: d2, text: a2 });
      da(this, Oa(d2), Ia);
    };
    oa.prototype = qe(fc.prototype, {
      constructor: oa,
      iter: function(a2, b, d2) {
        d2 ? this.iterN(
          a2 - this.first,
          b - a2,
          d2
        ) : this.iterN(this.first, this.first + this.size, a2);
      },
      insert: function(a2, b) {
        for (var d2 = 0, c = 0; c < b.length; ++c)
          d2 += b[c].height;
        this.insertInner(a2 - this.first, b, d2);
      },
      remove: function(a2, b) {
        this.removeInner(a2 - this.first, b);
      },
      getValue: function(a2) {
        var b = pd(this, this.first, this.first + this.size);
        return false === a2 ? b : b.join(a2 || this.lineSeparator());
      },
      setValue: ca(function(a2) {
        var b = t(this.first, 0), d2 = this.first + this.size - 1;
        Cb(this, { from: b, to: t(d2, w(this, d2).text.length), text: this.splitLines(a2), origin: "setValue", full: true }, true);
        this.cm && Wb(this.cm, 0, 0);
        da(this, Oa(b), Ia);
      }),
      replaceRange: function(a2, b, d2, c) {
        b = C(this, b);
        d2 = d2 ? C(this, d2) : b;
        Db(this, a2, b, d2, c);
      },
      getRange: function(a2, b, d2) {
        a2 = ab(this, C(this, a2), C(this, b));
        return false === d2 ? a2 : "" === d2 ? a2.join("") : a2.join(d2 || this.lineSeparator());
      },
      getLine: function(a2) {
        return (a2 = this.getLineHandle(a2)) && a2.text;
      },
      getLineHandle: function(a2) {
        if (Nb(this, a2))
          return w(this, a2);
      },
      getLineNumber: function(a2) {
        return N(a2);
      },
      getLineHandleVisualStart: function(a2) {
        "number" == typeof a2 && (a2 = w(this, a2));
        return za(a2);
      },
      lineCount: function() {
        return this.size;
      },
      firstLine: function() {
        return this.first;
      },
      lastLine: function() {
        return this.first + this.size - 1;
      },
      clipPos: function(a2) {
        return C(this, a2);
      },
      getCursor: function(a2) {
        var b = this.sel.primary();
        return null == a2 || "head" == a2 ? b.head : "anchor" == a2 ? b.anchor : "end" == a2 || "to" == a2 || false === a2 ? b.to() : b.from();
      },
      listSelections: function() {
        return this.sel.ranges;
      },
      somethingSelected: function() {
        return this.sel.somethingSelected();
      },
      setCursor: ca(function(a2, b, d2) {
        a2 = C(this, "number" == typeof a2 ? t(a2, b || 0) : a2);
        da(this, Oa(a2, null), d2);
      }),
      setSelection: ca(function(a2, b, d2) {
        var c = C(this, a2);
        a2 = C(this, b || a2);
        da(this, Oa(c, a2), d2);
      }),
      extendSelection: ca(function(a2, b, d2) {
        Tc(this, C(this, a2), b && C(this, b), d2);
      }),
      extendSelections: ca(function(a2, b) {
        Ff(this, xe(this, a2), b);
      }),
      extendSelectionsBy: ca(function(a2, b) {
        a2 = wc(this.sel.ranges, a2);
        Ff(this, xe(this, a2), b);
      }),
      setSelections: ca(function(a2, b, d2) {
        if (a2.length) {
          for (var c = [], e = 0; e < a2.length; e++)
            c[e] = new I(C(this, a2[e].anchor), C(this, a2[e].head || a2[e].anchor));
          null == b && (b = Math.min(a2.length - 1, this.sel.primIndex));
          da(this, Da(this.cm, c, b), d2);
        }
      }),
      addSelection: ca(function(a2, b, d2) {
        var c = this.sel.ranges.slice(0);
        c.push(new I(C(this, a2), C(this, b || a2)));
        da(this, Da(this.cm, c, c.length - 1), d2);
      }),
      getSelection: function(a2) {
        for (var b = this.sel.ranges, d2, c = 0; c < b.length; c++) {
          var e = ab(this, b[c].from(), b[c].to());
          d2 = d2 ? d2.concat(e) : e;
        }
        return false === a2 ? d2 : d2.join(a2 || this.lineSeparator());
      },
      getSelections: function(a2) {
        for (var b = [], d2 = this.sel.ranges, c = 0; c < d2.length; c++) {
          var e = ab(this, d2[c].from(), d2[c].to());
          false !== a2 && (e = e.join(a2 || this.lineSeparator()));
          b[c] = e;
        }
        return b;
      },
      replaceSelection: function(a2, b, d2) {
        for (var c = [], e = 0; e < this.sel.ranges.length; e++)
          c[e] = a2;
        this.replaceSelections(c, b, d2 || "+input");
      },
      replaceSelections: ca(function(a2, b, d2) {
        for (var c = [], e = this.sel, f = 0; f < e.ranges.length; f++) {
          var g = e.ranges[f];
          c[f] = { from: g.from(), to: g.to(), text: this.splitLines(a2[f]), origin: d2 };
        }
        if (a2 = b && "end" != b) {
          a2 = [];
          e = d2 = t(this.first, 0);
          for (f = 0; f < c.length; f++) {
            var h2 = c[f];
            g = xf(h2.from, d2, e);
            var k = xf(Ta(h2), d2, e);
            d2 = h2.to;
            e = k;
            "around" == b ? (h2 = this.sel.ranges[f], h2 = 0 > B(h2.head, h2.anchor), a2[f] = new I(h2 ? k : g, h2 ? g : k)) : a2[f] = new I(g, g);
          }
          a2 = new va(a2, this.sel.primIndex);
        }
        b = a2;
        for (a2 = c.length - 1; 0 <= a2; a2--)
          Cb(this, c[a2]);
        b ? Gf(this, b) : this.cm && xb(this.cm);
      }),
      undo: ca(function() {
        Wc(this, "undo");
      }),
      redo: ca(function() {
        Wc(this, "redo");
      }),
      undoSelection: ca(function() {
        Wc(this, "undo", true);
      }),
      redoSelection: ca(function() {
        Wc(this, "redo", true);
      }),
      setExtending: function(a2) {
        this.extend = a2;
      },
      getExtending: function() {
        return this.extend;
      },
      historySize: function() {
        for (var a2 = this.history, b = 0, d2 = 0, c = 0; c < a2.done.length; c++)
          a2.done[c].ranges || ++b;
        for (c = 0; c < a2.undone.length; c++)
          a2.undone[c].ranges || ++d2;
        return {
          undo: b,
          redo: d2
        };
      },
      clearHistory: function() {
        var a2 = this;
        this.history = new Rc(this.history);
        Ua(this, function(b) {
          return b.history = a2.history;
        }, true);
      },
      markClean: function() {
        this.cleanGeneration = this.changeGeneration(true);
      },
      changeGeneration: function(a2) {
        a2 && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null);
        return this.history.generation;
      },
      isClean: function(a2) {
        return this.history.generation == (a2 || this.cleanGeneration);
      },
      getHistory: function() {
        return { done: Ab(this.history.done), undone: Ab(this.history.undone) };
      },
      setHistory: function(a2) {
        var b = this.history = new Rc(this.history);
        b.done = Ab(a2.done.slice(0), null, true);
        b.undone = Ab(a2.undone.slice(0), null, true);
      },
      setGutterMarker: ca(function(a2, b, d2) {
        return dc(this, a2, "gutter", function(c) {
          var e = c.gutterMarkers || (c.gutterMarkers = {});
          e[b] = d2;
          !d2 && re2(e) && (c.gutterMarkers = null);
          return true;
        });
      }),
      clearGutter: ca(function(a2) {
        var b = this;
        this.iter(function(d2) {
          d2.gutterMarkers && d2.gutterMarkers[a2] && dc(b, d2, "gutter", function() {
            d2.gutterMarkers[a2] = null;
            re2(d2.gutterMarkers) && (d2.gutterMarkers = null);
            return true;
          });
        });
      }),
      lineInfo: function(a2) {
        if ("number" == typeof a2) {
          if (!Nb(this, a2))
            return null;
          var b = a2;
          a2 = w(this, a2);
          if (!a2)
            return null;
        } else if (b = N(a2), null == b)
          return null;
        return { line: b, handle: a2, text: a2.text, gutterMarkers: a2.gutterMarkers, textClass: a2.textClass, bgClass: a2.bgClass, wrapClass: a2.wrapClass, widgets: a2.widgets };
      },
      addLineClass: ca(function(a2, b, d2) {
        return dc(this, a2, "gutter" == b ? "gutter" : "class", function(c) {
          var e = "text" == b ? "textClass" : "background" == b ? "bgClass" : "gutter" == b ? "gutterClass" : "wrapClass";
          if (c[e]) {
            if (y2(d2).test(c[e]))
              return false;
            c[e] += " " + d2;
          } else
            c[e] = d2;
          return true;
        });
      }),
      removeLineClass: ca(function(a2, b, d2) {
        return dc(this, a2, "gutter" == b ? "gutter" : "class", function(c) {
          var e = "text" == b ? "textClass" : "background" == b ? "bgClass" : "gutter" == b ? "gutterClass" : "wrapClass", f = c[e];
          if (f)
            if (null == d2)
              c[e] = null;
            else {
              var g = f.match(y2(d2));
              if (!g)
                return false;
              var h2 = g.index + g[0].length;
              c[e] = f.slice(0, g.index) + (g.index && h2 != f.length ? " " : "") + f.slice(h2) || null;
            }
          else
            return false;
          return true;
        });
      }),
      addLineWidget: ca(function(a2, b, d2) {
        return ch(this, a2, b, d2);
      }),
      removeLineWidget: function(a2) {
        a2.clear();
      },
      markText: function(a2, b, d2) {
        return Eb(this, C(this, a2), C(this, b), d2, d2 && d2.type || "range");
      },
      setBookmark: function(a2, b) {
        b = { replacedWith: b && (null == b.nodeType ? b.widget : b), insertLeft: b && b.insertLeft, clearWhenEmpty: false, shared: b && b.shared, handleMouseEvents: b && b.handleMouseEvents };
        a2 = C(this, a2);
        return Eb(this, a2, a2, b, "bookmark");
      },
      findMarksAt: function(a2) {
        a2 = C(this, a2);
        var b = [], d2 = w(this, a2.line).markedSpans;
        if (d2)
          for (var c = 0; c < d2.length; ++c) {
            var e = d2[c];
            (null == e.from || e.from <= a2.ch) && (null == e.to || e.to >= a2.ch) && b.push(e.marker.parent || e.marker);
          }
        return b;
      },
      findMarks: function(a2, b, d2) {
        a2 = C(this, a2);
        b = C(this, b);
        var c = [], e = a2.line;
        this.iter(a2.line, b.line + 1, function(f) {
          if (f = f.markedSpans)
            for (var g = 0; g < f.length; g++) {
              var h2 = f[g];
              null != h2.to && e == a2.line && a2.ch >= h2.to || null == h2.from && e != a2.line || null != h2.from && e == b.line && h2.from >= b.ch || d2 && !d2(h2.marker) || c.push(h2.marker.parent || h2.marker);
            }
          ++e;
        });
        return c;
      },
      getAllMarks: function() {
        var a2 = [];
        this.iter(function(b) {
          if (b = b.markedSpans)
            for (var d2 = 0; d2 < b.length; ++d2)
              null != b[d2].from && a2.push(b[d2].marker);
        });
        return a2;
      },
      posFromIndex: function(a2) {
        var b, d2 = this.first, c = this.lineSeparator().length;
        this.iter(function(e) {
          e = e.text.length + c;
          if (e > a2)
            return b = a2, true;
          a2 -= e;
          ++d2;
        });
        return C(this, t(d2, b));
      },
      indexFromPos: function(a2) {
        a2 = C(this, a2);
        var b = a2.ch;
        if (a2.line < this.first || 0 > a2.ch)
          return 0;
        var d2 = this.lineSeparator().length;
        this.iter(this.first, a2.line, function(c) {
          b += c.text.length + d2;
        });
        return b;
      },
      copy: function(a2) {
        var b = new oa(pd(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
        b.scrollTop = this.scrollTop;
        b.scrollLeft = this.scrollLeft;
        b.sel = this.sel;
        b.extend = false;
        a2 && (b.history.undoDepth = this.history.undoDepth, b.setHistory(this.getHistory()));
        return b;
      },
      linkedDoc: function(a2) {
        a2 || (a2 = {});
        var b = this.first, d2 = this.first + this.size;
        null != a2.from && a2.from > b && (b = a2.from);
        null != a2.to && a2.to < d2 && (d2 = a2.to);
        b = new oa(pd(this, b, d2), a2.mode || this.modeOption, b, this.lineSep, this.direction);
        a2.sharedHist && (b.history = this.history);
        (this.linked || (this.linked = [])).push({ doc: b, sharedHist: a2.sharedHist });
        b.linked = [{ doc: this, isParent: true, sharedHist: a2.sharedHist }];
        a2 = Uf(this);
        for (d2 = 0; d2 < a2.length; d2++) {
          var c = a2[d2], e = c.find(), f = b.clipPos(e.from);
          e = b.clipPos(e.to);
          B(f, e) && (f = Eb(b, f, e, c.primary, c.primary.type), c.markers.push(f), f.parent = c);
        }
        return b;
      },
      unlinkDoc: function(a2) {
        a2 instanceof U && (a2 = a2.doc);
        if (this.linked) {
          for (var b = 0; b < this.linked.length; ++b)
            if (this.linked[b].doc == a2) {
              this.linked.splice(b, 1);
              a2.unlinkDoc(this);
              eh(Uf(this));
              break;
            }
        }
        if (a2.history == this.history) {
          var d2 = [a2.id];
          Ua(a2, function(c) {
            return d2.push(c.id);
          }, true);
          a2.history = new Rc(null);
          a2.history.done = Ab(this.history.done, d2);
          a2.history.undone = Ab(this.history.undone, d2);
        }
      },
      iterLinkedDocs: function(a2) {
        Ua(this, a2);
      },
      getMode: function() {
        return this.mode;
      },
      getEditor: function() {
        return this.cm;
      },
      splitLines: function(a2) {
        return this.lineSep ? a2.split(this.lineSep) : ne(a2);
      },
      lineSeparator: function() {
        return this.lineSep || "\n";
      },
      setDirection: ca(function(a2) {
        "rtl" != a2 && (a2 = "ltr");
        a2 != this.direction && (this.direction = a2, this.iter(function(b) {
          return b.order = null;
        }), this.cm && $g(this.cm));
      })
    });
    oa.prototype.eachLine = oa.prototype.iter;
    for (var Wf = 0, ng = false, Wa = {
      3: "Pause",
      8: "Backspace",
      9: "Tab",
      13: "Enter",
      16: "Shift",
      17: "Ctrl",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Esc",
      32: "Space",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "Left",
      38: "Up",
      39: "Right",
      40: "Down",
      44: "PrintScrn",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Mod",
      92: "Mod",
      93: "Mod",
      106: "*",
      107: "=",
      109: "-",
      110: ".",
      111: "/",
      145: "ScrollLock",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      224: "Mod",
      63232: "Up",
      63233: "Down",
      63234: "Left",
      63235: "Right",
      63272: "Delete",
      63273: "Home",
      63275: "End",
      63276: "PageUp",
      63277: "PageDown",
      63302: "Insert"
    }, sc = 0; 10 > sc; sc++)
      Wa[sc + 48] = Wa[sc + 96] = String(sc);
    for (var ed = 65; 90 >= ed; ed++)
      Wa[ed] = String.fromCharCode(ed);
    for (var tc = 1; 12 >= tc; tc++)
      Wa[tc + 111] = Wa[tc + 63235] = "F" + tc;
    var ic = { basic: {
      Left: "goCharLeft",
      Right: "goCharRight",
      Up: "goLineUp",
      Down: "goLineDown",
      End: "goLineEnd",
      Home: "goLineStartSmart",
      PageUp: "goPageUp",
      PageDown: "goPageDown",
      Delete: "delCharAfter",
      Backspace: "delCharBefore",
      "Shift-Backspace": "delCharBefore",
      Tab: "defaultTab",
      "Shift-Tab": "indentAuto",
      Enter: "newlineAndIndent",
      Insert: "toggleOverwrite",
      Esc: "singleSelection"
    }, pcDefault: {
      "Ctrl-A": "selectAll",
      "Ctrl-D": "deleteLine",
      "Ctrl-Z": "undo",
      "Shift-Ctrl-Z": "redo",
      "Ctrl-Y": "redo",
      "Ctrl-Home": "goDocStart",
      "Ctrl-End": "goDocEnd",
      "Ctrl-Up": "goLineUp",
      "Ctrl-Down": "goLineDown",
      "Ctrl-Left": "goGroupLeft",
      "Ctrl-Right": "goGroupRight",
      "Alt-Left": "goLineStart",
      "Alt-Right": "goLineEnd",
      "Ctrl-Backspace": "delGroupBefore",
      "Ctrl-Delete": "delGroupAfter",
      "Ctrl-S": "save",
      "Ctrl-F": "find",
      "Ctrl-G": "findNext",
      "Shift-Ctrl-G": "findPrev",
      "Shift-Ctrl-F": "replace",
      "Shift-Ctrl-R": "replaceAll",
      "Ctrl-[": "indentLess",
      "Ctrl-]": "indentMore",
      "Ctrl-U": "undoSelection",
      "Shift-Ctrl-U": "redoSelection",
      "Alt-U": "redoSelection",
      fallthrough: "basic"
    }, emacsy: {
      "Ctrl-F": "goCharRight",
      "Ctrl-B": "goCharLeft",
      "Ctrl-P": "goLineUp",
      "Ctrl-N": "goLineDown",
      "Ctrl-A": "goLineStart",
      "Ctrl-E": "goLineEnd",
      "Ctrl-V": "goPageDown",
      "Shift-Ctrl-V": "goPageUp",
      "Ctrl-D": "delCharAfter",
      "Ctrl-H": "delCharBefore",
      "Alt-Backspace": "delWordBefore",
      "Ctrl-K": "killLine",
      "Ctrl-T": "transposeChars",
      "Ctrl-O": "openLine"
    }, macDefault: {
      "Cmd-A": "selectAll",
      "Cmd-D": "deleteLine",
      "Cmd-Z": "undo",
      "Shift-Cmd-Z": "redo",
      "Cmd-Y": "redo",
      "Cmd-Home": "goDocStart",
      "Cmd-Up": "goDocStart",
      "Cmd-End": "goDocEnd",
      "Cmd-Down": "goDocEnd",
      "Alt-Left": "goGroupLeft",
      "Alt-Right": "goGroupRight",
      "Cmd-Left": "goLineLeft",
      "Cmd-Right": "goLineRight",
      "Alt-Backspace": "delGroupBefore",
      "Ctrl-Alt-Backspace": "delGroupAfter",
      "Alt-Delete": "delGroupAfter",
      "Cmd-S": "save",
      "Cmd-F": "find",
      "Cmd-G": "findNext",
      "Shift-Cmd-G": "findPrev",
      "Cmd-Alt-F": "replace",
      "Shift-Cmd-Alt-F": "replaceAll",
      "Cmd-[": "indentLess",
      "Cmd-]": "indentMore",
      "Cmd-Backspace": "delWrappedLineLeft",
      "Cmd-Delete": "delWrappedLineRight",
      "Cmd-U": "undoSelection",
      "Shift-Cmd-U": "redoSelection",
      "Ctrl-Up": "goDocStart",
      "Ctrl-Down": "goDocEnd",
      fallthrough: ["basic", "emacsy"]
    } };
    ic["default"] = ya ? ic.macDefault : ic.pcDefault;
    var jc = {
      selectAll: Lf,
      singleSelection: function(a2) {
        return a2.setSelection(a2.getCursor("anchor"), a2.getCursor("head"), Ia);
      },
      killLine: function(a2) {
        return Gb(a2, function(b) {
          if (b.empty()) {
            var d2 = w(a2.doc, b.head.line).text.length;
            return b.head.ch == d2 && b.head.line < a2.lastLine() ? { from: b.head, to: t(b.head.line + 1, 0) } : { from: b.head, to: t(b.head.line, d2) };
          }
          return { from: b.from(), to: b.to() };
        });
      },
      deleteLine: function(a2) {
        return Gb(a2, function(b) {
          return { from: t(b.from().line, 0), to: C(a2.doc, t(b.to().line + 1, 0)) };
        });
      },
      delLineLeft: function(a2) {
        return Gb(a2, function(b) {
          return { from: t(b.from().line, 0), to: b.from() };
        });
      },
      delWrappedLineLeft: function(a2) {
        return Gb(a2, function(b) {
          var d2 = a2.charCoords(b.head, "div").top + 5;
          return { from: a2.coordsChar({
            left: 0,
            top: d2
          }, "div"), to: b.from() };
        });
      },
      delWrappedLineRight: function(a2) {
        return Gb(a2, function(b) {
          var d2 = a2.charCoords(b.head, "div").top + 5;
          d2 = a2.coordsChar({ left: a2.display.lineDiv.offsetWidth + 100, top: d2 }, "div");
          return { from: b.from(), to: d2 };
        });
      },
      undo: function(a2) {
        return a2.undo();
      },
      redo: function(a2) {
        return a2.redo();
      },
      undoSelection: function(a2) {
        return a2.undoSelection();
      },
      redoSelection: function(a2) {
        return a2.redoSelection();
      },
      goDocStart: function(a2) {
        return a2.extendSelection(t(a2.firstLine(), 0));
      },
      goDocEnd: function(a2) {
        return a2.extendSelection(t(a2.lastLine()));
      },
      goLineStart: function(a2) {
        return a2.extendSelectionsBy(function(b) {
          return bg(a2, b.head.line);
        }, { origin: "+move", bias: 1 });
      },
      goLineStartSmart: function(a2) {
        return a2.extendSelectionsBy(function(b) {
          return cg(a2, b.head);
        }, { origin: "+move", bias: 1 });
      },
      goLineEnd: function(a2) {
        return a2.extendSelectionsBy(function(b) {
          b = b.head.line;
          var d2 = w(a2.doc, b);
          var c = d2;
          for (var e; e = sb(c, false); )
            c = e.find(1, true).line;
          c != d2 && (b = N(c));
          return ge(true, a2, d2, b, -1);
        }, { origin: "+move", bias: -1 });
      },
      goLineRight: function(a2) {
        return a2.extendSelectionsBy(function(b) {
          b = a2.cursorCoords(b.head, "div").top + 5;
          return a2.coordsChar({ left: a2.display.lineDiv.offsetWidth + 100, top: b }, "div");
        }, qc);
      },
      goLineLeft: function(a2) {
        return a2.extendSelectionsBy(function(b) {
          b = a2.cursorCoords(b.head, "div").top + 5;
          return a2.coordsChar({ left: 0, top: b }, "div");
        }, qc);
      },
      goLineLeftSmart: function(a2) {
        return a2.extendSelectionsBy(function(b) {
          var d2 = a2.cursorCoords(b.head, "div").top + 5;
          d2 = a2.coordsChar({ left: 0, top: d2 }, "div");
          return d2.ch < a2.getLine(d2.line).search(/\S/) ? cg(a2, b.head) : d2;
        }, qc);
      },
      goLineUp: function(a2) {
        return a2.moveV(
          -1,
          "line"
        );
      },
      goLineDown: function(a2) {
        return a2.moveV(1, "line");
      },
      goPageUp: function(a2) {
        return a2.moveV(-1, "page");
      },
      goPageDown: function(a2) {
        return a2.moveV(1, "page");
      },
      goCharLeft: function(a2) {
        return a2.moveH(-1, "char");
      },
      goCharRight: function(a2) {
        return a2.moveH(1, "char");
      },
      goColumnLeft: function(a2) {
        return a2.moveH(-1, "column");
      },
      goColumnRight: function(a2) {
        return a2.moveH(1, "column");
      },
      goWordLeft: function(a2) {
        return a2.moveH(-1, "word");
      },
      goGroupRight: function(a2) {
        return a2.moveH(1, "group");
      },
      goGroupLeft: function(a2) {
        return a2.moveH(
          -1,
          "group"
        );
      },
      goWordRight: function(a2) {
        return a2.moveH(1, "word");
      },
      delCharBefore: function(a2) {
        return a2.deleteH(-1, "codepoint");
      },
      delCharAfter: function(a2) {
        return a2.deleteH(1, "char");
      },
      delWordBefore: function(a2) {
        return a2.deleteH(-1, "word");
      },
      delWordAfter: function(a2) {
        return a2.deleteH(1, "word");
      },
      delGroupBefore: function(a2) {
        return a2.deleteH(-1, "group");
      },
      delGroupAfter: function(a2) {
        return a2.deleteH(1, "group");
      },
      indentAuto: function(a2) {
        return a2.indentSelection("smart");
      },
      indentMore: function(a2) {
        return a2.indentSelection("add");
      },
      indentLess: function(a2) {
        return a2.indentSelection("subtract");
      },
      insertTab: function(a2) {
        return a2.replaceSelection("	");
      },
      insertSoftTab: function(a2) {
        for (var b = [], d2 = a2.listSelections(), c = a2.options.tabSize, e = 0; e < d2.length; e++) {
          var f = d2[e].from();
          f = wa(a2.getLine(f.line), f.ch, c);
          b.push(id2(c - f % c));
        }
        a2.replaceSelections(b);
      },
      defaultTab: function(a2) {
        a2.somethingSelected() ? a2.indentSelection("add") : a2.execCommand("insertTab");
      },
      transposeChars: function(a2) {
        return ra(a2, function() {
          for (var b = a2.listSelections(), d2 = [], c = 0; c < b.length; c++)
            if (b[c].empty()) {
              var e = b[c].head, f = w(a2.doc, e.line).text;
              if (f) {
                if (e.ch == f.length && (e = new t(e.line, e.ch - 1)), 0 < e.ch)
                  e = new t(e.line, e.ch + 1), a2.replaceRange(f.charAt(e.ch - 1) + f.charAt(e.ch - 2), t(e.line, e.ch - 2), e, "+transpose");
                else if (e.line > a2.doc.first) {
                  var g = w(a2.doc, e.line - 1).text;
                  g && (e = new t(e.line, 1), a2.replaceRange(f.charAt(0) + a2.doc.lineSeparator() + g.charAt(g.length - 1), t(e.line - 1, g.length - 1), e, "+transpose"));
                }
              }
              d2.push(new I(e, e));
            }
          a2.setSelections(d2);
        });
      },
      newlineAndIndent: function(a2) {
        return ra(a2, function() {
          for (var b = a2.listSelections(), d2 = b.length - 1; 0 <= d2; d2--)
            a2.replaceRange(a2.doc.lineSeparator(), b[d2].anchor, b[d2].head, "+input");
          b = a2.listSelections();
          for (d2 = 0; d2 < b.length; d2++)
            a2.indentLine(b[d2].from().line, null, true);
          xb(a2);
        });
      },
      openLine: function(a2) {
        return a2.replaceSelection("\n", "start");
      },
      toggleOverwrite: function(a2) {
        return a2.toggleOverwrite();
      }
    }, lh = new Xa(), he = null, ie = function(a2, b, d2) {
      this.time = a2;
      this.pos = b;
      this.button = d2;
    };
    ie.prototype.compare = function(a2, b, d2) {
      return this.time + 400 > a2 && 0 == B(b, this.pos) && d2 == this.button;
    };
    var mc, lc, Hb = { toString: function() {
      return "CodeMirror.Init";
    } }, mg = {}, bd = {};
    U.defaults = mg;
    U.optionHandlers = bd;
    var le = [];
    U.defineInitHook = function(a2) {
      return le.push(a2);
    };
    var sa = null, O = function(a2) {
      this.cm = a2;
      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
      this.polling = new Xa();
      this.composing = null;
      this.gracePeriod = false;
      this.readDOMTimeout = null;
    };
    O.prototype.init = function(a2) {
      function b(h2) {
        for (h2 = h2.target; h2; h2 = h2.parentNode) {
          if (h2 == g)
            return true;
          if (/\bCodeMirror-(?:line)?widget\b/.test(h2.className))
            break;
        }
        return false;
      }
      function d2(h2) {
        if (b(h2) && !Z(
          f,
          h2
        )) {
          if (f.somethingSelected())
            sa = { lineWise: false, text: f.getSelections() }, "cut" == h2.type && f.replaceSelection("", null, "cut");
          else if (f.options.lineWiseCopyCut) {
            var k = qg(f);
            sa = { lineWise: true, text: k.text };
            "cut" == h2.type && f.operation(function() {
              f.setSelections(k.ranges, 0, Ia);
              f.replaceSelection("", null, "cut");
            });
          } else
            return;
          if (h2.clipboardData) {
            h2.clipboardData.clearData();
            var l = sa.text.join("\n");
            h2.clipboardData.setData("Text", l);
            if (h2.clipboardData.getData("Text") == l) {
              h2.preventDefault();
              return;
            }
          }
          var m2 = sg();
          h2 = m2.firstChild;
          f.display.lineSpace.insertBefore(m2, f.display.lineSpace.firstChild);
          h2.value = sa.text.join("\n");
          var n = ka(g.ownerDocument);
          pc(h2);
          setTimeout(function() {
            f.display.lineSpace.removeChild(m2);
            n.focus();
            n == g && e.showPrimarySelection();
          }, 50);
        }
      }
      var c = this, e = this, f = e.cm, g = e.div = a2.lineDiv;
      g.contentEditable = true;
      rg(g, f.options.spellcheck, f.options.autocorrect, f.options.autocapitalize);
      z(g, "paste", function(h2) {
        !b(h2) || Z(f, h2) || pg(h2, f) || 11 >= T && setTimeout(ba(f, function() {
          return c.updateFromDOM();
        }), 20);
      });
      z(
        g,
        "compositionstart",
        function(h2) {
          c.composing = { data: h2.data, done: false };
        }
      );
      z(g, "compositionupdate", function(h2) {
        c.composing || (c.composing = { data: h2.data, done: false });
      });
      z(g, "compositionend", function(h2) {
        c.composing && (h2.data != c.composing.data && c.readFromDOMSoon(), c.composing.done = true);
      });
      z(g, "touchstart", function() {
        return e.forceCompositionEnd();
      });
      z(g, "input", function() {
        c.composing || c.readFromDOMSoon();
      });
      z(g, "copy", d2);
      z(g, "cut", d2);
    };
    O.prototype.screenReaderLabelChanged = function(a2) {
      a2 ? this.div.setAttribute("aria-label", a2) : this.div.removeAttribute("aria-label");
    };
    O.prototype.prepareSelection = function() {
      var a2 = gf(this.cm, false);
      a2.focus = ka(this.div.ownerDocument) == this.div;
      return a2;
    };
    O.prototype.showSelection = function(a2, b) {
      a2 && this.cm.display.view.length && ((a2.focus || b) && this.showPrimarySelection(), this.showMultipleSelections(a2));
    };
    O.prototype.getSelection = function() {
      return this.cm.display.wrapper.ownerDocument.getSelection();
    };
    O.prototype.showPrimarySelection = function() {
      var a2 = this.getSelection(), b = this.cm, d2 = b.doc.sel.primary(), c = d2.from();
      d2 = d2.to();
      if (b.display.viewTo == b.display.viewFrom || c.line >= b.display.viewTo || d2.line < b.display.viewFrom)
        a2.removeAllRanges();
      else {
        var e = cd(b, a2.anchorNode, a2.anchorOffset), f = cd(b, a2.focusNode, a2.focusOffset);
        if (!e || e.bad || !f || f.bad || 0 != B(Bc(e, f), c) || 0 != B(Ac(e, f), d2))
          if (e = b.display.view, c = c.line >= b.display.viewFrom && ug(b, c) || { node: e[0].measure.map[2], offset: 0 }, d2 = d2.line < b.display.viewTo && ug(b, d2), d2 || (d2 = e[e.length - 1].measure, d2 = d2.maps ? d2.maps[d2.maps.length - 1] : d2.map, d2 = { node: d2[d2.length - 1], offset: d2[d2.length - 2] - d2[d2.length - 3] }), c && d2) {
            e = a2.rangeCount && a2.getRangeAt(0);
            try {
              var g = Qb(c.node, c.offset, d2.offset, d2.node);
            } catch (h2) {
            }
            g && (!Ma && b.state.focused ? (a2.collapse(c.node, c.offset), g.collapsed || (a2.removeAllRanges(), a2.addRange(g))) : (a2.removeAllRanges(), a2.addRange(g)), e && null == a2.anchorNode ? a2.addRange(e) : Ma && this.startGracePeriod());
            this.rememberSelection();
          } else
            a2.removeAllRanges();
      }
    };
    O.prototype.startGracePeriod = function() {
      var a2 = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        a2.gracePeriod = false;
        a2.selectionChanged() && a2.cm.operation(function() {
          return a2.cm.curOp.selectionChanged = true;
        });
      }, 20);
    };
    O.prototype.showMultipleSelections = function(a2) {
      D(this.cm.display.cursorDiv, a2.cursors);
      D(this.cm.display.selectionDiv, a2.selection);
    };
    O.prototype.rememberSelection = function() {
      var a2 = this.getSelection();
      this.lastAnchorNode = a2.anchorNode;
      this.lastAnchorOffset = a2.anchorOffset;
      this.lastFocusNode = a2.focusNode;
      this.lastFocusOffset = a2.focusOffset;
    };
    O.prototype.selectionInEditor = function() {
      var a2 = this.getSelection();
      if (!a2.rangeCount)
        return false;
      a2 = a2.getRangeAt(0).commonAncestorContainer;
      return ja(this.div, a2);
    };
    O.prototype.focus = function() {
      "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() && ka(this.div.ownerDocument) == this.div || this.showSelection(this.prepareSelection(), true), this.div.focus());
    };
    O.prototype.blur = function() {
      this.div.blur();
    };
    O.prototype.getField = function() {
      return this.div;
    };
    O.prototype.supportsTouch = function() {
      return true;
    };
    O.prototype.receivedFocus = function() {
      function a2() {
        d2.cm.state.focused && (d2.pollSelection(), d2.polling.set(d2.cm.options.pollInterval, a2));
      }
      var b = this, d2 = this;
      this.selectionInEditor() ? setTimeout(function() {
        return b.pollSelection();
      }, 20) : ra(this.cm, function() {
        return d2.cm.curOp.selectionChanged = true;
      });
      this.polling.set(this.cm.options.pollInterval, a2);
    };
    O.prototype.selectionChanged = function() {
      var a2 = this.getSelection();
      return a2.anchorNode != this.lastAnchorNode || a2.anchorOffset != this.lastAnchorOffset || a2.focusNode != this.lastFocusNode || a2.focusOffset != this.lastFocusOffset;
    };
    O.prototype.pollSelection = function() {
      if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
        var a2 = this.getSelection(), b = this.cm;
        if (Gc && Qa && this.cm.display.gutterSpecs.length && Ah(a2.anchorNode))
          this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs }), this.blur(), this.focus();
        else if (!this.composing) {
          this.rememberSelection();
          var d2 = cd(b, a2.anchorNode, a2.anchorOffset), c = cd(b, a2.focusNode, a2.focusOffset);
          d2 && c && ra(b, function() {
            da(b.doc, Oa(d2, c), Ia);
            if (d2.bad || c.bad)
              b.curOp.selectionChanged = true;
          });
        }
      }
    };
    O.prototype.pollContent = function() {
      null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
      var a2 = this.cm, b = a2.display, d2 = a2.doc.sel.primary(), c = d2.from(), e = d2.to();
      0 == c.ch && c.line > a2.firstLine() && (c = t(c.line - 1, w(a2.doc, c.line - 1).length));
      e.ch == w(a2.doc, e.line).text.length && e.line < a2.lastLine() && (e = t(e.line + 1, 0));
      if (c.line < b.viewFrom || e.line > b.viewTo - 1)
        return false;
      var f;
      c.line == b.viewFrom || 0 == (f = db(a2, c.line)) ? (d2 = N(b.view[0].line), f = b.view[0].node) : (d2 = N(b.view[f].line), f = b.view[f - 1].node.nextSibling);
      var g = db(a2, e.line);
      g == b.view.length - 1 ? (e = b.viewTo - 1, b = b.lineDiv.lastChild) : (e = N(b.view[g + 1].line) - 1, b = b.view[g + 1].node.previousSibling);
      if (!f)
        return false;
      b = a2.doc.splitLines(Bh(a2, f, b, d2, e));
      for (f = ab(a2.doc, t(d2, 0), t(e, w(a2.doc, e).text.length)); 1 < b.length && 1 < f.length; )
        if (J(b) == J(f))
          b.pop(), f.pop(), e--;
        else if (b[0] == f[0])
          b.shift(), f.shift(), d2++;
        else
          break;
      var h2 = 0;
      g = 0;
      for (var k = b[0], l = f[0], m2 = Math.min(k.length, l.length); h2 < m2 && k.charCodeAt(h2) == l.charCodeAt(h2); )
        ++h2;
      k = J(b);
      l = J(f);
      for (m2 = Math.min(k.length - (1 == b.length ? h2 : 0), l.length - (1 == f.length ? h2 : 0)); g < m2 && k.charCodeAt(k.length - g - 1) == l.charCodeAt(l.length - g - 1); )
        ++g;
      if (1 == b.length && 1 == f.length && d2 == c.line)
        for (; h2 && h2 > c.ch && k.charCodeAt(k.length - g - 1) == l.charCodeAt(l.length - g - 1); )
          h2--, g++;
      b[b.length - 1] = k.slice(0, k.length - g).replace(/^\u200b+/, "");
      b[0] = b[0].slice(h2).replace(/\u200b+$/, "");
      c = t(d2, h2);
      d2 = t(e, f.length ? J(f).length - g : 0);
      if (1 < b.length || b[0] || B(c, d2))
        return Db(a2.doc, b, c, d2, "+input"), true;
    };
    O.prototype.ensurePolled = function() {
      this.forceCompositionEnd();
    };
    O.prototype.reset = function() {
      this.forceCompositionEnd();
    };
    O.prototype.forceCompositionEnd = function() {
      this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus());
    };
    O.prototype.readFromDOMSoon = function() {
      var a2 = this;
      null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function() {
        a2.readDOMTimeout = null;
        if (a2.composing)
          if (a2.composing.done)
            a2.composing = null;
          else
            return;
        a2.updateFromDOM();
      }, 80));
    };
    O.prototype.updateFromDOM = function() {
      var a2 = this;
      !this.cm.isReadOnly() && this.pollContent() || ra(this.cm, function() {
        return ma(a2.cm);
      });
    };
    O.prototype.setUneditable = function(a2) {
      a2.contentEditable = "false";
    };
    O.prototype.onKeyPress = function(a2) {
      0 == a2.charCode || this.composing || (a2.preventDefault(), this.cm.isReadOnly() || ba(this.cm, me)(this.cm, String.fromCharCode(null == a2.charCode ? a2.keyCode : a2.charCode), 0));
    };
    O.prototype.readOnlyChanged = function(a2) {
      this.div.contentEditable = String("nocursor" != a2);
    };
    O.prototype.onContextMenu = function() {
    };
    O.prototype.resetPosition = function() {
    };
    O.prototype.needsContentAttribute = true;
    var V = function(a2) {
      this.cm = a2;
      this.prevInput = "";
      this.pollingFast = false;
      this.polling = new Xa();
      this.hasSelection = false;
      this.composing = null;
      this.resetting = false;
    };
    V.prototype.init = function(a2) {
      function b(g) {
        if (!Z(e, g)) {
          if (e.somethingSelected())
            sa = { lineWise: false, text: e.getSelections() };
          else if (e.options.lineWiseCopyCut) {
            var h2 = qg(e);
            sa = { lineWise: true, text: h2.text };
            "cut" == g.type ? e.setSelections(h2.ranges, null, Ia) : (c.prevInput = "", f.value = h2.text.join("\n"), pc(f));
          } else
            return;
          "cut" == g.type && (e.state.cutIncoming = +/* @__PURE__ */ new Date());
        }
      }
      var d2 = this, c = this, e = this.cm;
      this.createField(a2);
      var f = this.textarea;
      a2.wrapper.insertBefore(this.wrapper, a2.wrapper.firstChild);
      oc && (f.style.width = "0px");
      z(f, "input", function() {
        G && 9 <= T && d2.hasSelection && (d2.hasSelection = null);
        c.poll();
      });
      z(f, "paste", function(g) {
        Z(e, g) || pg(g, e) || (e.state.pasteIncoming = +/* @__PURE__ */ new Date(), c.fastPoll());
      });
      z(f, "cut", b);
      z(f, "copy", b);
      z(a2.scroller, "paste", function(g) {
        if (!La(a2, g) && !Z(e, g))
          if (f.dispatchEvent) {
            var h2 = new Event("paste");
            h2.clipboardData = g.clipboardData;
            f.dispatchEvent(h2);
          } else
            e.state.pasteIncoming = +/* @__PURE__ */ new Date(), c.focus();
      });
      z(a2.lineSpace, "selectstart", function(g) {
        La(a2, g) || la(g);
      });
      z(
        f,
        "compositionstart",
        function() {
          var g = e.getCursor("from");
          c.composing && c.composing.range.clear();
          c.composing = { start: g, range: e.markText(g, e.getCursor("to"), { className: "CodeMirror-composing" }) };
        }
      );
      z(f, "compositionend", function() {
        c.composing && (c.poll(), c.composing.range.clear(), c.composing = null);
      });
    };
    V.prototype.createField = function(a2) {
      this.wrapper = sg();
      this.textarea = this.wrapper.firstChild;
    };
    V.prototype.screenReaderLabelChanged = function(a2) {
      a2 ? this.textarea.setAttribute("aria-label", a2) : this.textarea.removeAttribute("aria-label");
    };
    V.prototype.prepareSelection = function() {
      var a2 = this.cm, b = a2.display, d2 = a2.doc, c = gf(a2);
      if (a2.options.moveInputWithCursor) {
        a2 = Ba(a2, d2.sel.primary().head, "div");
        d2 = b.wrapper.getBoundingClientRect();
        var e = b.lineDiv.getBoundingClientRect();
        c.teTop = Math.max(0, Math.min(b.wrapper.clientHeight - 10, a2.top + e.top - d2.top));
        c.teLeft = Math.max(0, Math.min(b.wrapper.clientWidth - 10, a2.left + e.left - d2.left));
      }
      return c;
    };
    V.prototype.showSelection = function(a2) {
      var b = this.cm.display;
      D(b.cursorDiv, a2.cursors);
      D(b.selectionDiv, a2.selection);
      null != a2.teTop && (this.wrapper.style.top = a2.teTop + "px", this.wrapper.style.left = a2.teLeft + "px");
    };
    V.prototype.reset = function(a2) {
      if (!(this.contextMenuPending || this.composing && a2)) {
        var b = this.cm;
        this.resetting = true;
        b.somethingSelected() ? (this.prevInput = "", a2 = b.getSelection(), this.textarea.value = a2, b.state.focused && pc(this.textarea), G && 9 <= T && (this.hasSelection = a2)) : a2 || (this.prevInput = this.textarea.value = "", G && 9 <= T && (this.hasSelection = null));
        this.resetting = false;
      }
    };
    V.prototype.getField = function() {
      return this.textarea;
    };
    V.prototype.supportsTouch = function() {
      return false;
    };
    V.prototype.focus = function() {
      if ("nocursor" != this.cm.options.readOnly && (!ac || ka(this.textarea.ownerDocument) != this.textarea))
        try {
          this.textarea.focus();
        } catch (a2) {
        }
    };
    V.prototype.blur = function() {
      this.textarea.blur();
    };
    V.prototype.resetPosition = function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    };
    V.prototype.receivedFocus = function() {
      this.slowPoll();
    };
    V.prototype.slowPoll = function() {
      var a2 = this;
      this.pollingFast || this.polling.set(
        this.cm.options.pollInterval,
        function() {
          a2.poll();
          a2.cm.state.focused && a2.slowPoll();
        }
      );
    };
    V.prototype.fastPoll = function() {
      function a2() {
        d2.poll() || b ? (d2.pollingFast = false, d2.slowPoll()) : (b = true, d2.polling.set(60, a2));
      }
      var b = false, d2 = this;
      d2.pollingFast = true;
      d2.polling.set(20, a2);
    };
    V.prototype.poll = function() {
      var a2 = this, b = this.cm, d2 = this.textarea, c = this.prevInput;
      if (this.contextMenuPending || this.resetting || !b.state.focused || Gh(d2) && !c && !this.composing || b.isReadOnly() || b.options.disableInput || b.state.keySeq)
        return false;
      var e = d2.value;
      if (e == c && !b.somethingSelected())
        return false;
      if (G && 9 <= T && this.hasSelection === e || ya && /[\uf700-\uf7ff]/.test(e))
        return b.display.input.reset(), false;
      if (b.doc.sel == b.display.selForContextMenu) {
        var f = e.charCodeAt(0);
        8203 != f || c || (c = "‚Äã");
        if (8666 == f)
          return this.reset(), this.cm.execCommand("undo");
      }
      var g = 0;
      for (f = Math.min(c.length, e.length); g < f && c.charCodeAt(g) == e.charCodeAt(g); )
        ++g;
      ra(b, function() {
        me(b, e.slice(g), c.length - g, null, a2.composing ? "*compose" : null);
        1e3 < e.length || -1 < e.indexOf("\n") ? d2.value = a2.prevInput = "" : a2.prevInput = e;
        a2.composing && (a2.composing.range.clear(), a2.composing.range = b.markText(a2.composing.start, b.getCursor("to"), { className: "CodeMirror-composing" }));
      });
      return true;
    };
    V.prototype.ensurePolled = function() {
      this.pollingFast && this.poll() && (this.pollingFast = false);
    };
    V.prototype.onKeyPress = function() {
      G && 9 <= T && (this.hasSelection = null);
      this.fastPoll();
    };
    V.prototype.onContextMenu = function(a2) {
      function b() {
        if (null != g.selectionStart) {
          var q = e.somethingSelected(), r = "‚Äã" + (q ? g.value : "");
          g.value = "‚áö";
          g.value = r;
          c.prevInput = q ? "" : "‚Äã";
          g.selectionStart = 1;
          g.selectionEnd = r.length;
          f.selForContextMenu = e.doc.sel;
        }
      }
      function d2() {
        if (c.contextMenuPending == d2 && (c.contextMenuPending = false, c.wrapper.style.cssText = m2, g.style.cssText = l, G && 9 > T && f.scrollbars.setScrollTop(f.scroller.scrollTop = k), null != g.selectionStart)) {
          (!G || G && 9 > T) && b();
          var q = 0, r = function() {
            f.selForContextMenu == e.doc.sel && 0 == g.selectionStart && 0 < g.selectionEnd && "‚Äã" == c.prevInput ? ba(e, Lf)(e) : 10 > q++ ? f.detectingSelectAll = setTimeout(r, 500) : (f.selForContextMenu = null, f.input.reset());
          };
          f.detectingSelectAll = setTimeout(
            r,
            200
          );
        }
      }
      var c = this, e = c.cm, f = e.display, g = c.textarea;
      c.contextMenuPending && c.contextMenuPending();
      var h2 = gb(e, a2), k = f.scroller.scrollTop;
      if (h2 && !Ca) {
        e.options.resetSelectionOnContextMenu && -1 == e.doc.sel.contains(h2) && ba(e, da)(e.doc, Oa(h2), Ia);
        var l = g.style.cssText, m2 = c.wrapper.style.cssText;
        h2 = c.wrapper.offsetParent.getBoundingClientRect();
        c.wrapper.style.cssText = "position: static";
        g.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (a2.clientY - h2.top - 5) + "px; left: " + (a2.clientX - h2.left - 5) + "px;\n      z-index: 1000; background: " + (G ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
        if (fa)
          var n = g.ownerDocument.defaultView.scrollY;
        f.input.focus();
        fa && g.ownerDocument.defaultView.scrollTo(null, n);
        f.input.reset();
        e.somethingSelected() || (g.value = c.prevInput = " ");
        c.contextMenuPending = d2;
        f.selForContextMenu = e.doc.sel;
        clearTimeout(f.detectingSelectAll);
        G && 9 <= T && b();
        if (je) {
          Mb(a2);
          var p = function() {
            ta(window, "mouseup", p);
            setTimeout(d2, 20);
          };
          z(window, "mouseup", p);
        } else
          setTimeout(d2, 50);
      }
    };
    V.prototype.readOnlyChanged = function(a2) {
      a2 || this.reset();
      this.textarea.disabled = "nocursor" == a2;
      this.textarea.readOnly = !!a2;
    };
    V.prototype.setUneditable = function() {
    };
    V.prototype.needsContentAttribute = false;
    (function(a2) {
      function b(c, e, f, g) {
        a2.defaults[c] = e;
        f && (d2[c] = g ? function(h2, k, l) {
          l != Hb && f(h2, k, l);
        } : f);
      }
      var d2 = a2.optionHandlers;
      a2.defineOption = b;
      a2.Init = Hb;
      b("value", "", function(c, e) {
        return c.setValue(e);
      }, true);
      b(
        "mode",
        null,
        function(c, e) {
          c.doc.modeOption = e;
          $d(c);
        },
        true
      );
      b("indentUnit", 2, $d, true);
      b("indentWithTabs", false);
      b("smartIndent", true);
      b("tabSize", 4, function(c) {
        bc(c);
        Ub(c);
        ma(c);
      }, true);
      b("lineSeparator", null, function(c, e) {
        if (c.doc.lineSep = e) {
          var f = [], g = c.doc.first;
          c.doc.iter(function(k) {
            for (var l = 0; ; ) {
              var m2 = k.text.indexOf(e, l);
              if (-1 == m2)
                break;
              l = m2 + e.length;
              f.push(t(g, m2));
            }
            g++;
          });
          for (var h2 = f.length - 1; 0 <= h2; h2--)
            Db(c.doc, e, f[h2], t(f[h2].line, f[h2].ch + e.length));
        }
      });
      b(
        "specialChars",
        /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g,
        function(c, e, f) {
          c.state.specialChars = new RegExp(e.source + (e.test("	") ? "" : "|	"), "g");
          f != Hb && c.refresh();
        }
      );
      b("specialCharPlaceholder", Mg, function(c) {
        return c.refresh();
      }, true);
      b("electricChars", true);
      b("inputStyle", ac ? "contenteditable" : "textarea", function() {
        throw Error("inputStyle can not (yet) be changed in a running editor");
      }, true);
      b("spellcheck", false, function(c, e) {
        return c.getInputField().spellcheck = e;
      }, true);
      b("autocorrect", false, function(c, e) {
        return c.getInputField().autocorrect = e;
      }, true);
      b(
        "autocapitalize",
        false,
        function(c, e) {
          return c.getInputField().autocapitalize = e;
        },
        true
      );
      b("rtlMoveVisually", !Fh);
      b("wholeLineUpdateBefore", true);
      b("theme", "default", function(c) {
        lg(c);
        $b(c);
      }, true);
      b("keyMap", "default", function(c, e, f) {
        e = Xc(e);
        (f = f != Hb && Xc(f)) && f.detach && f.detach(c, e);
        e.attach && e.attach(c, f || null);
      });
      b("extraKeys", null);
      b("configureMouse", null);
      b("lineWrapping", false, yh, true);
      b("gutters", [], function(c, e) {
        c.display.gutterSpecs = Yd(e, c.options.lineNumbers);
        $b(c);
      }, true);
      b("fixedGutter", true, function(c, e) {
        c.display.gutters.style.left = e ? Md(c.display) + "px" : "0";
        c.refresh();
      }, true);
      b("coverGutterNextToScrollbar", false, function(c) {
        return yb(c);
      }, true);
      b("scrollbarStyle", "native", function(c) {
        of(c);
        yb(c);
        c.display.scrollbars.setScrollTop(c.doc.scrollTop);
        c.display.scrollbars.setScrollLeft(c.doc.scrollLeft);
      }, true);
      b("lineNumbers", false, function(c, e) {
        c.display.gutterSpecs = Yd(c.options.gutters, e);
        $b(c);
      }, true);
      b("firstLineNumber", 1, $b, true);
      b("lineNumberFormatter", function(c) {
        return c;
      }, $b, true);
      b("showCursorWhenSelecting", false, Vb, true);
      b(
        "resetSelectionOnContextMenu",
        true
      );
      b("lineWiseCopyCut", true);
      b("pasteLinesPerSelection", true);
      b("selectionsMayTouch", false);
      b("readOnly", false, function(c, e) {
        "nocursor" == e && (wb(c), c.display.input.blur());
        c.display.input.readOnlyChanged(e);
      });
      b("screenReaderLabel", null, function(c, e) {
        c.display.input.screenReaderLabelChanged("" === e ? null : e);
      });
      b("disableInput", false, function(c, e) {
        e || c.display.input.reset();
      }, true);
      b("dragDrop", true, xh);
      b("allowDropFileTypes", null);
      b("cursorBlinkRate", 530);
      b("cursorScrollMargin", 0);
      b("cursorHeight", 1, Vb, true);
      b(
        "singleCursorHeightPerLine",
        true,
        Vb,
        true
      );
      b("workTime", 100);
      b("workDelay", 100);
      b("flattenSpans", true, bc, true);
      b("addModeClass", false, bc, true);
      b("pollInterval", 100);
      b("undoDepth", 200, function(c, e) {
        return c.doc.history.undoDepth = e;
      });
      b("historyEventDelay", 1250);
      b("viewportMargin", 10, function(c) {
        return c.refresh();
      }, true);
      b("maxHighlightLength", 1e4, bc, true);
      b("moveInputWithCursor", true, function(c, e) {
        e || c.display.input.resetPosition();
      });
      b("tabindex", null, function(c, e) {
        return c.display.input.getField().tabIndex = e || "";
      });
      b("autofocus", null);
      b(
        "direction",
        "ltr",
        function(c, e) {
          return c.doc.setDirection(e);
        },
        true
      );
      b("phrases", null);
    })(U);
    (function(a2) {
      var b = a2.optionHandlers, d2 = a2.helpers = {};
      a2.prototype = {
        constructor: a2,
        focus: function() {
          qa(this).defaultView.focus();
          this.display.input.focus();
        },
        setOption: function(c, e) {
          var f = this.options, g = f[c];
          if (f[c] != e || "mode" == c)
            f[c] = e, b.hasOwnProperty(c) && ba(this, b[c])(this, e, g), W(this, "optionChange", this, c);
        },
        getOption: function(c) {
          return this.options[c];
        },
        getDoc: function() {
          return this.doc;
        },
        addKeyMap: function(c, e) {
          this.state.keyMaps[e ? "push" : "unshift"](Xc(c));
        },
        removeKeyMap: function(c) {
          for (var e = this.state.keyMaps, f = 0; f < e.length; ++f)
            if (e[f] == c || e[f].name == c)
              return e.splice(f, 1), true;
        },
        addOverlay: ia(function(c, e) {
          var f = c.token ? c : a2.getMode(this.options, c);
          if (f.startState)
            throw Error("Overlays may not be stateful.");
          yg(this.state.overlays, { mode: f, modeSpec: c, opaque: e && e.opaque, priority: e && e.priority || 0 }, function(g) {
            return g.priority;
          });
          this.state.modeGen++;
          ma(this);
        }),
        removeOverlay: ia(function(c) {
          for (var e = this.state.overlays, f = 0; f < e.length; ++f) {
            var g = e[f].modeSpec;
            if (g == c || "string" == typeof c && g.name == c) {
              e.splice(f, 1);
              this.state.modeGen++;
              ma(this);
              break;
            }
          }
        }),
        indentLine: ia(function(c, e, f) {
          "string" != typeof e && "number" != typeof e && (e = null == e ? this.options.smartIndent ? "smart" : "prev" : e ? "add" : "subtract");
          Nb(this.doc, c) && nc(this, c, e, f);
        }),
        indentSelection: ia(function(c) {
          for (var e = this.doc.sel.ranges, f = -1, g = 0; g < e.length; g++) {
            var h2 = e[g];
            if (h2.empty())
              h2.head.line > f && (nc(this, h2.head.line, c, true), f = h2.head.line, g == this.doc.sel.primIndex && xb(this));
            else {
              var k = h2.from();
              h2 = h2.to();
              var l = Math.max(f, k.line);
              f = Math.min(this.lastLine(), h2.line - (h2.ch ? 0 : 1)) + 1;
              for (h2 = l; h2 < f; ++h2)
                nc(this, h2, c);
              h2 = this.doc.sel.ranges;
              0 == k.ch && e.length == h2.length && 0 < h2[g].from().ch && de(this.doc, g, new I(k, h2[g].to()), Ia);
            }
          }
        }),
        getTokenAt: function(c, e) {
          return Ce(this, c, e);
        },
        getLineTokens: function(c, e) {
          return Ce(this, t(c), e, true);
        },
        getTokenTypeAt: function(c) {
          c = C(this.doc, c);
          var e = Ae(this, w(this.doc, c.line)), f = 0, g = (e.length - 1) / 2;
          c = c.ch;
          if (0 == c)
            e = e[2];
          else
            for (; ; ) {
              var h2 = f + g >> 1;
              if ((h2 ? e[2 * h2 - 1] : 0) >= c)
                g = h2;
              else if (e[2 * h2 + 1] < c)
                f = h2 + 1;
              else {
                e = e[2 * h2 + 2];
                break;
              }
            }
          f = e ? e.indexOf("overlay ") : -1;
          return 0 > f ? e : 0 == f ? null : e.slice(0, f - 1);
        },
        getModeAt: function(c) {
          var e = this.doc.mode;
          return e.innerMode ? a2.innerMode(e, this.getTokenAt(c).state).mode : e;
        },
        getHelper: function(c, e) {
          return this.getHelpers(c, e)[0];
        },
        getHelpers: function(c, e) {
          var f = [];
          if (!d2.hasOwnProperty(e))
            return f;
          var g = d2[e];
          c = this.getModeAt(c);
          if ("string" == typeof c[e])
            g[c[e]] && f.push(g[c[e]]);
          else if (c[e])
            for (var h2 = 0; h2 < c[e].length; h2++) {
              var k = g[c[e][h2]];
              k && f.push(k);
            }
          else
            c.helperType && g[c.helperType] ? f.push(g[c.helperType]) : g[c.name] && f.push(g[c.name]);
          for (e = 0; e < g._global.length; e++)
            h2 = g._global[e], h2.pred(c, this) && -1 == ea(f, h2.val) && f.push(h2.val);
          return f;
        },
        getStateAfter: function(c, e) {
          var f = this.doc;
          c = Math.max(f.first, Math.min(null == c ? f.first + f.size - 1 : c, f.first + f.size - 1));
          return Ob(this, c + 1, e).state;
        },
        cursorCoords: function(c, e) {
          var f = this.doc.sel.primary();
          c = null == c ? f.head : "object" == typeof c ? C(this.doc, c) : c ? f.from() : f.to();
          return Ba(this, c, e || "page");
        },
        charCoords: function(c, e) {
          return Ic(
            this,
            C(this.doc, c),
            e || "page"
          );
        },
        coordsChar: function(c, e) {
          c = af(this, c, e || "page");
          return Kd(this, c.left, c.top);
        },
        lineAtHeight: function(c, e) {
          c = af(this, { top: c, left: 0 }, e || "page").top;
          return bb(this.doc, c + this.display.viewOffset);
        },
        heightAtLine: function(c, e, f) {
          var g = false;
          if ("number" == typeof c) {
            var h2 = this.doc.first + this.doc.size - 1;
            c < this.doc.first ? c = this.doc.first : c > h2 && (c = h2, g = true);
            c = w(this.doc, c);
          }
          return Hc(this, c, { top: 0, left: 0 }, e || "page", f || g).top + (g ? this.doc.height - Ga(c) : 0);
        },
        defaultTextHeight: function() {
          return vb(this.display);
        },
        defaultCharWidth: function() {
          return ub(this.display);
        },
        getViewport: function() {
          return { from: this.display.viewFrom, to: this.display.viewTo };
        },
        addWidget: function(c, e, f, g, h2) {
          var k = this.display;
          c = Ba(this, C(this.doc, c));
          var l = c.bottom, m2 = c.left;
          e.style.position = "absolute";
          e.setAttribute("cm-ignore-events", "true");
          this.display.input.setUneditable(e);
          k.sizer.appendChild(e);
          if ("over" == g)
            l = c.top;
          else if ("above" == g || "near" == g) {
            var n = Math.max(k.wrapper.clientHeight, this.doc.height), p = Math.max(k.sizer.clientWidth, k.lineSpace.clientWidth);
            ("above" == g || c.bottom + e.offsetHeight > n) && c.top > e.offsetHeight ? l = c.top - e.offsetHeight : c.bottom + e.offsetHeight <= n && (l = c.bottom);
            m2 + e.offsetWidth > p && (m2 = p - e.offsetWidth);
          }
          e.style.top = l + "px";
          e.style.left = e.style.right = "";
          "right" == h2 ? (m2 = k.sizer.clientWidth - e.offsetWidth, e.style.right = "0px") : ("left" == h2 ? m2 = 0 : "middle" == h2 && (m2 = (k.sizer.clientWidth - e.offsetWidth) / 2), e.style.left = m2 + "px");
          f && (c = Td(this, { left: m2, top: l, right: m2 + e.offsetWidth, bottom: l + e.offsetHeight }), null != c.scrollTop && Xb(this, c.scrollTop), null != c.scrollLeft && kb(this, c.scrollLeft));
        },
        triggerOnKeyDown: ia(fg),
        triggerOnKeyPress: ia(hg),
        triggerOnKeyUp: gg,
        triggerOnMouseDown: ia(ig),
        execCommand: function(c) {
          if (jc.hasOwnProperty(c))
            return jc[c].call(null, this);
        },
        triggerElectric: ia(function(c) {
          og(this, c);
        }),
        findPosH: function(c, e, f, g) {
          var h2 = 1;
          0 > e && (h2 = -1, e = -e);
          c = C(this.doc, c);
          for (var k = 0; k < e && (c = oe(this.doc, c, h2, f, g), !c.hitSide); ++k)
            ;
          return c;
        },
        moveH: ia(function(c, e) {
          var f = this;
          this.extendSelectionsBy(function(g) {
            return f.display.shift || f.doc.extend || g.empty() ? oe(
              f.doc,
              g.head,
              c,
              e,
              f.options.rtlMoveVisually
            ) : 0 > c ? g.from() : g.to();
          }, qc);
        }),
        deleteH: ia(function(c, e) {
          var f = this.doc;
          this.doc.sel.somethingSelected() ? f.replaceSelection("", null, "+delete") : Gb(this, function(g) {
            var h2 = oe(f, g.head, c, e, false);
            return 0 > c ? { from: h2, to: g.head } : { from: g.head, to: h2 };
          });
        }),
        findPosV: function(c, e, f, g) {
          var h2 = 1;
          0 > e && (h2 = -1, e = -e);
          var k = C(this.doc, c);
          for (c = 0; c < e && (k = Ba(this, k, "div"), null == g ? g = k.left : k.left = g, k = tg(this, k, h2, f), !k.hitSide); ++c)
            ;
          return k;
        },
        moveV: ia(function(c, e) {
          var f = this, g = this.doc, h2 = [], k = !this.display.shift && !g.extend && g.sel.somethingSelected();
          g.extendSelectionsBy(function(m2) {
            if (k)
              return 0 > c ? m2.from() : m2.to();
            var n = Ba(f, m2.head, "div");
            null != m2.goalColumn && (n.left = m2.goalColumn);
            h2.push(n.left);
            var p = tg(f, n, c, e);
            "page" == e && m2 == g.sel.primary() && Nc(f, Ic(f, p, "div").top - n.top);
            return p;
          }, qc);
          if (h2.length)
            for (var l = 0; l < g.sel.ranges.length; l++)
              g.sel.ranges[l].goalColumn = h2[l];
        }),
        findWordAt: function(c) {
          var e = w(this.doc, c.line).text, f = c.ch, g = c.ch;
          if (e) {
            var h2 = this.getHelper(c, "wordChars");
            "before" != c.sticky && g != e.length || !f ? ++g : --f;
            var k = e.charAt(f);
            for (k = xc(k, h2) ? function(l) {
              return xc(l, h2);
            } : /\s/.test(k) ? function(l) {
              return /\s/.test(l);
            } : function(l) {
              return !/\s/.test(l) && !xc(l);
            }; 0 < f && k(e.charAt(f - 1)); )
              --f;
            for (; g < e.length && k(e.charAt(g)); )
              ++g;
          }
          return new I(t(c.line, f), t(c.line, g));
        },
        toggleOverwrite: function(c) {
          if (null == c || c != this.state.overwrite)
            (this.state.overwrite = !this.state.overwrite) ? Ya(this.display.cursorDiv, "CodeMirror-overwrite") : jb(this.display.cursorDiv, "CodeMirror-overwrite"), W(
              this,
              "overwriteToggle",
              this,
              this.state.overwrite
            );
        },
        hasFocus: function() {
          return this.display.input.getField() == ka(qa(this));
        },
        isReadOnly: function() {
          return !(!this.options.readOnly && !this.doc.cantEdit);
        },
        scrollTo: ia(function(c, e) {
          Wb(this, c, e);
        }),
        getScrollInfo: function() {
          var c = this.display.scroller;
          return { left: c.scrollLeft, top: c.scrollTop, height: c.scrollHeight - Ha(this) - this.display.barHeight, width: c.scrollWidth - Ha(this) - this.display.barWidth, clientHeight: Ed(this), clientWidth: cb(this) };
        },
        scrollIntoView: ia(function(c, e) {
          null == c ? (c = { from: this.doc.sel.primary().head, to: null }, null == e && (e = this.options.cursorScrollMargin)) : "number" == typeof c ? c = { from: t(c, 0), to: null } : null == c.from && (c = { from: c, to: null });
          c.to || (c.to = c.from);
          c.margin = e || 0;
          null != c.from.line ? (Oc(this), this.curOp.scrollToPos = c) : kf(this, c.from, c.to, c.margin);
        }),
        setSize: ia(function(c, e) {
          var f = this, g = function(k) {
            return "number" == typeof k || /^\d+$/.test(String(k)) ? k + "px" : k;
          };
          null != c && (this.display.wrapper.style.width = g(c));
          null != e && (this.display.wrapper.style.height = g(e));
          this.options.lineWrapping && Ye(this);
          var h2 = this.display.viewFrom;
          this.doc.iter(h2, this.display.viewTo, function(k) {
            if (k.widgets) {
              for (var l = 0; l < k.widgets.length; l++)
                if (k.widgets[l].noHScroll) {
                  Sa(f, h2, "widget");
                  break;
                }
            }
            ++h2;
          });
          this.curOp.forceUpdate = true;
          W(this, "refresh", this);
        }),
        operation: function(c) {
          return ra(this, c);
        },
        startOperation: function() {
          return lb(this);
        },
        endOperation: function() {
          return mb(this);
        },
        refresh: ia(function() {
          var c = this.display.cachedTextHeight;
          ma(this);
          this.curOp.forceUpdate = true;
          Ub(this);
          Wb(this, this.doc.scrollLeft, this.doc.scrollTop);
          Xd(this.display);
          (null == c || 0.5 < Math.abs(c - vb(this.display)) || this.options.lineWrapping) && Nd(this);
          W(this, "refresh", this);
        }),
        swapDoc: ia(function(c) {
          var e = this.doc;
          e.cm = null;
          this.state.selectingText && this.state.selectingText();
          zf(this, c);
          Ub(this);
          this.display.input.reset();
          Wb(this, c.scrollLeft, c.scrollTop);
          this.curOp.forceScroll = true;
          aa(this, "swapDoc", this, e);
          return e;
        }),
        phrase: function(c) {
          var e = this.options.phrases;
          return e && Object.prototype.hasOwnProperty.call(e, c) ? e[c] : c;
        },
        getInputField: function() {
          return this.display.input.getField();
        },
        getWrapperElement: function() {
          return this.display.wrapper;
        },
        getScrollerElement: function() {
          return this.display.scroller;
        },
        getGutterElement: function() {
          return this.display.gutters;
        }
      };
      pb(a2);
      a2.registerHelper = function(c, e, f) {
        d2.hasOwnProperty(c) || (d2[c] = a2[c] = { _global: [] });
        d2[c][e] = f;
      };
      a2.registerGlobalHelper = function(c, e, f, g) {
        a2.registerHelper(c, e, g);
        d2[c]._global.push({ pred: f, val: g });
      };
    })(U);
    var Ih = "iter insert remove copy getEditor constructor".split(" "), uc;
    for (uc in oa.prototype)
      oa.prototype.hasOwnProperty(uc) && 0 > ea(Ih, uc) && (U.prototype[uc] = function(a2) {
        return function() {
          return a2.apply(this.doc, arguments);
        };
      }(oa.prototype[uc]));
    pb(oa);
    U.inputStyles = { textarea: V, contenteditable: O };
    U.defineMode = function(a2) {
      U.defaults.mode || "null" == a2 || (U.defaults.mode = a2);
      Dg.apply(this, arguments);
    };
    U.defineMIME = function(a2, b) {
      qb[a2] = b;
    };
    U.defineMode("null", function() {
      return { token: function(a2) {
        return a2.skipToEnd();
      } };
    });
    U.defineMIME("text/plain", "null");
    U.defineExtension = function(a2, b) {
      U.prototype[a2] = b;
    };
    U.defineDocExtension = function(a2, b) {
      oa.prototype[a2] = b;
    };
    U.fromTextArea = function(a2, b) {
      function d2() {
        a2.value = h2.getValue();
      }
      b = b ? Za(b) : {};
      b.value = a2.value;
      !b.tabindex && a2.tabIndex && (b.tabindex = a2.tabIndex);
      !b.placeholder && a2.placeholder && (b.placeholder = a2.placeholder);
      if (null == b.autofocus) {
        var c = ka(a2.ownerDocument);
        b.autofocus = c == a2 || null != a2.getAttribute("autofocus") && c == document.body;
      }
      if (a2.form && (z(a2.form, "submit", d2), !b.leaveSubmitMethodAlone)) {
        var e = a2.form;
        var f = e.submit;
        try {
          var g = e.submit = function() {
            d2();
            e.submit = f;
            e.submit();
            e.submit = g;
          };
        } catch (k) {
        }
      }
      b.finishInit = function(k) {
        k.save = d2;
        k.getTextArea = function() {
          return a2;
        };
        k.toTextArea = function() {
          k.toTextArea = isNaN;
          d2();
          a2.parentNode.removeChild(k.getWrapperElement());
          a2.style.display = "";
          a2.form && (ta(a2.form, "submit", d2), b.leaveSubmitMethodAlone || "function" != typeof a2.form.submit || (a2.form.submit = f));
        };
      };
      a2.style.display = "none";
      var h2 = U(function(k) {
        return a2.parentNode.insertBefore(k, a2.nextSibling);
      }, b);
      return h2;
    };
    (function(a2) {
      a2.off = ta;
      a2.on = z;
      a2.wheelEventPixels = Zg;
      a2.Doc = oa;
      a2.splitLines = ne;
      a2.countColumn = wa;
      a2.findColumn = hd;
      a2.isWordChar = jd;
      a2.Pass = Zc;
      a2.signal = W;
      a2.Line = zb;
      a2.changeEnd = Ta;
      a2.scrollbarModel = pf;
      a2.Pos = t;
      a2.cmpPos = B;
      a2.modes = md;
      a2.mimeModes = qb;
      a2.resolveMode = zc;
      a2.getMode = nd;
      a2.modeExtensions = rb;
      a2.extendMode = Eg;
      a2.copyState = $a;
      a2.startState = we;
      a2.innerMode = od;
      a2.commands = jc;
      a2.keyMap = ic;
      a2.keyName = ag;
      a2.isModifierKey = Yf;
      a2.lookupKey = Fb;
      a2.normalizeKeyMap = jh;
      a2.StringStream = X;
      a2.SharedTextMarker = hc;
      a2.TextMarker = Va;
      a2.LineWidget = gc;
      a2.e_preventDefault = la;
      a2.e_stopPropagation = ue;
      a2.e_stop = Mb;
      a2.addClass = Ya;
      a2.contains = ja;
      a2.rmClass = jb;
      a2.keyNames = Wa;
    })(U);
    U.version = "5.65.9";
    return U;
  });
})(codemirror$1);
var codemirrorExports = codemirror$1.exports;
const CodeMirror = /* @__PURE__ */ getDefaultExportFromCjs(codemirrorExports);
(function(module2, exports2) {
  (function(v) {
    v(codemirrorExports);
  })(function(v) {
    v.defineMode("javascript", function(Ua, A) {
      var p, w, f;
      function u(a2, b, d2) {
        V = a2;
        ca = d2;
        return b;
      }
      function I(a2, b) {
        var d2 = a2.next();
        if ('"' == d2 || "'" == d2)
          return b.tokenize = Va(d2), b.tokenize(a2, b);
        if ("." == d2 && a2.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/))
          return u("number", "number");
        if ("." == d2 && a2.match(".."))
          return u("spread", "meta");
        if (/[\[\]{}\(\),;:\.]/.test(d2))
          return u(d2);
        if ("=" == d2 && a2.eat(">"))
          return u("=>", "operator");
        if ("0" == d2 && a2.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/))
          return u("number", "number");
        if (/\d/.test(d2))
          return a2.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), u("number", "number");
        if ("/" == d2) {
          if (a2.eat("*"))
            return b.tokenize = da, da(a2, b);
          if (a2.eat("/"))
            return a2.skipToEnd(), u("comment", "comment");
          if (Aa(a2, b, 1)) {
            a:
              for (var e = b = false; null != (d2 = a2.next()); ) {
                if (!b) {
                  if ("/" == d2 && !e)
                    break a;
                  "[" == d2 ? e = true : e && "]" == d2 && (e = false);
                }
                b = !b && "\\" == d2;
              }
            a2.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
            return u("regexp", "string-2");
          }
          a2.eat("=");
          return u("operator", "operator", a2.current());
        }
        if ("`" == d2)
          return b.tokenize = W, W(a2, b);
        if ("#" == d2 && "!" == a2.peek())
          return a2.skipToEnd(), u("meta", "meta");
        if ("#" == d2 && a2.eatWhile(ea))
          return u("variable", "property");
        if ("<" == d2 && a2.match("!--") || "-" == d2 && a2.match("->") && !/\S/.test(a2.string.slice(0, a2.start)))
          return a2.skipToEnd(), u("comment", "comment");
        if (Ba.test(d2))
          return ">" == d2 && b.lexical && ">" == b.lexical.type || (a2.eat("=") ? "!" != d2 && "=" != d2 || a2.eat("=") : /[<>*+\-|&?]/.test(d2) && (a2.eat(d2), ">" == d2 && a2.eat(d2))), "?" == d2 && a2.eat(".") ? u(".") : u("operator", "operator", a2.current());
        if (ea.test(d2)) {
          a2.eatWhile(ea);
          d2 = a2.current();
          if ("." != b.lastType) {
            if (Ca.propertyIsEnumerable(d2))
              return a2 = Ca[d2], u(a2.type, a2.style, d2);
            if ("async" == d2 && a2.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
              return u("async", "keyword", d2);
          }
          return u("variable", "variable", d2);
        }
      }
      function Va(a2) {
        return function(b, d2) {
          var e = false, h2;
          if (fa && "@" == b.peek() && b.match(Wa))
            return d2.tokenize = I, u("jsonld-keyword", "meta");
          for (; null != (h2 = b.next()) && (h2 != a2 || e); )
            e = !e && "\\" == h2;
          e || (d2.tokenize = I);
          return u("string", "string");
        };
      }
      function da(a2, b) {
        for (var d2 = false, e; e = a2.next(); ) {
          if ("/" == e && d2) {
            b.tokenize = I;
            break;
          }
          d2 = "*" == e;
        }
        return u("comment", "comment");
      }
      function W(a2, b) {
        for (var d2 = false, e; null != (e = a2.next()); ) {
          if (!d2 && ("`" == e || "$" == e && a2.eat("{"))) {
            b.tokenize = I;
            break;
          }
          d2 = !d2 && "\\" == e;
        }
        return u("quasi", "string-2", a2.current());
      }
      function qa(a2, b) {
        b.fatArrowAt && (b.fatArrowAt = null);
        var d2 = a2.string.indexOf("=>", a2.start);
        if (!(0 > d2)) {
          if (r) {
            var e = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(a2.string.slice(a2.start, d2));
            e && (d2 = e.index);
          }
          e = 0;
          var h2 = false;
          for (--d2; 0 <= d2; --d2) {
            var m2 = a2.string.charAt(d2), y2 = "([{}])".indexOf(m2);
            if (0 <= y2 && 3 > y2) {
              if (!e) {
                ++d2;
                break;
              }
              if (0 == --e) {
                "(" == m2 && (h2 = true);
                break;
              }
            } else if (3 <= y2 && 6 > y2)
              ++e;
            else if (ea.test(m2))
              h2 = true;
            else if (/["'\/`]/.test(m2))
              for (; ; --d2) {
                if (0 == d2)
                  return;
                if (a2.string.charAt(d2 - 1) == m2 && "\\" != a2.string.charAt(d2 - 2)) {
                  d2--;
                  break;
                }
              }
            else if (h2 && !e) {
              ++d2;
              break;
            }
          }
          h2 && !e && (b.fatArrowAt = d2);
        }
      }
      function Da(a2, b, d2, e, h2, m2) {
        this.indented = a2;
        this.column = b;
        this.type = d2;
        this.prev = h2;
        this.info = m2;
        null != e && (this.align = e);
      }
      function Ea(a2, b, d2, e, h2) {
        var m2 = a2.cc;
        p = a2;
        w = h2;
        f = null;
        ra = m2;
        X = b;
        a2.lexical.hasOwnProperty("align") || (a2.lexical.align = true);
        for (; ; )
          if ((m2.length ? m2.pop() : J ? t : x2)(d2, e)) {
            for (; m2.length && m2[m2.length - 1].lex; )
              m2.pop()();
            if (f)
              return f;
            if (d2 = "variable" == d2)
              a:
                if (Fa) {
                  for (d2 = a2.localVars; d2; d2 = d2.next)
                    if (d2.name == e) {
                      d2 = true;
                      break a;
                    }
                  for (a2 = a2.context; a2; a2 = a2.prev)
                    for (d2 = a2.vars; d2; d2 = d2.next)
                      if (d2.name == e) {
                        d2 = true;
                        break a;
                      }
                  d2 = void 0;
                } else
                  d2 = false;
            return d2 ? "variable-2" : b;
          }
      }
      function k() {
        for (var a2 = arguments.length - 1; 0 <= a2; a2--)
          ra.push(arguments[a2]);
      }
      function c() {
        k.apply(null, arguments);
        return true;
      }
      function sa(a2, b) {
        for (; b; b = b.next)
          if (b.name == a2)
            return true;
        return false;
      }
      function O(a2) {
        var b = p;
        f = "def";
        if (Fa) {
          if (b.context) {
            if ("var" == b.lexical.info && b.context && b.context.block) {
              var d2 = Ga(a2, b.context);
              if (null != d2) {
                b.context = d2;
                return;
              }
            } else if (!sa(a2, b.localVars)) {
              b.localVars = new Y(a2, b.localVars);
              return;
            }
          }
          A.globalVars && !sa(a2, b.globalVars) && (b.globalVars = new Y(a2, b.globalVars));
        }
      }
      function Ga(a2, b) {
        return b ? b.block ? (a2 = Ga(
          a2,
          b.prev
        )) ? a2 == b.prev ? b : new Z(a2, b.vars, true) : null : sa(a2, b.vars) ? b : new Z(b.prev, new Y(a2, b.vars), false) : null;
      }
      function ha(a2) {
        return "public" == a2 || "private" == a2 || "protected" == a2 || "abstract" == a2 || "readonly" == a2;
      }
      function Z(a2, b, d2) {
        this.prev = a2;
        this.vars = b;
        this.block = d2;
      }
      function Y(a2, b) {
        this.name = a2;
        this.next = b;
      }
      function K() {
        p.context = new Z(p.context, p.localVars, false);
        p.localVars = Xa;
      }
      function ia() {
        p.context = new Z(p.context, p.localVars, true);
        p.localVars = null;
      }
      function C() {
        p.localVars = p.context.vars;
        p.context = p.context.prev;
      }
      function l(a2, b) {
        var d2 = function() {
          var e = p, h2 = e.indented;
          if ("stat" == e.lexical.type)
            h2 = e.lexical.indented;
          else
            for (var m2 = e.lexical; m2 && ")" == m2.type && m2.align; m2 = m2.prev)
              h2 = m2.indented;
          e.lexical = new Da(h2, w.column(), a2, null, e.lexical, b);
        };
        d2.lex = true;
        return d2;
      }
      function g() {
        var a2 = p;
        a2.lexical.prev && (")" == a2.lexical.type && (a2.indented = a2.lexical.indented), a2.lexical = a2.lexical.prev);
      }
      function n(a2) {
        function b(d2) {
          return d2 == a2 ? c() : ";" == a2 || "}" == d2 || ")" == d2 || "]" == d2 ? k() : c(b);
        }
        return b;
      }
      function x2(a2, b) {
        return "var" == a2 ? c(l("vardef", b), ta, n(";"), g) : "keyword a" == a2 ? c(l("form"), ua, x2, g) : "keyword b" == a2 ? c(l("form"), x2, g) : "keyword d" == a2 ? w.match(/^\s*$/, false) ? c() : c(l("stat"), P, n(";"), g) : "debugger" == a2 ? c(n(";")) : "{" == a2 ? c(l("}"), ia, ja, g, C) : ";" == a2 ? c() : "if" == a2 ? ("else" == p.lexical.info && p.cc[p.cc.length - 1] == g && p.cc.pop()(), c(l("form"), ua, x2, g, Ha)) : "function" == a2 ? c(G) : "for" == a2 ? c(l("form"), ia, Ia, x2, C, g) : "class" == a2 || r && "interface" == b ? (f = "keyword", c(l("form", "class" == a2 ? a2 : b), Ja, g)) : "variable" == a2 ? r && "declare" == b ? (f = "keyword", c(x2)) : r && ("module" == b || "enum" == b || "type" == b) && w.match(
          /^\s*\w/,
          false
        ) ? (f = "keyword", "enum" == b ? c(Ka) : "type" == b ? c(La, n("operator"), q, n(";")) : c(l("form"), D, n("{"), l("}"), ja, g, g)) : r && "namespace" == b ? (f = "keyword", c(l("form"), t, x2, g)) : r && "abstract" == b ? (f = "keyword", c(x2)) : c(l("stat"), Ya) : "switch" == a2 ? c(l("form"), ua, n("{"), l("}", "switch"), ia, ja, g, g, C) : "case" == a2 ? c(t, n(":")) : "default" == a2 ? c(n(":")) : "catch" == a2 ? c(l("form"), K, Za, x2, g, C) : "export" == a2 ? c(l("stat"), $a, g) : "import" == a2 ? c(l("stat"), ab, g) : "async" == a2 ? c(x2) : "@" == b ? c(t, x2) : k(l("stat"), t, n(";"), g);
      }
      function Za(a2) {
        if ("(" == a2)
          return c(
            L,
            n(")")
          );
      }
      function t(a2, b) {
        return Ma(a2, b, false);
      }
      function B(a2, b) {
        return Ma(a2, b, true);
      }
      function ua(a2) {
        return "(" != a2 ? k() : c(l(")"), P, n(")"), g);
      }
      function Ma(a2, b, d2) {
        if (p.fatArrowAt == w.start) {
          var e = d2 ? Na : Oa;
          if ("(" == a2)
            return c(K, l(")"), z(L, ")"), g, n("=>"), e, C);
          if ("variable" == a2)
            return k(K, D, n("=>"), e, C);
        }
        e = d2 ? Q : M;
        return bb.hasOwnProperty(a2) ? c(e) : "function" == a2 ? c(G, e) : "class" == a2 || r && "interface" == b ? (f = "keyword", c(l("form"), cb, g)) : "keyword c" == a2 || "async" == a2 ? c(d2 ? B : t) : "(" == a2 ? c(l(")"), P, n(")"), g, e) : "operator" == a2 || "spread" == a2 ? c(d2 ? B : t) : "[" == a2 ? c(l("]"), db, g, e) : "{" == a2 ? aa(ka, "}", null, e) : "quasi" == a2 ? k(la, e) : "new" == a2 ? c(eb(d2)) : c();
      }
      function P(a2) {
        return a2.match(/[;\}\)\],]/) ? k() : k(t);
      }
      function M(a2, b) {
        return "," == a2 ? c(P) : Q(a2, b, false);
      }
      function Q(a2, b, d2) {
        var e = 0 == d2 ? M : Q, h2 = 0 == d2 ? t : B;
        if ("=>" == a2)
          return c(K, d2 ? Na : Oa, C);
        if ("operator" == a2)
          return /\+\+|--/.test(b) || r && "!" == b ? c(e) : r && "<" == b && w.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false) ? c(l(">"), z(q, ">"), g, e) : "?" == b ? c(t, n(":"), h2) : c(h2);
        if ("quasi" == a2)
          return k(la, e);
        if (";" != a2) {
          if ("(" == a2)
            return aa(B, ")", "call", e);
          if ("." == a2)
            return c(fb, e);
          if ("[" == a2)
            return c(l("]"), P, n("]"), g, e);
          if (r && "as" == b)
            return f = "keyword", c(q, e);
          if ("regexp" == a2)
            return p.lastType = f = "operator", w.backUp(w.pos - w.start - 1), c(h2);
        }
      }
      function la(a2, b) {
        return "quasi" != a2 ? k() : "${" != b.slice(b.length - 2) ? c(la) : c(P, gb);
      }
      function gb(a2) {
        if ("}" == a2)
          return f = "string-2", p.tokenize = W, c(la);
      }
      function Oa(a2) {
        qa(w, p);
        return k("{" == a2 ? x2 : t);
      }
      function Na(a2) {
        qa(w, p);
        return k("{" == a2 ? x2 : B);
      }
      function eb(a2) {
        return function(b) {
          return "." == b ? c(a2 ? hb : ib) : "variable" == b && r ? c(jb, a2 ? Q : M) : k(a2 ? B : t);
        };
      }
      function ib(a2, b) {
        if ("target" == b)
          return f = "keyword", c(M);
      }
      function hb(a2, b) {
        if ("target" == b)
          return f = "keyword", c(Q);
      }
      function Ya(a2) {
        return ":" == a2 ? c(g, x2) : k(M, n(";"), g);
      }
      function fb(a2) {
        if ("variable" == a2)
          return f = "property", c();
      }
      function ka(a2, b) {
        if ("async" == a2)
          return f = "property", c(ka);
        if ("variable" == a2 || "keyword" == X) {
          f = "property";
          if ("get" == b || "set" == b)
            return c(kb);
          var d2;
          r && p.fatArrowAt == w.start && (d2 = w.match(/^\s*:\s*/, false)) && (p.fatArrowAt = w.pos + d2[0].length);
          return c(N);
        }
        if ("number" == a2 || "string" == a2)
          return f = fa ? "property" : X + " property", c(N);
        if ("jsonld-keyword" == a2)
          return c(N);
        if (r && ha(b))
          return f = "keyword", c(ka);
        if ("[" == a2)
          return c(t, R2, n("]"), N);
        if ("spread" == a2)
          return c(B, N);
        if ("*" == b)
          return f = "keyword", c(ka);
        if (":" == a2)
          return k(N);
      }
      function kb(a2) {
        if ("variable" != a2)
          return k(N);
        f = "property";
        return c(G);
      }
      function N(a2) {
        if (":" == a2)
          return c(B);
        if ("(" == a2)
          return k(G);
      }
      function z(a2, b, d2) {
        function e(h2, m2) {
          return (d2 ? -1 < d2.indexOf(h2) : "," == h2) ? (h2 = p.lexical, "call" == h2.info && (h2.pos = (h2.pos || 0) + 1), c(function(y2, va) {
            return y2 == b || va == b ? k() : k(a2);
          }, e)) : h2 == b || m2 == b ? c() : d2 && -1 < d2.indexOf(";") ? k(a2) : c(n(b));
        }
        return function(h2, m2) {
          return h2 == b || m2 == b ? c() : k(a2, e);
        };
      }
      function aa(a2, b, d2) {
        for (var e = 3; e < arguments.length; e++)
          ra.push(arguments[e]);
        return c(l(b, d2), z(a2, b), g);
      }
      function ja(a2) {
        return "}" == a2 ? c() : k(x2, ja);
      }
      function R2(a2, b) {
        if (r) {
          if (":" == a2)
            return c(q);
          if ("?" == b)
            return c(R2);
        }
      }
      function lb(a2, b) {
        if (r && (":" == a2 || "in" == b))
          return c(q);
      }
      function Pa(a2) {
        if (r && ":" == a2)
          return w.match(/^\s*\w+\s+is\b/, false) ? c(t, mb, q) : c(q);
      }
      function mb(a2, b) {
        if ("is" == b)
          return f = "keyword", c();
      }
      function q(a2, b) {
        if ("keyof" == b || "typeof" == b || "infer" == b || "readonly" == b)
          return f = "keyword", c("typeof" == b ? B : q);
        if ("variable" == a2 || "void" == b)
          return f = "type", c(E);
        if ("|" == b || "&" == b)
          return c(q);
        if ("string" == a2 || "number" == a2 || "atom" == a2)
          return c(E);
        if ("[" == a2)
          return c(l("]"), z(q, "]", ","), g, E);
        if ("{" == a2)
          return c(l("}"), wa, g, E);
        if ("(" == a2)
          return c(z(xa, ")"), nb, E);
        if ("<" == a2)
          return c(z(q, ">"), q);
        if ("quasi" == a2)
          return k(ya, E);
      }
      function nb(a2) {
        if ("=>" == a2)
          return c(q);
      }
      function wa(a2) {
        return a2.match(/[\}\)\]]/) ? c() : "," == a2 || ";" == a2 ? c(wa) : k(ba, wa);
      }
      function ba(a2, b) {
        if ("variable" == a2 || "keyword" == X)
          return f = "property", c(ba);
        if ("?" == b || "number" == a2 || "string" == a2)
          return c(ba);
        if (":" == a2)
          return c(q);
        if ("[" == a2)
          return c(n("variable"), lb, n("]"), ba);
        if ("(" == a2)
          return k(S, ba);
        if (!a2.match(/[;\}\)\],]/))
          return c();
      }
      function ya(a2, b) {
        return "quasi" != a2 ? k() : "${" != b.slice(b.length - 2) ? c(ya) : c(q, ob);
      }
      function ob(a2) {
        if ("}" == a2)
          return f = "string-2", p.tokenize = W, c(ya);
      }
      function xa(a2, b) {
        return "variable" == a2 && w.match(/^\s*[?:]/, false) || "?" == b ? c(xa) : ":" == a2 ? c(q) : "spread" == a2 ? c(xa) : k(q);
      }
      function E(a2, b) {
        if ("<" == b)
          return c(l(">"), z(q, ">"), g, E);
        if ("|" == b || "." == a2 || "&" == b)
          return c(q);
        if ("[" == a2)
          return c(q, n("]"), E);
        if ("extends" == b || "implements" == b)
          return f = "keyword", c(q);
        if ("?" == b)
          return c(q, n(":"), q);
      }
      function jb(a2, b) {
        if ("<" == b)
          return c(l(">"), z(q, ">"), g, E);
      }
      function ma() {
        return k(q, pb);
      }
      function pb(a2, b) {
        if ("=" == b)
          return c(q);
      }
      function ta(a2, b) {
        return "enum" == b ? (f = "keyword", c(Ka)) : k(D, R2, H, qb);
      }
      function D(a2, b) {
        if (r && ha(b))
          return f = "keyword", c(D);
        if ("variable" == a2)
          return O(b), c();
        if ("spread" == a2)
          return c(D);
        if ("[" == a2)
          return aa(rb, "]");
        if ("{" == a2)
          return aa(Qa, "}");
      }
      function Qa(a2, b) {
        if ("variable" == a2 && !w.match(/^\s*:/, false))
          return O(b), c(H);
        "variable" == a2 && (f = "property");
        return "spread" == a2 ? c(D) : "}" == a2 ? k() : "[" == a2 ? c(t, n("]"), n(":"), Qa) : c(n(":"), D, H);
      }
      function rb() {
        return k(D, H);
      }
      function H(a2, b) {
        if ("=" == b)
          return c(B);
      }
      function qb(a2) {
        if ("," == a2)
          return c(ta);
      }
      function Ha(a2, b) {
        if ("keyword b" == a2 && "else" == b)
          return c(l("form", "else"), x2, g);
      }
      function Ia(a2, b) {
        if ("await" == b)
          return c(Ia);
        if ("(" == a2)
          return c(
            l(")"),
            sb,
            g
          );
      }
      function sb(a2) {
        return "var" == a2 ? c(ta, T) : "variable" == a2 ? c(T) : k(T);
      }
      function T(a2, b) {
        return ")" == a2 ? c() : ";" == a2 ? c(T) : "in" == b || "of" == b ? (f = "keyword", c(t, T)) : k(t, T);
      }
      function G(a2, b) {
        if ("*" == b)
          return f = "keyword", c(G);
        if ("variable" == a2)
          return O(b), c(G);
        if ("(" == a2)
          return c(K, l(")"), z(L, ")"), g, Pa, x2, C);
        if (r && "<" == b)
          return c(l(">"), z(ma, ">"), g, G);
      }
      function S(a2, b) {
        if ("*" == b)
          return f = "keyword", c(S);
        if ("variable" == a2)
          return O(b), c(S);
        if ("(" == a2)
          return c(K, l(")"), z(L, ")"), g, Pa, C);
        if (r && "<" == b)
          return c(
            l(">"),
            z(ma, ">"),
            g,
            S
          );
      }
      function La(a2, b) {
        if ("keyword" == a2 || "variable" == a2)
          return f = "type", c(La);
        if ("<" == b)
          return c(l(">"), z(ma, ">"), g);
      }
      function L(a2, b) {
        "@" == b && c(t, L);
        return "spread" == a2 ? c(L) : r && ha(b) ? (f = "keyword", c(L)) : r && "this" == a2 ? c(R2, H) : k(D, R2, H);
      }
      function cb(a2, b) {
        return "variable" == a2 ? Ja(a2, b) : na(a2, b);
      }
      function Ja(a2, b) {
        if ("variable" == a2)
          return O(b), c(na);
      }
      function na(a2, b) {
        if ("<" == b)
          return c(l(">"), z(ma, ">"), g, na);
        if ("extends" == b || "implements" == b || r && "," == a2)
          return "implements" == b && (f = "keyword"), c(r ? q : t, na);
        if ("{" == a2)
          return c(
            l("}"),
            F,
            g
          );
      }
      function F(a2, b) {
        if ("async" == a2 || "variable" == a2 && ("static" == b || "get" == b || "set" == b || r && ha(b)) && w.match(/^\s+[\w$\xa1-\uffff]/, false))
          return f = "keyword", c(F);
        if ("variable" == a2 || "keyword" == X)
          return f = "property", c(oa, F);
        if ("number" == a2 || "string" == a2)
          return c(oa, F);
        if ("[" == a2)
          return c(t, R2, n("]"), oa, F);
        if ("*" == b)
          return f = "keyword", c(F);
        if (r && "(" == a2)
          return k(S, F);
        if (";" == a2 || "," == a2)
          return c(F);
        if ("}" == a2)
          return c();
        if ("@" == b)
          return c(t, F);
      }
      function oa(a2, b) {
        if ("!" == b || "?" == b)
          return c(oa);
        if (":" == a2)
          return c(q, H);
        if ("=" == b)
          return c(B);
        a2 = p.lexical.prev;
        return k(a2 && "interface" == a2.info ? S : G);
      }
      function $a(a2, b) {
        return "*" == b ? (f = "keyword", c(za, n(";"))) : "default" == b ? (f = "keyword", c(t, n(";"))) : "{" == a2 ? c(z(Ra, "}"), za, n(";")) : k(x2);
      }
      function Ra(a2, b) {
        if ("as" == b)
          return f = "keyword", c(n("variable"));
        if ("variable" == a2)
          return k(B, Ra);
      }
      function ab(a2) {
        return "string" == a2 ? c() : "(" == a2 ? k(t) : "." == a2 ? k(M) : k(pa, Sa, za);
      }
      function pa(a2, b) {
        if ("{" == a2)
          return aa(pa, "}");
        "variable" == a2 && O(b);
        "*" == b && (f = "keyword");
        return c(tb);
      }
      function Sa(a2) {
        if ("," == a2)
          return c(
            pa,
            Sa
          );
      }
      function tb(a2, b) {
        if ("as" == b)
          return f = "keyword", c(pa);
      }
      function za(a2, b) {
        if ("from" == b)
          return f = "keyword", c(t);
      }
      function db(a2) {
        return "]" == a2 ? c() : k(z(B, "]"));
      }
      function Ka() {
        return k(l("form"), D, n("{"), l("}"), z(ub, "}"), g, g);
      }
      function ub() {
        return k(D, H);
      }
      function Aa(a2, b, d2) {
        return b.tokenize == I && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(b.lastType) || "quasi" == b.lastType && /\{\s*$/.test(a2.string.slice(0, a2.pos - (d2 || 0)));
      }
      var U = Ua.indentUnit, Ta = A.statementIndent, fa = A.jsonld, J = A.json || fa, Fa = false !== A.trackScope, r = A.typescript, ea = A.wordCharacters || /[\w$\xa1-\uffff]/, Ca = function() {
        function a2(va) {
          return { type: va, style: "keyword" };
        }
        var b = a2("keyword a"), d2 = a2("keyword b"), e = a2("keyword c"), h2 = a2("keyword d"), m2 = a2("operator"), y2 = { type: "atom", style: "atom" };
        return {
          "if": a2("if"),
          "while": b,
          "with": b,
          "else": d2,
          "do": d2,
          "try": d2,
          "finally": d2,
          "return": h2,
          "break": h2,
          "continue": h2,
          "new": a2("new"),
          "delete": e,
          "void": e,
          "throw": e,
          "debugger": a2("debugger"),
          "var": a2("var"),
          "const": a2("var"),
          let: a2("var"),
          "function": a2("function"),
          "catch": a2("catch"),
          "for": a2("for"),
          "switch": a2("switch"),
          "case": a2("case"),
          "default": a2("default"),
          "in": m2,
          "typeof": m2,
          "instanceof": m2,
          "true": y2,
          "false": y2,
          "null": y2,
          undefined: y2,
          NaN: y2,
          Infinity: y2,
          "this": a2("this"),
          "class": a2("class"),
          "super": a2("atom"),
          yield: e,
          "export": a2("export"),
          "import": a2("import"),
          "extends": e,
          await: e
        };
      }(), Ba = /[+\-*&%=<>!?|~^@]/, Wa = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/, V, ca, bb = {
        atom: true,
        number: true,
        variable: true,
        string: true,
        regexp: true,
        "this": true,
        "import": true,
        "jsonld-keyword": true
      };
      var ra = f = p = null;
      var X = w = void 0;
      var Xa = new Y("this", new Y("arguments", null));
      K.lex = ia.lex = true;
      C.lex = true;
      g.lex = true;
      return { startState: function(a2) {
        a2 = { tokenize: I, lastType: "sof", cc: [], lexical: new Da((a2 || 0) - U, 0, "block", false), localVars: A.localVars, context: A.localVars && new Z(null, null, false), indented: a2 || 0 };
        A.globalVars && "object" == typeof A.globalVars && (a2.globalVars = A.globalVars);
        return a2;
      }, token: function(a2, b) {
        a2.sol() && (b.lexical.hasOwnProperty("align") || (b.lexical.align = false), b.indented = a2.indentation(), qa(a2, b));
        if (b.tokenize != da && a2.eatSpace())
          return null;
        var d2 = b.tokenize(a2, b);
        if ("comment" == V)
          return d2;
        b.lastType = "operator" != V || "++" != ca && "--" != ca ? V : "incdec";
        return Ea(b, d2, V, ca, a2);
      }, indent: function(a2, b) {
        if (a2.tokenize == da || a2.tokenize == W)
          return v.Pass;
        if (a2.tokenize != I)
          return 0;
        var d2 = b && b.charAt(0), e = a2.lexical, h2;
        if (!/^\s*else\b/.test(b))
          for (var m2 = a2.cc.length - 1; 0 <= m2; --m2) {
            var y2 = a2.cc[m2];
            if (y2 == g)
              e = e.prev;
            else if (y2 != Ha && y2 != C)
              break;
          }
        for (; !("stat" != e.type && "form" != e.type || "}" != d2 && (!(h2 = a2.cc[a2.cc.length - 1]) || h2 != M && h2 != Q || /^[,\.=+\-*:?[\(]/.test(b))); )
          e = e.prev;
        Ta && ")" == e.type && "stat" == e.prev.type && (e = e.prev);
        h2 = e.type;
        m2 = d2 == h2;
        return "vardef" == h2 ? e.indented + ("operator" == a2.lastType || "," == a2.lastType ? e.info.length + 1 : 0) : "form" == h2 && "{" == d2 ? e.indented : "form" == h2 ? e.indented + U : "stat" == h2 ? (d2 = e.indented, a2 = "operator" == a2.lastType || "," == a2.lastType || Ba.test(b.charAt(0)) || /[,.]/.test(b.charAt(0)), d2 + (a2 ? Ta || U : 0)) : "switch" != e.info || m2 || 0 == A.doubleIndentSwitch ? e.align ? e.column + (m2 ? 0 : 1) : e.indented + (m2 ? 0 : U) : e.indented + (/^(?:case|default)\b/.test(b) ? U : 2 * U);
      }, electricInput: /^\s*(?:case .*?:|default:|\{|\})$/, blockCommentStart: J ? null : "/*", blockCommentEnd: J ? null : "*/", blockCommentContinue: J ? null : " * ", lineComment: J ? null : "//", fold: "brace", closeBrackets: "()[]{}''\"\"``", helperType: J ? "json" : "javascript", jsonldMode: fa, jsonMode: J, expressionAllowed: Aa, skipExpression: function(a2) {
        Ea(a2, "atom", "atom", "true", new v.StringStream("", 2, null));
      } };
    });
    v.registerHelper("wordChars", "javascript", /[\w$]/);
    v.defineMIME("text/javascript", "javascript");
    v.defineMIME(
      "text/ecmascript",
      "javascript"
    );
    v.defineMIME("application/javascript", "javascript");
    v.defineMIME("application/x-javascript", "javascript");
    v.defineMIME("application/ecmascript", "javascript");
    v.defineMIME("application/json", { name: "javascript", json: true });
    v.defineMIME("application/x-json", { name: "javascript", json: true });
    v.defineMIME("application/manifest+json", { name: "javascript", json: true });
    v.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
    v.defineMIME("text/typescript", { name: "javascript", typescript: true });
    v.defineMIME(
      "application/typescript",
      { name: "javascript", typescript: true }
    );
  });
})();
(function(module2, exports2) {
  (function(m2) {
    m2(codemirrorExports);
  })(function(m2) {
    function q(a2, b) {
      for (var l = 0, e = a2.length; l < e; ++l)
        b(a2[l]);
    }
    function t(a2, b, l, e) {
      var c = a2.getCursor(), d2 = l(a2, c);
      if (!/\b(?:string|comment)\b/.test(d2.type)) {
        var g = m2.innerMode(a2.getMode(), d2.state);
        if ("json" !== g.mode.helperType) {
          d2.state = g.state;
          /^[\w$_]*$/.test(d2.string) ? d2.end > c.ch && (d2.end = c.ch, d2.string = d2.string.slice(
            0,
            c.ch - d2.start
          )) : d2 = { start: c.ch, end: c.ch, string: "", state: d2.state, type: "." == d2.string ? "property" : null };
          for (g = d2; "property" == g.type; ) {
            g = l(a2, r(c.line, g.start));
            if ("." != g.string)
              return;
            g = l(a2, r(c.line, g.start));
            if (!p)
              var p = [];
            p.push(g);
          }
          return { list: u(d2, p, b, e), from: r(c.line, d2.start), to: r(c.line, d2.end) };
        }
      }
    }
    function v(a2, b) {
      a2 = a2.getTokenAt(b);
      b.ch == a2.start + 1 && "." == a2.string.charAt(0) ? (a2.end = a2.start, a2.string = ".", a2.type = "property") : /^\.[\w$_]*$/.test(a2.string) && (a2.type = "property", a2.start++, a2.string = a2.string.replace(
        /\./,
        ""
      ));
      return a2;
    }
    function u(a2, b, l, e) {
      function c(h2) {
        var k;
        if (k = 0 == h2.lastIndexOf(p, 0)) {
          a:
            if (Array.prototype.indexOf)
              k = -1 != g.indexOf(h2);
            else {
              for (k = g.length; k--; )
                if (g[k] === h2) {
                  k = true;
                  break a;
                }
              k = false;
            }
          k = !k;
        }
        k && g.push(h2);
      }
      function d2(h2) {
        "string" == typeof h2 ? q(w, c) : h2 instanceof Array ? q(x2, c) : h2 instanceof Function && q(y2, c);
        if (Object.getOwnPropertyNames && Object.getPrototypeOf)
          for (; h2; h2 = Object.getPrototypeOf(h2))
            Object.getOwnPropertyNames(h2).forEach(c);
        else
          for (var k in h2)
            c(k);
      }
      var g = [], p = a2.string, n = e && e.globalScope || window;
      if (b && b.length) {
        a2 = b.pop();
        var f;
        a2.type && 0 === a2.type.indexOf("variable") ? (e && e.additionalContext && (f = e.additionalContext[a2.string]), e && false === e.useGlobalScope || (f = f || n[a2.string])) : "string" == a2.type ? f = "" : "atom" == a2.type ? f = 1 : "function" == a2.type && (null == n.jQuery || "$" != a2.string && "jQuery" != a2.string || "function" != typeof n.jQuery ? null != n._ && "_" == a2.string && "function" == typeof n._ && (f = n._()) : f = n.jQuery());
        for (; null != f && b.length; )
          f = f[b.pop().string];
        null != f && d2(f);
      } else {
        for (b = a2.state.localVars; b; b = b.next)
          c(b.name);
        for (f = a2.state.context; f; f = f.prev)
          for (b = f.vars; b; b = b.next)
            c(b.name);
        for (b = a2.state.globalVars; b; b = b.next)
          c(b.name);
        if (e && null != e.additionalContext)
          for (var z in e.additionalContext)
            c(z);
        e && false === e.useGlobalScope || d2(n);
        q(l, c);
      }
      return g;
    }
    var r = m2.Pos;
    m2.registerHelper("hint", "javascript", function(a2, b) {
      return t(a2, A, function(l, e) {
        return l.getTokenAt(e);
      }, b);
    });
    m2.registerHelper("hint", "coffeescript", function(a2, b) {
      return t(a2, B, v, b);
    });
    var w = "charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight toUpperCase toLowerCase split concat match replace search".split(" "), x2 = "length concat join splice push pop shift unshift slice reverse sort indexOf lastIndexOf every some filter forEach map reduce reduceRight ".split(" "), y2 = ["prototype", "apply", "call", "bind"], A = "break case catch class const continue debugger default delete do else export extends false finally for function if in import instanceof new null return super switch this throw true try typeof var void while with yield".split(" "), B = "and break catch class continue delete do else extends false finally for if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes".split(" ");
  });
})();
(function(module2, exports2) {
  (function(h2) {
    h2(codemirrorExports);
  })(function(h2) {
    function B(a2, b) {
      this.cm = a2;
      this.options = b;
      this.widget = null;
      this.tick = this.debounce = 0;
      this.startPos = this.cm.getCursor("start");
      this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
      if (this.options.updateOnCursorActivity) {
        var c = this;
        a2.on("cursorActivity", this.activityFunc = function() {
          c.cursorActivity();
        });
      }
    }
    function K(a2, b) {
      function c(r, g) {
        var m2 = "string" != typeof g ? function(k) {
          return g(k, b);
        } : d2.hasOwnProperty(g) ? d2[g] : g;
        p[r] = m2;
      }
      var d2 = { Up: function() {
        b.moveFocus(-1);
      }, Down: function() {
        b.moveFocus(1);
      }, PageUp: function() {
        b.moveFocus(-b.menuSize() + 1, true);
      }, PageDown: function() {
        b.moveFocus(b.menuSize() - 1, true);
      }, Home: function() {
        b.setFocus(0);
      }, End: function() {
        b.setFocus(b.length - 1);
      }, Enter: b.pick, Tab: b.pick, Esc: b.close };
      /Mac/.test(navigator.platform) && (d2["Ctrl-P"] = function() {
        b.moveFocus(-1);
      }, d2["Ctrl-N"] = function() {
        b.moveFocus(1);
      });
      var e = a2.options.customKeys, p = e ? {} : d2;
      if (e)
        for (var f in e)
          e.hasOwnProperty(f) && c(f, e[f]);
      if (a2 = a2.options.extraKeys)
        for (f in a2)
          a2.hasOwnProperty(f) && c(f, a2[f]);
      return p;
    }
    function C(a2, b) {
      for (; b && b != a2; ) {
        if ("LI" === b.nodeName.toUpperCase() && b.parentNode == a2)
          return b;
        b = b.parentNode;
      }
    }
    function D(a2, b) {
      this.id = "cm-complete-" + Math.floor(Math.random(1e6));
      this.completion = a2;
      this.data = b;
      this.picked = false;
      var c = this, d2 = a2.cm, e = d2.getInputField().ownerDocument, p = e.defaultView || e.parentWindow, f = this.hints = e.createElement("ul");
      f.setAttribute("role", "listbox");
      f.setAttribute("aria-expanded", "true");
      f.id = this.id;
      f.className = "CodeMirror-hints " + a2.cm.options.theme;
      this.selectedHint = b.selectedHint || 0;
      for (var r = b.list, g = 0; g < r.length; ++g) {
        var m2 = f.appendChild(e.createElement("li")), k = r[g], q = "CodeMirror-hint" + (g != this.selectedHint ? "" : " CodeMirror-hint-active");
        null != k.className && (q = k.className + " " + q);
        m2.className = q;
        g == this.selectedHint && m2.setAttribute("aria-selected", "true");
        m2.id = this.id + "-" + g;
        m2.setAttribute("role", "option");
        k.render ? k.render(m2, b, k) : m2.appendChild(e.createTextNode(k.displayText || ("string" == typeof k ? k : k.text)));
        m2.hintId = g;
      }
      var n = a2.options.container || e.body;
      g = d2.cursorCoords(a2.options.alignWithWord ? b.from : null);
      var w = g.left, x2 = g.bottom, E = true;
      q = m2 = 0;
      if (n !== e.body) {
        k = -1 !== ["absolute", "relative", "fixed"].indexOf(p.getComputedStyle(n).position) ? n : n.offsetParent;
        q = k.getBoundingClientRect();
        var t = e.body.getBoundingClientRect();
        m2 = q.left - t.left - k.scrollLeft;
        q = q.top - t.top - k.scrollTop;
      }
      f.style.left = w - m2 + "px";
      f.style.top = x2 - q + "px";
      k = p.innerWidth || Math.max(e.body.offsetWidth, e.documentElement.offsetWidth);
      t = p.innerHeight || Math.max(e.body.offsetHeight, e.documentElement.offsetHeight);
      n.appendChild(f);
      d2.getInputField().setAttribute("aria-autocomplete", "list");
      d2.getInputField().setAttribute("aria-owns", this.id);
      d2.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint);
      n = a2.options.moveOnOverlap ? f.getBoundingClientRect() : new DOMRect();
      var F = a2.options.paddingForScrollbar ? f.scrollHeight > f.clientHeight + 1 : false, u;
      setTimeout(function() {
        u = d2.getScrollInfo();
      });
      if (0 < n.bottom - t) {
        var y2 = n.bottom - n.top, z = n.top - (g.bottom - g.top) - 2;
        t - n.top < z ? (y2 > z && (f.style.height = (y2 = z) + "px"), f.style.top = (x2 = g.top - y2) + q + "px", E = false) : f.style.height = t - n.top - 2 + "px";
      }
      q = n.right - k;
      F && (q += d2.display.nativeBarWidth);
      0 < q && (n.right - n.left > k && (f.style.width = k - 5 + "px", q -= n.right - n.left - k), f.style.left = (w = Math.max(g.left - q - m2, 0)) + "px");
      if (F)
        for (g = f.firstChild; g; g = g.nextSibling)
          g.style.paddingRight = d2.display.nativeBarWidth + "px";
      d2.addKeyMap(this.keyMap = K(a2, { moveFocus: function(l, v) {
        c.changeActive(c.selectedHint + l, v);
      }, setFocus: function(l) {
        c.changeActive(l);
      }, menuSize: function() {
        return c.screenAmount();
      }, length: r.length, close: function() {
        a2.close();
      }, pick: function() {
        c.pick();
      }, data: b }));
      if (a2.options.closeOnUnfocus) {
        var G;
        d2.on("blur", this.onBlur = function() {
          G = setTimeout(function() {
            a2.close();
          }, 100);
        });
        d2.on("focus", this.onFocus = function() {
          clearTimeout(G);
        });
      }
      d2.on("scroll", this.onScroll = function() {
        var l = d2.getScrollInfo(), v = d2.getWrapperElement().getBoundingClientRect();
        u || (u = d2.getScrollInfo());
        var H = x2 + u.top - l.top, A = H - (p.pageYOffset || (e.documentElement || e.body).scrollTop);
        E || (A += f.offsetHeight);
        if (A <= v.top || A >= v.bottom)
          return a2.close();
        f.style.top = H + "px";
        f.style.left = w + u.left - l.left + "px";
      });
      h2.on(f, "dblclick", function(l) {
        (l = C(f, l.target || l.srcElement)) && null != l.hintId && (c.changeActive(l.hintId), c.pick());
      });
      h2.on(f, "click", function(l) {
        (l = C(f, l.target || l.srcElement)) && null != l.hintId && (c.changeActive(l.hintId), a2.options.completeOnSingleClick && c.pick());
      });
      h2.on(
        f,
        "mousedown",
        function() {
          setTimeout(function() {
            d2.focus();
          }, 20);
        }
      );
      g = this.getSelectedHintRange();
      0 === g.from && 0 === g.to || this.scrollToActive();
      h2.signal(b, "select", r[this.selectedHint], f.childNodes[this.selectedHint]);
      return true;
    }
    function L(a2, b) {
      if (!a2.somethingSelected())
        return b;
      a2 = [];
      for (var c = 0; c < b.length; c++)
        b[c].supportsSelection && a2.push(b[c]);
      return a2;
    }
    function I(a2, b, c, d2) {
      a2.async ? a2(b, d2, c) : (a2 = a2(b, c)) && a2.then ? a2.then(d2) : d2(a2);
    }
    h2.showHint = function(a2, b, c) {
      if (!b)
        return a2.showHint(c);
      c && c.async && (b.async = true);
      b = { hint: b };
      if (c)
        for (var d2 in c)
          b[d2] = c[d2];
      return a2.showHint(b);
    };
    h2.defineExtension("showHint", function(a2) {
      var b = this.getCursor("start"), c = this.options.hintOptions, d2 = {}, e;
      for (e in J)
        d2[e] = J[e];
      if (c)
        for (e in c)
          void 0 !== c[e] && (d2[e] = c[e]);
      if (a2)
        for (e in a2)
          void 0 !== a2[e] && (d2[e] = a2[e]);
      d2.hint.resolve && (d2.hint = d2.hint.resolve(this, b));
      a2 = d2;
      b = this.listSelections();
      if (!(1 < b.length)) {
        if (this.somethingSelected()) {
          if (!a2.hint.supportsSelection)
            return;
          for (e = 0; e < b.length; e++)
            if (b[e].head.line != b[e].anchor.line)
              return;
        }
        this.state.completionActive && this.state.completionActive.close();
        b = this.state.completionActive = new B(this, a2);
        b.options.hint && (h2.signal(this, "startCompletion", this), b.update(true));
      }
    });
    h2.defineExtension("closeHint", function() {
      this.state.completionActive && this.state.completionActive.close();
    });
    var M = window.requestAnimationFrame || function(a2) {
      return setTimeout(a2, 1e3 / 60);
    }, N = window.cancelAnimationFrame || clearTimeout;
    B.prototype = { close: function() {
      this.active() && (this.tick = this.cm.state.completionActive = null, this.options.updateOnCursorActivity && this.cm.off(
        "cursorActivity",
        this.activityFunc
      ), this.widget && this.data && h2.signal(this.data, "close"), this.widget && this.widget.close(), h2.signal(this.cm, "endCompletion", this.cm));
    }, active: function() {
      return this.cm.state.completionActive == this;
    }, pick: function(a2, b) {
      var c = a2.list[b], d2 = this;
      this.cm.operation(function() {
        c.hint ? c.hint(d2.cm, a2, c) : d2.cm.replaceRange("string" == typeof c ? c : c.text, c.from || a2.from, c.to || a2.to, "complete");
        h2.signal(a2, "pick", c);
        d2.cm.scrollIntoView();
      });
      this.options.closeOnPick && this.close();
    }, cursorActivity: function() {
      this.debounce && (N(this.debounce), this.debounce = 0);
      var a2 = this.startPos;
      this.data && (a2 = this.data.from);
      var b = this.cm.getCursor(), c = this.cm.getLine(b.line);
      if (b.line != this.startPos.line || c.length - b.ch != this.startLen - this.startPos.ch || b.ch < a2.ch || this.cm.somethingSelected() || !b.ch || this.options.closeCharacters.test(c.charAt(b.ch - 1)))
        this.close();
      else {
        var d2 = this;
        this.debounce = M(function() {
          d2.update();
        });
        this.widget && this.widget.disable();
      }
    }, update: function(a2) {
      if (null != this.tick) {
        var b = this, c = ++this.tick;
        I(
          this.options.hint,
          this.cm,
          this.options,
          function(d2) {
            b.tick == c && b.finishUpdate(d2, a2);
          }
        );
      }
    }, finishUpdate: function(a2, b) {
      this.data && h2.signal(this.data, "update");
      b = this.widget && this.widget.picked || b && this.options.completeSingle;
      this.widget && this.widget.close();
      (this.data = a2) && a2.list.length && (b && 1 == a2.list.length ? this.pick(a2, 0) : (this.widget = new D(this, a2), h2.signal(a2, "shown")));
    } };
    D.prototype = { close: function() {
      if (this.completion.widget == this) {
        this.completion.widget = null;
        this.hints.parentNode && this.hints.parentNode.removeChild(this.hints);
        this.completion.cm.removeKeyMap(this.keyMap);
        var a2 = this.completion.cm.getInputField();
        a2.removeAttribute("aria-activedescendant");
        a2.removeAttribute("aria-owns");
        a2 = this.completion.cm;
        this.completion.options.closeOnUnfocus && (a2.off("blur", this.onBlur), a2.off("focus", this.onFocus));
        a2.off("scroll", this.onScroll);
      }
    }, disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var a2 = this;
      this.keyMap = { Enter: function() {
        a2.picked = true;
      } };
      this.completion.cm.addKeyMap(this.keyMap);
    }, pick: function() {
      this.completion.pick(
        this.data,
        this.selectedHint
      );
    }, changeActive: function(a2, b) {
      a2 >= this.data.list.length ? a2 = b ? this.data.list.length - 1 : 0 : 0 > a2 && (a2 = b ? 0 : this.data.list.length - 1);
      if (this.selectedHint != a2) {
        if (b = this.hints.childNodes[this.selectedHint])
          b.className = b.className.replace(" CodeMirror-hint-active", ""), b.removeAttribute("aria-selected");
        b = this.hints.childNodes[this.selectedHint = a2];
        b.className += " CodeMirror-hint-active";
        b.setAttribute("aria-selected", "true");
        this.completion.cm.getInputField().setAttribute(
          "aria-activedescendant",
          b.id
        );
        this.scrollToActive();
        h2.signal(this.data, "select", this.data.list[this.selectedHint], b);
      }
    }, scrollToActive: function() {
      var a2 = this.getSelectedHintRange(), b = this.hints.childNodes[a2.from];
      a2 = this.hints.childNodes[a2.to];
      var c = this.hints.firstChild;
      b.offsetTop < this.hints.scrollTop ? this.hints.scrollTop = b.offsetTop - c.offsetTop : a2.offsetTop + a2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight && (this.hints.scrollTop = a2.offsetTop + a2.offsetHeight - this.hints.clientHeight + c.offsetTop);
    }, screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }, getSelectedHintRange: function() {
      var a2 = this.completion.options.scrollMargin || 0;
      return { from: Math.max(0, this.selectedHint - a2), to: Math.min(this.data.list.length - 1, this.selectedHint + a2) };
    } };
    h2.registerHelper("hint", "auto", { resolve: function(a2, b) {
      var c = a2.getHelpers(b, "hint"), d2;
      return c.length ? (a2 = function(e, p, f) {
        function r(m2) {
          if (m2 == g.length)
            return p(null);
          I(g[m2], e, f, function(k) {
            k && 0 < k.list.length ? p(k) : r(m2 + 1);
          });
        }
        var g = L(e, c);
        r(0);
      }, a2.async = true, a2.supportsSelection = true, a2) : (d2 = a2.getHelper(a2.getCursor(), "hintWords")) ? function(e) {
        return h2.hint.fromList(e, { words: d2 });
      } : h2.hint.anyword ? function(e, p) {
        return h2.hint.anyword(e, p);
      } : function() {
      };
    } });
    h2.registerHelper("hint", "fromList", function(a2, b) {
      var c = a2.getCursor(), d2 = a2.getTokenAt(c);
      a2 = h2.Pos(c.line, d2.start);
      d2.start < c.ch && /\w/.test(d2.string.charAt(c.ch - d2.start - 1)) ? d2 = d2.string.substr(0, c.ch - d2.start) : (d2 = "", a2 = c);
      for (var e = [], p = 0; p < b.words.length; p++) {
        var f = b.words[p];
        f.slice(0, d2.length) == d2 && e.push(f);
      }
      if (e.length)
        return { list: e, from: a2, to: c };
    });
    h2.commands.autocomplete = h2.showHint;
    var J = { hint: h2.hint.auto, completeSingle: true, alignWithWord: true, closeCharacters: /[\s()\[\]{};:>,]/, closeOnPick: true, closeOnUnfocus: true, updateOnCursorActivity: true, completeOnSingleClick: true, container: null, customKeys: null, extraKeys: null, paddingForScrollbar: true, moveOnOverlap: true };
    h2.defineOption("hintOptions", null);
  });
})();
(function(module2, exports2) {
  var $jscomp = $jscomp || {};
  $jscomp.scope = {};
  $jscomp.findInternal = function(a2, d2, c) {
    a2 instanceof String && (a2 = String(a2));
    for (var e = a2.length, f = 0; f < e; f++) {
      var m2 = a2[f];
      if (d2.call(c, m2, f, a2))
        return { i: f, v: m2 };
    }
    return { i: -1, v: void 0 };
  };
  $jscomp.ASSUME_ES5 = false;
  $jscomp.ASSUME_NO_NATIVE_MAP = false;
  $jscomp.ASSUME_NO_NATIVE_SET = false;
  $jscomp.SIMPLE_FROUND_POLYFILL = false;
  $jscomp.ISOLATE_POLYFILLS = false;
  $jscomp.FORCE_POLYFILL_PROMISE = false;
  $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = false;
  $jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(a2, d2, c) {
    if (a2 == Array.prototype || a2 == Object.prototype)
      return a2;
    a2[d2] = c.value;
    return a2;
  };
  $jscomp.getGlobal = function(a2) {
    a2 = ["object" == typeof globalThis && globalThis, a2, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof commonjsGlobal && commonjsGlobal];
    for (var d2 = 0; d2 < a2.length; ++d2) {
      var c = a2[d2];
      if (c && c.Math == Math)
        return c;
    }
    throw Error("Cannot find global object");
  };
  $jscomp.global = $jscomp.getGlobal(commonjsGlobal);
  $jscomp.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
  $jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
  $jscomp.polyfills = {};
  $jscomp.propertyToPolyfillSymbol = {};
  $jscomp.POLYFILL_PREFIX = "$jscp$";
  $jscomp.polyfill = function(a2, d2, c, e) {
    d2 && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(a2, d2, c, e) : $jscomp.polyfillUnisolated(a2, d2, c, e));
  };
  $jscomp.polyfillUnisolated = function(a2, d2, c, e) {
    c = $jscomp.global;
    a2 = a2.split(".");
    for (e = 0; e < a2.length - 1; e++) {
      var f = a2[e];
      if (!(f in c))
        return;
      c = c[f];
    }
    a2 = a2[a2.length - 1];
    e = c[a2];
    d2 = d2(e);
    d2 != e && null != d2 && $jscomp.defineProperty(c, a2, { configurable: true, writable: true, value: d2 });
  };
  $jscomp.polyfillIsolated = function(a2, d2, c, e) {
    var f = a2.split(".");
    a2 = 1 === f.length;
    e = f[0];
    e = !a2 && e in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
    for (var m2 = 0; m2 < f.length - 1; m2++) {
      var r = f[m2];
      if (!(r in e))
        return;
      e = e[r];
    }
    f = f[f.length - 1];
    c = $jscomp.IS_SYMBOL_NATIVE && "es6" === c ? e[f] : null;
    d2 = d2(c);
    null != d2 && (a2 ? $jscomp.defineProperty($jscomp.polyfills, f, { configurable: true, writable: true, value: d2 }) : d2 !== c && (void 0 === $jscomp.propertyToPolyfillSymbol[f] && (c = 1e9 * Math.random() >>> 0, $jscomp.propertyToPolyfillSymbol[f] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(f) : $jscomp.POLYFILL_PREFIX + c + "$" + f), $jscomp.defineProperty(e, $jscomp.propertyToPolyfillSymbol[f], { configurable: true, writable: true, value: d2 })));
  };
  $jscomp.polyfill("Array.prototype.find", function(a2) {
    return a2 ? a2 : function(d2, c) {
      return $jscomp.findInternal(this, d2, c).v;
    };
  }, "es6", "es3");
  (function(a2) {
    a2(codemirrorExports);
  })(function(a2) {
    function d2(b) {
      b.state.markedSelection && b.operation(function() {
        r(b);
      });
    }
    function c(b) {
      b.state.markedSelection && b.state.markedSelection.length && b.operation(function() {
        f(b);
      });
    }
    function e(b, g, h2, k) {
      if (0 != p(g, h2))
        for (var l = b.state.markedSelection, n = b.state.markedSelectionStyle, q = g.line; ; ) {
          var t = q == g.line ? g : v(
            q,
            0
          );
          q += u;
          var w = q >= h2.line, x2 = w ? h2 : v(q, 0);
          t = b.markText(t, x2, { className: n });
          null == k ? l.push(t) : l.splice(k++, 0, t);
          if (w)
            break;
        }
    }
    function f(b) {
      b = b.state.markedSelection;
      for (var g = 0; g < b.length; ++g)
        b[g].clear();
      b.length = 0;
    }
    function m2(b) {
      f(b);
      for (var g = b.listSelections(), h2 = 0; h2 < g.length; h2++)
        e(b, g[h2].from(), g[h2].to());
    }
    function r(b) {
      if (!b.somethingSelected())
        return f(b);
      if (1 < b.listSelections().length)
        return m2(b);
      var g = b.getCursor("start"), h2 = b.getCursor("end"), k = b.state.markedSelection;
      if (!k.length)
        return e(b, g, h2);
      var l = k[0].find(), n = k[k.length - 1].find();
      if (!l || !n || h2.line - g.line <= u || 0 <= p(g, n.to) || 0 >= p(h2, l.from))
        return m2(b);
      for (; 0 < p(g, l.from); )
        k.shift().clear(), l = k[0].find();
      0 > p(g, l.from) && (l.to.line - g.line < u ? (k.shift().clear(), e(b, g, l.to, 0)) : e(b, g, l.from, 0));
      for (; 0 > p(h2, n.to); )
        k.pop().clear(), n = k[k.length - 1].find();
      0 < p(h2, n.to) && (h2.line - n.from.line < u ? (k.pop().clear(), e(b, n.from, h2)) : e(b, n.to, h2));
    }
    a2.defineOption("styleSelectedText", false, function(b, g, h2) {
      h2 = h2 && h2 != a2.Init;
      g && !h2 ? (b.state.markedSelection = [], b.state.markedSelectionStyle = "string" == typeof g ? g : "CodeMirror-selectedtext", m2(b), b.on("cursorActivity", d2), b.on("change", c)) : !g && h2 && (b.off("cursorActivity", d2), b.off("change", c), f(b), b.state.markedSelection = b.state.markedSelectionStyle = null);
    });
    var u = 8, v = a2.Pos, p = a2.cmpPos;
  });
})();
(function(module2, exports2) {
  (function(r) {
    r(codemirrorExports);
  })(function(r) {
    function I(c) {
      c = c.search(u);
      return -1 == c ? 0 : c;
    }
    function J(c, d2, a2) {
      return /\bstring\b/.test(c.getTokenTypeAt(l(d2.line, 0))) && !/^['"`]/.test(a2);
    }
    function G(c, d2) {
      var a2 = c.getMode();
      return false !== a2.useInnerComments && a2.innerMode ? c.getModeAt(d2) : a2;
    }
    var E = {}, u = /[^\s\u00a0]/, l = r.Pos, K = r.cmpPos;
    r.commands.toggleComment = function(c) {
      c.toggleComment();
    };
    r.defineExtension("toggleComment", function(c) {
      c || (c = E);
      for (var d2 = Infinity, a2 = this.listSelections(), b = null, e = a2.length - 1; 0 <= e; e--) {
        var g = a2[e].from(), f = a2[e].to();
        g.line >= d2 || (f.line >= d2 && (f = l(d2, 0)), d2 = g.line, null == b ? this.uncomment(g, f, c) ? b = "un" : (this.lineComment(g, f, c), b = "line") : "un" == b ? this.uncomment(g, f, c) : this.lineComment(g, f, c));
      }
    });
    r.defineExtension("lineComment", function(c, d2, a2) {
      a2 || (a2 = E);
      var b = this, e = G(b, c), g = b.getLine(c.line);
      if (null != g && !J(b, c, g)) {
        var f = a2.lineComment || e.lineComment;
        if (f) {
          var m2 = Math.min(0 != d2.ch || d2.line == c.line ? d2.line + 1 : d2.line, b.lastLine() + 1), v = null == a2.padding ? " " : a2.padding, k = a2.commentBlankLines || c.line == d2.line;
          b.operation(function() {
            if (a2.indent) {
              for (var q = null, h2 = c.line; h2 < m2; ++h2) {
                var n = b.getLine(h2);
                n = -1 === n.search(u) ? n : n.slice(0, I(n));
                if (null == q || q.length > n.length)
                  q = n;
              }
              for (h2 = c.line; h2 < m2; ++h2) {
                n = b.getLine(h2);
                var t = q.length;
                if (k || u.test(n))
                  n.slice(0, t) != q && (t = I(n)), b.replaceRange(q + f + v, l(h2, 0), l(h2, t));
              }
            } else
              for (h2 = c.line; h2 < m2; ++h2)
                (k || u.test(b.getLine(h2))) && b.replaceRange(f + v, l(h2, 0));
          });
        } else if (a2.blockCommentStart || e.blockCommentStart)
          a2.fullLines = true, b.blockComment(c, d2, a2);
      }
    });
    r.defineExtension("blockComment", function(c, d2, a2) {
      a2 || (a2 = E);
      var b = this, e = G(b, c), g = a2.blockCommentStart || e.blockCommentStart, f = a2.blockCommentEnd || e.blockCommentEnd;
      if (!g || !f)
        (a2.lineComment || e.lineComment) && 0 != a2.fullLines && b.lineComment(c, d2, a2);
      else if (!/\bcomment\b/.test(b.getTokenTypeAt(l(c.line, 0)))) {
        var m2 = Math.min(d2.line, b.lastLine());
        m2 != c.line && 0 == d2.ch && u.test(b.getLine(m2)) && --m2;
        var v = null == a2.padding ? " " : a2.padding;
        c.line > m2 || b.operation(function() {
          if (0 != a2.fullLines) {
            var k = u.test(b.getLine(m2));
            b.replaceRange(v + f, l(m2));
            b.replaceRange(g + v, l(c.line, 0));
            var q = a2.blockCommentLead || e.blockCommentLead;
            if (null != q)
              for (var h2 = c.line + 1; h2 <= m2; ++h2)
                (h2 != m2 || k) && b.replaceRange(q + v, l(h2, 0));
          } else
            k = 0 == K(b.getCursor("to"), d2), q = !b.somethingSelected(), b.replaceRange(f, d2), k && b.setSelection(q ? d2 : b.getCursor("from"), d2), b.replaceRange(g, c);
        });
      }
    });
    r.defineExtension("uncomment", function(c, d2, a2) {
      a2 || (a2 = E);
      var b = this, e = G(b, c), g = Math.min(0 != d2.ch || d2.line == c.line ? d2.line : d2.line - 1, b.lastLine()), f = Math.min(c.line, g), m2 = a2.lineComment || e.lineComment, v = [], k = null == a2.padding ? " " : a2.padding, q;
      a:
        if (m2) {
          for (var h2 = f; h2 <= g; ++h2) {
            var n = b.getLine(h2), t = n.indexOf(m2);
            -1 < t && !/comment/.test(b.getTokenTypeAt(l(h2, t + 1))) && (t = -1);
            if (-1 == t && u.test(n))
              break a;
            if (-1 < t && u.test(n.slice(0, t)))
              break a;
            v.push(n);
          }
          b.operation(function() {
            for (var p = f; p <= g; ++p) {
              var A = v[p - f], x2 = A.indexOf(m2), w = x2 + m2.length;
              0 > x2 || (A.slice(w, w + k.length) == k && (w += k.length), q = true, b.replaceRange("", l(p, x2), l(p, w)));
            }
          });
          if (q)
            return true;
        }
      var y2 = a2.blockCommentStart || e.blockCommentStart, z = a2.blockCommentEnd || e.blockCommentEnd;
      if (!y2 || !z)
        return false;
      var H = a2.blockCommentLead || e.blockCommentLead, C = b.getLine(f), D = C.indexOf(y2);
      if (-1 == D)
        return false;
      var F = g == f ? C : b.getLine(g), B = F.indexOf(z, g == f ? D + y2.length : 0);
      a2 = l(f, D + 1);
      e = l(g, B + 1);
      if (-1 == B || !/comment/.test(b.getTokenTypeAt(a2)) || !/comment/.test(b.getTokenTypeAt(e)) || -1 < b.getRange(a2, e, "\n").indexOf(z))
        return false;
      e = C.lastIndexOf(y2, c.ch);
      a2 = -1 == e ? -1 : C.slice(0, c.ch).indexOf(z, e + y2.length);
      if (-1 != e && -1 != a2 && a2 + z.length != c.ch)
        return false;
      a2 = F.indexOf(
        z,
        d2.ch
      );
      c = F.slice(d2.ch).lastIndexOf(y2, a2 - d2.ch);
      e = -1 == a2 || -1 == c ? -1 : d2.ch + c;
      if (-1 != a2 && -1 != e && e != d2.ch)
        return false;
      b.operation(function() {
        b.replaceRange("", l(g, B - (k && F.slice(B - k.length, B) == k ? k.length : 0)), l(g, B + z.length));
        var p = D + y2.length;
        k && C.slice(p, p + k.length) == k && (p += k.length);
        b.replaceRange("", l(f, D), l(f, p));
        if (H)
          for (p = f + 1; p <= g; ++p) {
            var A = b.getLine(p), x2 = A.indexOf(H);
            if (-1 != x2 && !u.test(A.slice(0, x2))) {
              var w = x2 + H.length;
              k && A.slice(w, w + k.length) == k && (w += k.length);
              b.replaceRange("", l(p, x2), l(p, w));
            }
          }
      });
      return true;
    });
  });
})();
const keymaps = {
  "Ctrl-Enter": "editor:evalLine",
  "Cmd-Enter": "editor:evalLine",
  "Ctrl-/": "editor:toggleComment",
  "Cmd-/": "editor:toggleComment",
  "Alt-Enter": "editor:evalBlock",
  "Shift-Ctrl-Enter": "editor:evalAll",
  "Shift-Cmd-Enter": "editor:evalAll",
  "Shift-Ctrl-G": "gallery:shareSketch",
  "Shift-Cmd-G": "gallery:shareSketch",
  "Shift-Ctrl-F": "editor:formatCode",
  "Shift-Cmd-F": "editor:formatCode",
  "Shift-Ctrl-L": "gallery:saveToURL",
  "Shift-Cmd-L": "gallery:saveToURL",
  "Shift-Ctrl-H": "hideAll",
  "Shift-Cmd-H": "hideAll",
  "Shift-Ctrl-S": "screencap",
  "Shift-Cmd-S": "screencap"
};
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "‚Äå‚Äç¬∑ÃÄ-ÕØŒá“É-“á÷ë-÷Ω÷ø◊Å◊Ç◊Ñ◊Ö◊áÿê-ÿöŸã-Ÿ©Ÿ∞€ñ-€ú€ü-€§€ß€®€™-€≠€∞-€π‹ë‹∞-›äﬁ¶-ﬁ∞ﬂÄ-ﬂâﬂ´-ﬂ≥ﬂΩ‡†ñ-‡†ô‡†õ-‡†£‡†•-‡†ß‡†©-‡†≠‡°ô-‡°õ‡¢ò-‡¢ü‡£ä-‡£°‡££-‡§É‡§∫-‡§º‡§æ-‡•è‡•ë-‡•ó‡•¢‡•£‡•¶-‡•Ø‡¶Å-‡¶É‡¶º‡¶æ-‡ßÑ‡ßá‡ßà‡ßã-‡ßç‡ßó‡ß¢‡ß£‡ß¶-‡ßØ‡ßæ‡®Å-‡®É‡®º‡®æ-‡©Ç‡©á‡©à‡©ã-‡©ç‡©ë‡©¶-‡©±‡©µ‡™Å-‡™É‡™º‡™æ-‡´Ö‡´á-‡´â‡´ã-‡´ç‡´¢‡´£‡´¶-‡´Ø‡´∫-‡´ø‡¨Å-‡¨É‡¨º‡¨æ-‡≠Ñ‡≠á‡≠à‡≠ã-‡≠ç‡≠ï-‡≠ó‡≠¢‡≠£‡≠¶-‡≠Ø‡ÆÇ‡Ææ-‡ØÇ‡ØÜ-‡Øà‡Øä-‡Øç‡Øó‡Ø¶-‡ØØ‡∞Ä-‡∞Ñ‡∞º‡∞æ-‡±Ñ‡±Ü-‡±à‡±ä-‡±ç‡±ï‡±ñ‡±¢‡±£‡±¶-‡±Ø‡≤Å-‡≤É‡≤º‡≤æ-‡≥Ñ‡≥Ü-‡≥à‡≥ä-‡≥ç‡≥ï‡≥ñ‡≥¢‡≥£‡≥¶-‡≥Ø‡≥≥‡¥Ä-‡¥É‡¥ª‡¥º‡¥æ-‡µÑ‡µÜ-‡µà‡µä-‡µç‡µó‡µ¢‡µ£‡µ¶-‡µØ‡∂Å-‡∂É‡∑ä‡∑è-‡∑î‡∑ñ‡∑ò-‡∑ü‡∑¶-‡∑Ø‡∑≤‡∑≥‡∏±‡∏¥-‡∏∫‡πá-‡πé‡πê-‡πô‡∫±‡∫¥-‡∫º‡ªà-‡ªé‡ªê-‡ªô‡ºò‡ºô‡º†-‡º©‡ºµ‡º∑‡ºπ‡ºæ‡ºø‡Ω±-‡æÑ‡æÜ‡æá‡æç-‡æó‡æô-‡æº‡øÜ·Ä´-·Äæ·ÅÄ-·Åâ·Åñ-·Åô·Åû-·Å†·Å¢-·Å§·Åß-·Å≠·Å±-·Å¥·ÇÇ-·Çç·Çè-·Çù·çù-·çü·ç©-·ç±·úí-·úï·ú≤-·ú¥·ùí·ùì·ù≤·ù≥·û¥-·üì·üù·ü†-·ü©·†ã-·†ç·†è-·†ô·¢©·§†-·§´·§∞-·§ª·•Ü-·•è·ßê-·ßö·®ó-·®õ·©ï-·©û·©†-·©º·©ø-·™â·™ê-·™ô·™∞-·™Ω·™ø-·´é·¨Ä-·¨Ñ·¨¥-·≠Ñ·≠ê-·≠ô·≠´-·≠≥·ÆÄ-·ÆÇ·Æ°-·Æ≠·Æ∞-·Æπ·Ø¶-·Ø≥·∞§-·∞∑·±Ä-·±â·±ê-·±ô·≥ê-·≥í·≥î-·≥®·≥≠·≥¥·≥∑-·≥π·∑Ä-·∑ø‚Äø‚ÅÄ‚Åî‚Éê-‚Éú‚É°‚É•-‚É∞‚≥Ø-‚≥±‚µø‚∑†-‚∑ø„Ä™-„ÄØ„Çô„ÇöÍò†-Íò©ÍôØÍô¥-ÍôΩÍöûÍöüÍõ∞Íõ±Í†ÇÍ†ÜÍ†ãÍ†£-Í†ßÍ†¨Í¢ÄÍ¢ÅÍ¢¥-Í£ÖÍ£ê-Í£ôÍ£†-Í£±Í£ø-Í§âÍ§¶-Í§≠Í•á-Í•ìÍ¶Ä-Í¶ÉÍ¶≥-ÍßÄÍßê-ÍßôÍß•Íß∞-ÍßπÍ®©-Í®∂Í©ÉÍ©åÍ©çÍ©ê-Í©ôÍ©ª-Í©ΩÍ™∞Í™≤-Í™¥Í™∑Í™∏Í™æÍ™øÍ´ÅÍ´´-Í´ØÍ´µÍ´∂ÍØ£-ÍØ™ÍØ¨ÍØ≠ÍØ∞-ÍØπÔ¨ûÔ∏Ä-Ô∏èÔ∏†-Ô∏ØÔ∏≥Ô∏¥Ôπç-ÔπèÔºê-ÔºôÔºø";
var nonASCIIidentifierStartChars = "¬™¬µ¬∫√Ä-√ñ√ò-√∂√∏-ÀÅÀÜ-ÀëÀ†-À§À¨ÀÆÕ∞-Õ¥Õ∂Õ∑Õ∫-ÕΩÕøŒÜŒà-ŒäŒåŒé-Œ°Œ£-œµœ∑-“Å“ä-‘Ø‘±-’ñ’ô’†-÷à◊ê-◊™◊Ø-◊≤ÿ†-ŸäŸÆŸØŸ±-€ì€ï€•€¶€Æ€Ø€∫-€º€ø‹ê‹í-‹Ø›ç-ﬁ•ﬁ±ﬂä-ﬂ™ﬂ¥ﬂµﬂ∫‡†Ä-‡†ï‡†ö‡†§‡†®‡°Ä-‡°ò‡°†-‡°™‡°∞-‡¢á‡¢â-‡¢é‡¢†-‡£â‡§Ñ-‡§π‡§Ω‡•ê‡•ò-‡•°‡•±-‡¶Ä‡¶Ö-‡¶å‡¶è‡¶ê‡¶ì-‡¶®‡¶™-‡¶∞‡¶≤‡¶∂-‡¶π‡¶Ω‡ßé‡ßú‡ßù‡ßü-‡ß°‡ß∞‡ß±‡ßº‡®Ö-‡®ä‡®è‡®ê‡®ì-‡®®‡®™-‡®∞‡®≤‡®≥‡®µ‡®∂‡®∏‡®π‡©ô-‡©ú‡©û‡©≤-‡©¥‡™Ö-‡™ç‡™è-‡™ë‡™ì-‡™®‡™™-‡™∞‡™≤‡™≥‡™µ-‡™π‡™Ω‡´ê‡´†‡´°‡´π‡¨Ö-‡¨å‡¨è‡¨ê‡¨ì-‡¨®‡¨™-‡¨∞‡¨≤‡¨≥‡¨µ-‡¨π‡¨Ω‡≠ú‡≠ù‡≠ü-‡≠°‡≠±‡ÆÉ‡ÆÖ-‡Æä‡Æé-‡Æê‡Æí-‡Æï‡Æô‡Æö‡Æú‡Æû‡Æü‡Æ£‡Æ§‡Æ®-‡Æ™‡ÆÆ-‡Æπ‡Øê‡∞Ö-‡∞å‡∞é-‡∞ê‡∞í-‡∞®‡∞™-‡∞π‡∞Ω‡±ò-‡±ö‡±ù‡±†‡±°‡≤Ä‡≤Ö-‡≤å‡≤é-‡≤ê‡≤í-‡≤®‡≤™-‡≤≥‡≤µ-‡≤π‡≤Ω‡≥ù‡≥û‡≥†‡≥°‡≥±‡≥≤‡¥Ñ-‡¥å‡¥é-‡¥ê‡¥í-‡¥∫‡¥Ω‡µé‡µî-‡µñ‡µü-‡µ°‡µ∫-‡µø‡∂Ö-‡∂ñ‡∂ö-‡∂±‡∂≥-‡∂ª‡∂Ω‡∑Ä-‡∑Ü‡∏Å-‡∏∞‡∏≤‡∏≥‡πÄ-‡πÜ‡∫Å‡∫Ç‡∫Ñ‡∫Ü-‡∫ä‡∫å-‡∫£‡∫•‡∫ß-‡∫∞‡∫≤‡∫≥‡∫Ω‡ªÄ-‡ªÑ‡ªÜ‡ªú-‡ªü‡ºÄ‡ΩÄ-‡Ωá‡Ωâ-‡Ω¨‡æà-‡æå·ÄÄ-·Ä™·Äø·Åê-·Åï·Åö-·Åù·Å°·Å•·Å¶·ÅÆ-·Å∞·Åµ-·ÇÅ·Çé·Ç†-·ÉÖ·Éá·Éç·Éê-·É∫·Éº-·âà·âä-·âç·âê-·âñ·âò·âö-·âù·â†-·äà·ää-·äç·äê-·ä∞·ä≤-·äµ·ä∏-·äæ·ãÄ·ãÇ-·ãÖ·ãà-·ãñ·ãò-·åê·åí-·åï·åò-·çö·éÄ-·éè·é†-·èµ·è∏-·èΩ·êÅ-·ô¨·ôØ-·ôø·öÅ-·öö·ö†-·õ™·õÆ-·õ∏·úÄ-·úë·úü-·ú±·ùÄ-·ùë·ù†-·ù¨·ùÆ-·ù∞·ûÄ-·û≥·üó·üú·††-·°∏·¢Ä-·¢®·¢™·¢∞-·£µ·§Ä-·§û·•ê-·•≠·•∞-·•¥·¶Ä-·¶´·¶∞-·ßâ·®Ä-·®ñ·®†-·©î·™ß·¨Ö-·¨≥·≠Ö-·≠å·ÆÉ-·Æ†·ÆÆ·ÆØ·Æ∫-·Ø•·∞Ä-·∞£·±ç-·±è·±ö-·±Ω·≤Ä-·≤à·≤ê-·≤∫·≤Ω-·≤ø·≥©-·≥¨·≥Æ-·≥≥·≥µ·≥∂·≥∫·¥Ä-·∂ø·∏Ä-·ºï·ºò-·ºù·º†-·ΩÖ·Ωà-·Ωç·Ωê-·Ωó·Ωô·Ωõ·Ωù·Ωü-·ΩΩ·æÄ-·æ¥·æ∂-·æº·ææ·øÇ-·øÑ·øÜ-·øå·øê-·øì·øñ-·øõ·ø†-·ø¨·ø≤-·ø¥·ø∂-·øº‚Å±‚Åø‚Çê-‚Çú‚ÑÇ‚Ñá‚Ñä-‚Ñì‚Ñï‚Ñò-‚Ñù‚Ñ§‚Ñ¶‚Ñ®‚Ñ™-‚Ñπ‚Ñº-‚Ñø‚ÖÖ-‚Öâ‚Öé‚Ö†-‚Üà‚∞Ä-‚≥§‚≥´-‚≥Æ‚≥≤‚≥≥‚¥Ä-‚¥•‚¥ß‚¥≠‚¥∞-‚µß‚µØ‚∂Ä-‚∂ñ‚∂†-‚∂¶‚∂®-‚∂Æ‚∂∞-‚∂∂‚∂∏-‚∂æ‚∑Ä-‚∑Ü‚∑à-‚∑é‚∑ê-‚∑ñ‚∑ò-‚∑û„ÄÖ-„Äá„Ä°-„Ä©„Ä±-„Äµ„Ä∏-„Äº„ÅÅ-„Çñ„Çõ-„Çü„Ç°-„É∫„Éº-„Éø„ÑÖ-„ÑØ„Ñ±-„Üé„Ü†-„Üø„á∞-„áø„êÄ-‰∂ø‰∏Ä-ÍíåÍìê-ÍìΩÍîÄ-ÍòåÍòê-ÍòüÍò™Íò´ÍôÄ-ÍôÆÍôø-ÍöùÍö†-ÍõØÍúó-ÍúüÍú¢-ÍûàÍûã-ÍüäÍüêÍüëÍüìÍüï-ÍüôÍü≤-Í†ÅÍ†É-Í†ÖÍ†á-Í†äÍ†å-Í†¢Í°Ä-Í°≥Í¢Ç-Í¢≥Í£≤-Í£∑Í£ªÍ£ΩÍ£æÍ§ä-Í§•Í§∞-Í•ÜÍ•†-Í•ºÍ¶Ñ-Í¶≤ÍßèÍß†-Íß§Íß¶-ÍßØÍß∫-ÍßæÍ®Ä-Í®®Í©Ä-Í©ÇÍ©Ñ-Í©ãÍ©†-Í©∂Í©∫Í©æ-Í™ØÍ™±Í™µÍ™∂Í™π-Í™ΩÍ´ÄÍ´ÇÍ´õ-Í´ùÍ´†-Í´™Í´≤-Í´¥Í¨Å-Í¨ÜÍ¨â-Í¨éÍ¨ë-Í¨ñÍ¨†-Í¨¶Í¨®-Í¨ÆÍ¨∞-Í≠öÍ≠ú-Í≠©Í≠∞-ÍØ¢Í∞Ä-Ìû£Ìû∞-ÌüÜÌüã-ÌüªÔ§Ä-Ô©≠Ô©∞-Ô´ôÔ¨Ä-Ô¨ÜÔ¨ì-Ô¨óÔ¨ùÔ¨ü-Ô¨®Ô¨™-Ô¨∂Ô¨∏-Ô¨ºÔ¨æÔ≠ÄÔ≠ÅÔ≠ÉÔ≠ÑÔ≠Ü-ÔÆ±ÔØì-Ô¥ΩÔµê-Ô∂èÔ∂í-Ô∑áÔ∑∞-Ô∑ªÔπ∞-Ôπ¥Ôπ∂-ÔªºÔº°-Ôº∫ÔΩÅ-ÔΩöÔΩ¶-ÔææÔøÇ-ÔøáÔøä-ÔøèÔøí-ÔøóÔøö-Ôøú";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code2, set) {
  var pos = 65536;
  for (var i2 = 0; i2 < set.length; i2 += 2) {
    pos += set[i2];
    if (pos > code2) {
      return false;
    }
    pos += set[i2 + 1];
    if (pos >= code2) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code2, astral) {
  if (code2 < 65) {
    return code2 === 36;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes);
}
function isIdentifierChar(code2, astral) {
  if (code2 < 48) {
    return code2 === 36;
  }
  if (code2 < 58) {
    return true;
  }
  if (code2 < 65) {
    return false;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options2) {
  if (options2 === void 0)
    options2 = {};
  options2.keyword = name;
  return keywords[name] = new TokenType(name, options2);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code2) {
  return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
}
function nextLineBreak(code2, from, end) {
  if (end === void 0)
    end = code2.length;
  for (var i2 = from; i2 < end; i2++) {
    var next = code2.charCodeAt(i2);
    if (isNewLine(next)) {
      return i2 < end - 1 && next === 13 && code2.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code2) {
  if (code2 <= 65535) {
    return String.fromCharCode(code2);
  }
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback‚Äîthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback‚Äîthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options2 = {};
  for (var opt in defaultOptions) {
    options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options2.allowHashBang = options2.ecmaVersion >= 14;
  }
  if (isArray(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token2) {
      return tokens.push(token2);
    };
  }
  if (isArray(options2.onComment)) {
    options2.onComment = pushComment(options2, options2.onComment);
  }
  return options2;
}
function pushComment(options2, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options2.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment.range = [start, end];
    }
    array.push(comment);
  };
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
var Parser = function Parser2(options2, input, startPos) {
  this.options = options2 = getOptions(options2);
  this.sourceFile = options2.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options2.allowReserved !== true) {
    reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
    if (options2.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options2.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse2() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend2() {
  var plugins = [], len2 = arguments.length;
  while (len2--)
    plugins[len2] = arguments[len2];
  var cls = this;
  for (var i2 = 0; i2 < plugins.length; i2++) {
    cls = plugins[i2](cls);
  }
  return cls;
};
Parser.parse = function parse3(input, options2) {
  return new this(options2, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
  var parser2 = new this(options2, input, pos);
  parser2.nextToken();
  return parser2.parseExpression();
};
Parser.tokenizer = function tokenizer2(input, options2) {
  return new this(options2, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports2 = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports2);
    node.body.push(stmt);
  }
  if (this.inModule) {
    for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
      var name = list2[i2];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after2;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after2 = this.input.charCodeAt(next + 8)) || after2 > 55295 && after2 < 56320));
};
pp$8.parseStatement = function(context, topLevel2, exports2) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel2) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports2);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i2 = 0;
  for (; i2 < this.labels.length; ++i2) {
    var lab = this.labels[i2];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i2 === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$12 = 0, list2 = this.labels; i$12 < list2.length; i$12 += 1) {
    var label = list2[i$12];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
    var label$1 = this.labels[i2];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node === void 0)
    node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raise(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion2 = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  var len2 = this.privateNameStack.length;
  var parent2 = len2 === 0 ? null : this.privateNameStack[len2 - 1];
  for (var i2 = 0; i2 < used.length; ++i2) {
    var id2 = used[i2];
    if (!hasOwn(declared, id2.name)) {
      if (parent2) {
        parent2.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExport = function(node, exports2) {
  this.next();
  if (this.eat(types$1.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node.exported = this.parseModuleExportName();
        this.checkExport(exports2, node.exported, this.lastTokStart);
      } else {
        node.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports2, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) {
        this.next();
      }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports2, node.declaration.declarations);
    } else {
      this.checkExport(exports2, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports2);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
    } else {
      for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
        var spec = list2[i2];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.checkExport = function(exports2, name, pos) {
  if (!exports2) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports2, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports2[name] = true;
};
pp$8.checkPatternExport = function(exports2, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports2, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
      var prop = list2[i2];
      this.checkPatternExport(exports2, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$12 = 0, list$1 = pat.elements; i$12 < list$1.length; i$12 += 1) {
      var elt = list$1[i$12];
      if (elt) {
        this.checkPatternExport(exports2, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports2, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports2, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports2, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports2, pat.expression);
  }
};
pp$8.checkVariableExport = function(exports2, decls) {
  if (!exports2) {
    return;
  }
  for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
    var decl = list2[i2];
    this.checkPatternExport(exports2, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifiers = function(exports2) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var node = this.startNode();
    node.local = this.parseModuleExportName();
    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
    this.checkExport(
      exports2,
      node.exported,
      node.exported.start
    );
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLValSimple(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLValSimple(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var node$2 = this.startNode();
    node$2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLValSimple(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
    statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
          var prop = list2[i2];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i2 = 0; i2 < end; i2++) {
    var elt = exprList[i2];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last2 = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last2 && last2.type === "RestElement" && last2.argument.type !== "Identifier") {
      this.unexpected(last2.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
        var prop = list2[i2];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$12 = 0, list$1 = expr.elements; i$12 < list$1.length; i$12 += 1) {
        var elem = list$1[i$12];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token2, isExpr, preserveSpace, override, generator) {
  this.token = token2;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent2 = this.curContext();
  if (parent2 === types.f_expr || parent2 === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent2 === types.b_stat || parent2 === types.b_expr)) {
    return !parent2.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent2 === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
    var context = this.context[i2];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types.f_expr) {
      this.context[index2] = types.f_expr_gen;
    } else {
      this.context[index2] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;
    case "Literal":
      name = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if (forInit || this.privateNameStack.length === 0) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base = element;
  }
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport();
      } else {
        return this.unexpected();
      }
    default:
      this.unexpected();
  }
};
pp$5.parseExprImport = function() {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  var meta = this.parseIdent(true);
  switch (this.type) {
    case types$1.parenL:
      return this.parseDynamicImport(node);
    case types$1.dot:
      node.meta = meta;
      return this.parseImportMeta(node);
    default:
      this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
  if (isImport && node.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") {
        this.raiseRecoverable(start, "getter should have no params");
      } else {
        this.raiseRecoverable(start, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
    var param = list2[i2];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
    var param = list2[i2];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re2.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.privateNameStack.length === 0) {
    this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
  } else {
    this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
      var scope$3 = this.scopeStack[i2];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser2, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser2.options.locations) {
    this.loc = new SourceLocation(parser2, loc);
  }
  if (parser2.options.directSourceFile) {
    this.sourceFile = parser2.options.directSourceFile;
  }
  if (parser2.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) {
    newNode[prop] = node[prop];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Kawi Nag_Mundari Nagm";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion2) {
  var d2 = data[ecmaVersion2] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
    }
  };
  d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
  d2.nonBinary.gc = d2.nonBinary.General_Category;
  d2.nonBinary.sc = d2.nonBinary.Script;
  d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
}
for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
  var ecmaVersion = list[i];
  buildUnicodeData(ecmaVersion);
}
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser2) {
  this.parser = parser2;
  this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "");
  this.unicodeProperties = data[parser2.options.ecmaVersion >= 14 ? 14 : parser2.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset2(start, pattern2, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern2 + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i2, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s2 = this.source;
  var l = s2.length;
  if (i2 >= l) {
    return -1;
  }
  var c = s2.charCodeAt(i2);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
    return c;
  }
  var next = s2.charCodeAt(i2 + 1);
  return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s2 = this.source;
  var l = s2.length;
  if (i2 >= l) {
    return l;
  }
  var c = s2.charCodeAt(i2), next;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s2.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
    return i2 + 1;
  }
  return i2 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
pp$1.validateRegExpFlags = function(state2) {
  var validFlags = state2.validFlags;
  var flags = state2.flags;
  for (var i2 = 0; i2 < flags.length; i2++) {
    var flag = flags.charAt(i2);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state2.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i2 + 1) > -1) {
      this.raise(state2.start, "Duplicate regular expression flag");
    }
  }
};
pp$1.validateRegExpPattern = function(state2) {
  this.regexp_pattern(state2);
  if (!state2.switchN && this.options.ecmaVersion >= 9 && state2.groupNames.length > 0) {
    state2.switchN = true;
    this.regexp_pattern(state2);
  }
};
pp$1.regexp_pattern = function(state2) {
  state2.pos = 0;
  state2.lastIntValue = 0;
  state2.lastStringValue = "";
  state2.lastAssertionIsQuantifiable = false;
  state2.numCapturingParens = 0;
  state2.maxBackReference = 0;
  state2.groupNames.length = 0;
  state2.backReferenceNames.length = 0;
  this.regexp_disjunction(state2);
  if (state2.pos !== state2.source.length) {
    if (state2.eat(
      41
      /* ) */
    )) {
      state2.raise("Unmatched ')'");
    }
    if (state2.eat(
      93
      /* ] */
    ) || state2.eat(
      125
      /* } */
    )) {
      state2.raise("Lone quantifier brackets");
    }
  }
  if (state2.maxBackReference > state2.numCapturingParens) {
    state2.raise("Invalid escape");
  }
  for (var i2 = 0, list2 = state2.backReferenceNames; i2 < list2.length; i2 += 1) {
    var name = list2[i2];
    if (state2.groupNames.indexOf(name) === -1) {
      state2.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state2) {
  this.regexp_alternative(state2);
  while (state2.eat(
    124
    /* | */
  )) {
    this.regexp_alternative(state2);
  }
  if (this.regexp_eatQuantifier(state2, true)) {
    state2.raise("Nothing to repeat");
  }
  if (state2.eat(
    123
    /* { */
  )) {
    state2.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state2) {
  while (state2.pos < state2.source.length && this.regexp_eatTerm(state2)) {
  }
};
pp$1.regexp_eatTerm = function(state2) {
  if (this.regexp_eatAssertion(state2)) {
    if (state2.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state2)) {
      if (state2.switchU) {
        state2.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state2.switchU ? this.regexp_eatAtom(state2) : this.regexp_eatExtendedAtom(state2)) {
    this.regexp_eatQuantifier(state2);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state2) {
  var start = state2.pos;
  state2.lastAssertionIsQuantifiable = false;
  if (state2.eat(
    94
    /* ^ */
  ) || state2.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state2.eat(
    92
    /* \ */
  )) {
    if (state2.eat(
      66
      /* B */
    ) || state2.eat(
      98
      /* b */
    )) {
      return true;
    }
    state2.pos = start;
  }
  if (state2.eat(
    40
    /* ( */
  ) && state2.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state2.eat(
        60
        /* < */
      );
    }
    if (state2.eat(
      61
      /* = */
    ) || state2.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state2);
      if (!state2.eat(
        41
        /* ) */
      )) {
        state2.raise("Unterminated group");
      }
      state2.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state2.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state2, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state2, noError)) {
    state2.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state2, noError) {
  return state2.eat(
    42
    /* * */
  ) || state2.eat(
    43
    /* + */
  ) || state2.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state2, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state2, noError) {
  var start = state2.pos;
  if (state2.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state2)) {
      min = state2.lastIntValue;
      if (state2.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state2)) {
        max = state2.lastIntValue;
      }
      if (state2.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state2.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state2.switchU && !noError) {
      state2.raise("Incomplete quantifier");
    }
    state2.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state2) {
  return this.regexp_eatPatternCharacters(state2) || state2.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state2) || this.regexp_eatCharacterClass(state2) || this.regexp_eatUncapturingGroup(state2) || this.regexp_eatCapturingGroup(state2);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state2) {
  var start = state2.pos;
  if (state2.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state2)) {
      return true;
    }
    state2.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state2) {
  var start = state2.pos;
  if (state2.eat(
    40
    /* ( */
  )) {
    if (state2.eat(
      63
      /* ? */
    ) && state2.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state2);
      if (state2.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state2.raise("Unterminated group");
    }
    state2.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state2) {
  if (state2.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state2);
    } else if (state2.current() === 63) {
      state2.raise("Invalid group");
    }
    this.regexp_disjunction(state2);
    if (state2.eat(
      41
      /* ) */
    )) {
      state2.numCapturingParens += 1;
      return true;
    }
    state2.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state2) {
  return state2.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state2) || this.regexp_eatCharacterClass(state2) || this.regexp_eatUncapturingGroup(state2) || this.regexp_eatCapturingGroup(state2) || this.regexp_eatInvalidBracedQuantifier(state2) || this.regexp_eatExtendedPatternCharacter(state2);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state2) {
  if (this.regexp_eatBracedQuantifier(state2, true)) {
    state2.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state2) {
  var ch = state2.current();
  if (isSyntaxCharacter(ch)) {
    state2.lastIntValue = ch;
    state2.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state2) {
  var start = state2.pos;
  var ch = 0;
  while ((ch = state2.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state2.advance();
  }
  return state2.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state2) {
  var ch = state2.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state2) {
  if (state2.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(state2)) {
      if (state2.groupNames.indexOf(state2.lastStringValue) !== -1) {
        state2.raise("Duplicate capture group name");
      }
      state2.groupNames.push(state2.lastStringValue);
      return;
    }
    state2.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state2) {
  state2.lastStringValue = "";
  if (state2.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state2) && state2.eat(
      62
      /* > */
    )) {
      return true;
    }
    state2.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state2) {
  state2.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state2)) {
    state2.lastStringValue += codePointToString(state2.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state2)) {
      state2.lastStringValue += codePointToString(state2.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state2) {
  var start = state2.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state2.current(forceU);
  state2.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state2, forceU)) {
    ch = state2.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state2.lastIntValue = ch;
    return true;
  }
  state2.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state2) {
  var start = state2.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state2.current(forceU);
  state2.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state2, forceU)) {
    ch = state2.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state2.lastIntValue = ch;
    return true;
  }
  state2.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state2) {
  if (this.regexp_eatBackReference(state2) || this.regexp_eatCharacterClassEscape(state2) || this.regexp_eatCharacterEscape(state2) || state2.switchN && this.regexp_eatKGroupName(state2)) {
    return true;
  }
  if (state2.switchU) {
    if (state2.current() === 99) {
      state2.raise("Invalid unicode escape");
    }
    state2.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state2) {
  var start = state2.pos;
  if (this.regexp_eatDecimalEscape(state2)) {
    var n = state2.lastIntValue;
    if (state2.switchU) {
      if (n > state2.maxBackReference) {
        state2.maxBackReference = n;
      }
      return true;
    }
    if (n <= state2.numCapturingParens) {
      return true;
    }
    state2.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state2) {
  if (state2.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state2)) {
      state2.backReferenceNames.push(state2.lastStringValue);
      return true;
    }
    state2.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state2) {
  return this.regexp_eatControlEscape(state2) || this.regexp_eatCControlLetter(state2) || this.regexp_eatZero(state2) || this.regexp_eatHexEscapeSequence(state2) || this.regexp_eatRegExpUnicodeEscapeSequence(state2, false) || !state2.switchU && this.regexp_eatLegacyOctalEscapeSequence(state2) || this.regexp_eatIdentityEscape(state2);
};
pp$1.regexp_eatCControlLetter = function(state2) {
  var start = state2.pos;
  if (state2.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state2)) {
      return true;
    }
    state2.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state2) {
  if (state2.current() === 48 && !isDecimalDigit(state2.lookahead())) {
    state2.lastIntValue = 0;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state2) {
  var ch = state2.current();
  if (ch === 116) {
    state2.lastIntValue = 9;
    state2.advance();
    return true;
  }
  if (ch === 110) {
    state2.lastIntValue = 10;
    state2.advance();
    return true;
  }
  if (ch === 118) {
    state2.lastIntValue = 11;
    state2.advance();
    return true;
  }
  if (ch === 102) {
    state2.lastIntValue = 12;
    state2.advance();
    return true;
  }
  if (ch === 114) {
    state2.lastIntValue = 13;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state2) {
  var ch = state2.current();
  if (isControlLetter(ch)) {
    state2.lastIntValue = ch % 32;
    state2.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state2, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start = state2.pos;
  var switchU = forceU || state2.switchU;
  if (state2.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state2, 4)) {
      var lead = state2.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state2.pos;
        if (state2.eat(
          92
          /* \ */
        ) && state2.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state2, 4)) {
          var trail = state2.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state2.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state2.pos = leadSurrogateEnd;
        state2.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state2.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state2) && state2.eat(
      125
      /* } */
    ) && isValidUnicode(state2.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state2.raise("Invalid unicode escape");
    }
    state2.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state2) {
  if (state2.switchU) {
    if (this.regexp_eatSyntaxCharacter(state2)) {
      return true;
    }
    if (state2.eat(
      47
      /* / */
    )) {
      state2.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state2.current();
  if (ch !== 99 && (!state2.switchN || ch !== 107)) {
    state2.lastIntValue = ch;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state2) {
  state2.lastIntValue = 0;
  var ch = state2.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state2.lastIntValue = 10 * state2.lastIntValue + (ch - 48);
      state2.advance();
    } while ((ch = state2.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
pp$1.regexp_eatCharacterClassEscape = function(state2) {
  var ch = state2.current();
  if (isCharacterClassEscape(ch)) {
    state2.lastIntValue = -1;
    state2.advance();
    return true;
  }
  if (state2.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
    state2.lastIntValue = -1;
    state2.advance();
    if (state2.eat(
      123
      /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(state2) && state2.eat(
      125
      /* } */
    )) {
      return true;
    }
    state2.raise("Invalid property name");
  }
  return false;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state2) {
  var start = state2.pos;
  if (this.regexp_eatUnicodePropertyName(state2) && state2.eat(
    61
    /* = */
  )) {
    var name = state2.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state2)) {
      var value = state2.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state2, name, value);
      return true;
    }
  }
  state2.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state2)) {
    var nameOrValue = state2.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state2, nameOrValue);
    return true;
  }
  return false;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state2, name, value) {
  if (!hasOwn(state2.unicodeProperties.nonBinary, name)) {
    state2.raise("Invalid property name");
  }
  if (!state2.unicodeProperties.nonBinary[name].test(value)) {
    state2.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state2, nameOrValue) {
  if (!state2.unicodeProperties.binary.test(nameOrValue)) {
    state2.raise("Invalid property name");
  }
};
pp$1.regexp_eatUnicodePropertyName = function(state2) {
  var ch = 0;
  state2.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state2.current())) {
    state2.lastStringValue += codePointToString(ch);
    state2.advance();
  }
  return state2.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state2) {
  var ch = 0;
  state2.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state2.current())) {
    state2.lastStringValue += codePointToString(ch);
    state2.advance();
  }
  return state2.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state2) {
  return this.regexp_eatUnicodePropertyValue(state2);
};
pp$1.regexp_eatCharacterClass = function(state2) {
  if (state2.eat(
    91
    /* [ */
  )) {
    state2.eat(
      94
      /* ^ */
    );
    this.regexp_classRanges(state2);
    if (state2.eat(
      93
      /* ] */
    )) {
      return true;
    }
    state2.raise("Unterminated character class");
  }
  return false;
};
pp$1.regexp_classRanges = function(state2) {
  while (this.regexp_eatClassAtom(state2)) {
    var left = state2.lastIntValue;
    if (state2.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state2)) {
      var right = state2.lastIntValue;
      if (state2.switchU && (left === -1 || right === -1)) {
        state2.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state2.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state2) {
  var start = state2.pos;
  if (state2.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state2)) {
      return true;
    }
    if (state2.switchU) {
      var ch$1 = state2.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state2.raise("Invalid class escape");
      }
      state2.raise("Invalid escape");
    }
    state2.pos = start;
  }
  var ch = state2.current();
  if (ch !== 93) {
    state2.lastIntValue = ch;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state2) {
  var start = state2.pos;
  if (state2.eat(
    98
    /* b */
  )) {
    state2.lastIntValue = 8;
    return true;
  }
  if (state2.switchU && state2.eat(
    45
    /* - */
  )) {
    state2.lastIntValue = 45;
    return true;
  }
  if (!state2.switchU && state2.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state2)) {
      return true;
    }
    state2.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state2) || this.regexp_eatCharacterEscape(state2);
};
pp$1.regexp_eatClassControlLetter = function(state2) {
  var ch = state2.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state2.lastIntValue = ch % 32;
    state2.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state2) {
  var start = state2.pos;
  if (state2.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state2, 2)) {
      return true;
    }
    if (state2.switchU) {
      state2.raise("Invalid escape");
    }
    state2.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state2) {
  var start = state2.pos;
  var ch = 0;
  state2.lastIntValue = 0;
  while (isDecimalDigit(ch = state2.current())) {
    state2.lastIntValue = 10 * state2.lastIntValue + (ch - 48);
    state2.advance();
  }
  return state2.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state2) {
  var start = state2.pos;
  var ch = 0;
  state2.lastIntValue = 0;
  while (isHexDigit(ch = state2.current())) {
    state2.lastIntValue = 16 * state2.lastIntValue + hexToInt(ch);
    state2.advance();
  }
  return state2.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state2) {
  if (this.regexp_eatOctalDigit(state2)) {
    var n1 = state2.lastIntValue;
    if (this.regexp_eatOctalDigit(state2)) {
      var n2 = state2.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state2)) {
        state2.lastIntValue = n1 * 64 + n2 * 8 + state2.lastIntValue;
      } else {
        state2.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state2.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state2) {
  var ch = state2.current();
  if (isOctalDigit(ch)) {
    state2.lastIntValue = ch - 48;
    state2.advance();
    return true;
  }
  state2.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state2, length2) {
  var start = state2.pos;
  state2.lastIntValue = 0;
  for (var i2 = 0; i2 < length2; ++i2) {
    var ch = state2.current();
    if (!isHexDigit(ch)) {
      state2.pos = start;
      return false;
    }
    state2.lastIntValue = 16 * state2.lastIntValue + hexToInt(ch);
    state2.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token2 = this$1$1.getToken();
        return {
          done: token2.type === types$1.eof,
          value: token2
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code2) {
  if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code2);
};
pp.fullCharCodeAtPos = function() {
  var code2 = this.input.charCodeAt(this.pos);
  if (code2 <= 55295 || code2 >= 56320) {
    return code2;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code2) {
    size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  if (ecmaVersion2 >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion2 >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  var code2 = 35;
  if (ecmaVersion2 >= 13) {
    ++this.pos;
    code2 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code2, true) || code2 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.getTokenFromCode = function(code2) {
  switch (code2) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code2);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code2);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code2);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code2);
    case 60:
    case 62:
      return this.readToken_lt_gt(code2);
    case 61:
    case 33:
      return this.readToken_eq_excl(code2);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern2 = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state2 = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state2.reset(start, pattern2, flags);
  this.validateRegExpFlags(state2);
  this.validateRegExpPattern(state2);
  var value = null;
  try {
    value = new RegExp(pattern2, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern: pattern2, flags, value });
};
pp.readInt = function(radix, len2, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len2 === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i2 = 0, e = len2 == null ? Infinity : len2; i2 < e; ++i2, ++this.pos) {
    var code2 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code2 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i2 === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code2;
      continue;
    }
    if (code2 >= 97) {
      val = code2 - 97 + 10;
    } else if (code2 >= 65) {
      val = code2 - 65 + 10;
    } else if (code2 >= 48 && code2 <= 57) {
      val = code2 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code2;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len2 != null && this.pos - start !== len2) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code2;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code2 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code2 = this.readHexChar(4);
  }
  return code2;
};
pp.readString = function(quote2) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote2) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len2) {
  var codePos = this.pos;
  var n = this.readInt(16, len2);
  if (n === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.8.2";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
const { stringify } = JSON;
if (!String.prototype.repeat) {
  throw new Error(
    "String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"
  );
}
if (!String.prototype.endsWith) {
  throw new Error(
    "String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"
  );
}
const OPERATOR_PRECEDENCE = {
  "||": 2,
  "??": 3,
  "&&": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
const NEEDS_PARENTHESES = 17;
const EXPRESSIONS_PRECEDENCE = {
  // Definitions
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  PrivateIdentifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  // Operations
  MemberExpression: 19,
  ChainExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  // Other definitions
  ArrowFunctionExpression: NEEDS_PARENTHESES,
  ClassExpression: NEEDS_PARENTHESES,
  FunctionExpression: NEEDS_PARENTHESES,
  ObjectExpression: NEEDS_PARENTHESES,
  // Other operations
  UpdateExpression: 16,
  UnaryExpression: 15,
  AwaitExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function formatSequence(state2, nodes) {
  const { generator } = state2;
  state2.write("(");
  if (nodes != null && nodes.length > 0) {
    generator[nodes[0].type](nodes[0], state2);
    const { length: length2 } = nodes;
    for (let i2 = 1; i2 < length2; i2++) {
      const param = nodes[i2];
      state2.write(", ");
      generator[param.type](param, state2);
    }
  }
  state2.write(")");
}
function expressionNeedsParenthesis(state2, node, parentNode, isRightHand) {
  const nodePrecedence = state2.expressionsPrecedence[node.type];
  if (nodePrecedence === NEEDS_PARENTHESES) {
    return true;
  }
  const parentNodePrecedence = state2.expressionsPrecedence[parentNode.type];
  if (nodePrecedence !== parentNodePrecedence) {
    return !isRightHand && nodePrecedence === 15 && parentNodePrecedence === 14 && parentNode.operator === "**" || nodePrecedence < parentNodePrecedence;
  }
  if (nodePrecedence !== 13 && nodePrecedence !== 14) {
    return false;
  }
  if (node.operator === "**" && parentNode.operator === "**") {
    return !isRightHand;
  }
  if (isRightHand) {
    return OPERATOR_PRECEDENCE[node.operator] <= OPERATOR_PRECEDENCE[parentNode.operator];
  }
  return OPERATOR_PRECEDENCE[node.operator] < OPERATOR_PRECEDENCE[parentNode.operator];
}
function formatExpression(state2, node, parentNode, isRightHand) {
  const { generator } = state2;
  if (expressionNeedsParenthesis(state2, node, parentNode, isRightHand)) {
    state2.write("(");
    generator[node.type](node, state2);
    state2.write(")");
  } else {
    generator[node.type](node, state2);
  }
}
function reindent(state2, text, indent, lineEnd) {
  const lines = text.split("\n");
  const end = lines.length - 1;
  state2.write(lines[0].trim());
  if (end > 0) {
    state2.write(lineEnd);
    for (let i2 = 1; i2 < end; i2++) {
      state2.write(indent + lines[i2].trim() + lineEnd);
    }
    state2.write(indent + lines[end].trim());
  }
}
function formatComments(state2, comments, indent, lineEnd) {
  const { length: length2 } = comments;
  for (let i2 = 0; i2 < length2; i2++) {
    const comment = comments[i2];
    state2.write(indent);
    if (comment.type[0] === "L") {
      state2.write("// " + comment.value.trim() + "\n", comment);
    } else {
      state2.write("/*");
      reindent(state2, comment.value, indent, lineEnd);
      state2.write("*/" + lineEnd);
    }
  }
}
function hasCallExpression(node) {
  let currentNode = node;
  while (currentNode != null) {
    const { type } = currentNode;
    if (type[0] === "C" && type[1] === "a") {
      return true;
    } else if (type[0] === "M" && type[1] === "e" && type[2] === "m") {
      currentNode = currentNode.object;
    } else {
      return false;
    }
  }
}
function formatVariableDeclaration(state2, node) {
  const { generator } = state2;
  const { declarations } = node;
  state2.write(node.kind + " ");
  const { length: length2 } = declarations;
  if (length2 > 0) {
    generator.VariableDeclarator(declarations[0], state2);
    for (let i2 = 1; i2 < length2; i2++) {
      state2.write(", ");
      generator.VariableDeclarator(declarations[i2], state2);
    }
  }
}
let ForInStatement, FunctionDeclaration, RestElement, BinaryExpression, ArrayExpression, BlockStatement;
const GENERATOR = {
  /*
  Default generator.
  */
  Program(node, state2) {
    const indent = state2.indent.repeat(state2.indentLevel);
    const { lineEnd, writeComments } = state2;
    if (writeComments && node.comments != null) {
      formatComments(state2, node.comments, indent, lineEnd);
    }
    const statements = node.body;
    const { length: length2 } = statements;
    for (let i2 = 0; i2 < length2; i2++) {
      const statement = statements[i2];
      if (writeComments && statement.comments != null) {
        formatComments(state2, statement.comments, indent, lineEnd);
      }
      state2.write(indent);
      this[statement.type](statement, state2);
      state2.write(lineEnd);
    }
    if (writeComments && node.trailingComments != null) {
      formatComments(state2, node.trailingComments, indent, lineEnd);
    }
  },
  BlockStatement: BlockStatement = function(node, state2) {
    const indent = state2.indent.repeat(state2.indentLevel++);
    const { lineEnd, writeComments } = state2;
    const statementIndent = indent + state2.indent;
    state2.write("{");
    const statements = node.body;
    if (statements != null && statements.length > 0) {
      state2.write(lineEnd);
      if (writeComments && node.comments != null) {
        formatComments(state2, node.comments, statementIndent, lineEnd);
      }
      const { length: length2 } = statements;
      for (let i2 = 0; i2 < length2; i2++) {
        const statement = statements[i2];
        if (writeComments && statement.comments != null) {
          formatComments(state2, statement.comments, statementIndent, lineEnd);
        }
        state2.write(statementIndent);
        this[statement.type](statement, state2);
        state2.write(lineEnd);
      }
      state2.write(indent);
    } else {
      if (writeComments && node.comments != null) {
        state2.write(lineEnd);
        formatComments(state2, node.comments, statementIndent, lineEnd);
        state2.write(indent);
      }
    }
    if (writeComments && node.trailingComments != null) {
      formatComments(state2, node.trailingComments, statementIndent, lineEnd);
    }
    state2.write("}");
    state2.indentLevel--;
  },
  ClassBody: BlockStatement,
  StaticBlock(node, state2) {
    state2.write("static ");
    this.BlockStatement(node, state2);
  },
  EmptyStatement(node, state2) {
    state2.write(";");
  },
  ExpressionStatement(node, state2) {
    const precedence = state2.expressionsPrecedence[node.expression.type];
    if (precedence === NEEDS_PARENTHESES || precedence === 3 && node.expression.left.type[0] === "O") {
      state2.write("(");
      this[node.expression.type](node.expression, state2);
      state2.write(")");
    } else {
      this[node.expression.type](node.expression, state2);
    }
    state2.write(";");
  },
  IfStatement(node, state2) {
    state2.write("if (");
    this[node.test.type](node.test, state2);
    state2.write(") ");
    this[node.consequent.type](node.consequent, state2);
    if (node.alternate != null) {
      state2.write(" else ");
      this[node.alternate.type](node.alternate, state2);
    }
  },
  LabeledStatement(node, state2) {
    this[node.label.type](node.label, state2);
    state2.write(": ");
    this[node.body.type](node.body, state2);
  },
  BreakStatement(node, state2) {
    state2.write("break");
    if (node.label != null) {
      state2.write(" ");
      this[node.label.type](node.label, state2);
    }
    state2.write(";");
  },
  ContinueStatement(node, state2) {
    state2.write("continue");
    if (node.label != null) {
      state2.write(" ");
      this[node.label.type](node.label, state2);
    }
    state2.write(";");
  },
  WithStatement(node, state2) {
    state2.write("with (");
    this[node.object.type](node.object, state2);
    state2.write(") ");
    this[node.body.type](node.body, state2);
  },
  SwitchStatement(node, state2) {
    const indent = state2.indent.repeat(state2.indentLevel++);
    const { lineEnd, writeComments } = state2;
    state2.indentLevel++;
    const caseIndent = indent + state2.indent;
    const statementIndent = caseIndent + state2.indent;
    state2.write("switch (");
    this[node.discriminant.type](node.discriminant, state2);
    state2.write(") {" + lineEnd);
    const { cases: occurences } = node;
    const { length: occurencesCount } = occurences;
    for (let i2 = 0; i2 < occurencesCount; i2++) {
      const occurence = occurences[i2];
      if (writeComments && occurence.comments != null) {
        formatComments(state2, occurence.comments, caseIndent, lineEnd);
      }
      if (occurence.test) {
        state2.write(caseIndent + "case ");
        this[occurence.test.type](occurence.test, state2);
        state2.write(":" + lineEnd);
      } else {
        state2.write(caseIndent + "default:" + lineEnd);
      }
      const { consequent } = occurence;
      const { length: consequentCount } = consequent;
      for (let i3 = 0; i3 < consequentCount; i3++) {
        const statement = consequent[i3];
        if (writeComments && statement.comments != null) {
          formatComments(state2, statement.comments, statementIndent, lineEnd);
        }
        state2.write(statementIndent);
        this[statement.type](statement, state2);
        state2.write(lineEnd);
      }
    }
    state2.indentLevel -= 2;
    state2.write(indent + "}");
  },
  ReturnStatement(node, state2) {
    state2.write("return");
    if (node.argument) {
      state2.write(" ");
      this[node.argument.type](node.argument, state2);
    }
    state2.write(";");
  },
  ThrowStatement(node, state2) {
    state2.write("throw ");
    this[node.argument.type](node.argument, state2);
    state2.write(";");
  },
  TryStatement(node, state2) {
    state2.write("try ");
    this[node.block.type](node.block, state2);
    if (node.handler) {
      const { handler } = node;
      if (handler.param == null) {
        state2.write(" catch ");
      } else {
        state2.write(" catch (");
        this[handler.param.type](handler.param, state2);
        state2.write(") ");
      }
      this[handler.body.type](handler.body, state2);
    }
    if (node.finalizer) {
      state2.write(" finally ");
      this[node.finalizer.type](node.finalizer, state2);
    }
  },
  WhileStatement(node, state2) {
    state2.write("while (");
    this[node.test.type](node.test, state2);
    state2.write(") ");
    this[node.body.type](node.body, state2);
  },
  DoWhileStatement(node, state2) {
    state2.write("do ");
    this[node.body.type](node.body, state2);
    state2.write(" while (");
    this[node.test.type](node.test, state2);
    state2.write(");");
  },
  ForStatement(node, state2) {
    state2.write("for (");
    if (node.init != null) {
      const { init } = node;
      if (init.type[0] === "V") {
        formatVariableDeclaration(state2, init);
      } else {
        this[init.type](init, state2);
      }
    }
    state2.write("; ");
    if (node.test) {
      this[node.test.type](node.test, state2);
    }
    state2.write("; ");
    if (node.update) {
      this[node.update.type](node.update, state2);
    }
    state2.write(") ");
    this[node.body.type](node.body, state2);
  },
  ForInStatement: ForInStatement = function(node, state2) {
    state2.write(`for ${node.await ? "await " : ""}(`);
    const { left } = node;
    if (left.type[0] === "V") {
      formatVariableDeclaration(state2, left);
    } else {
      this[left.type](left, state2);
    }
    state2.write(node.type[3] === "I" ? " in " : " of ");
    this[node.right.type](node.right, state2);
    state2.write(") ");
    this[node.body.type](node.body, state2);
  },
  ForOfStatement: ForInStatement,
  DebuggerStatement(node, state2) {
    state2.write("debugger;", node);
  },
  FunctionDeclaration: FunctionDeclaration = function(node, state2) {
    state2.write(
      (node.async ? "async " : "") + (node.generator ? "function* " : "function ") + (node.id ? node.id.name : ""),
      node
    );
    formatSequence(state2, node.params);
    state2.write(" ");
    this[node.body.type](node.body, state2);
  },
  FunctionExpression: FunctionDeclaration,
  VariableDeclaration(node, state2) {
    formatVariableDeclaration(state2, node);
    state2.write(";");
  },
  VariableDeclarator(node, state2) {
    this[node.id.type](node.id, state2);
    if (node.init != null) {
      state2.write(" = ");
      this[node.init.type](node.init, state2);
    }
  },
  ClassDeclaration(node, state2) {
    state2.write("class " + (node.id ? `${node.id.name} ` : ""), node);
    if (node.superClass) {
      state2.write("extends ");
      const { superClass } = node;
      const { type } = superClass;
      const precedence = state2.expressionsPrecedence[type];
      if ((type[0] !== "C" || type[1] !== "l" || type[5] !== "E") && (precedence === NEEDS_PARENTHESES || precedence < state2.expressionsPrecedence.ClassExpression)) {
        state2.write("(");
        this[node.superClass.type](superClass, state2);
        state2.write(")");
      } else {
        this[superClass.type](superClass, state2);
      }
      state2.write(" ");
    }
    this.ClassBody(node.body, state2);
  },
  ImportDeclaration(node, state2) {
    state2.write("import ");
    const { specifiers } = node;
    const { length: length2 } = specifiers;
    let i2 = 0;
    if (length2 > 0) {
      for (; i2 < length2; ) {
        if (i2 > 0) {
          state2.write(", ");
        }
        const specifier = specifiers[i2];
        const type = specifier.type[6];
        if (type === "D") {
          state2.write(specifier.local.name, specifier);
          i2++;
        } else if (type === "N") {
          state2.write("* as " + specifier.local.name, specifier);
          i2++;
        } else {
          break;
        }
      }
      if (i2 < length2) {
        state2.write("{");
        for (; ; ) {
          const specifier = specifiers[i2];
          const { name } = specifier.imported;
          state2.write(name, specifier);
          if (name !== specifier.local.name) {
            state2.write(" as " + specifier.local.name);
          }
          if (++i2 < length2) {
            state2.write(", ");
          } else {
            break;
          }
        }
        state2.write("}");
      }
      state2.write(" from ");
    }
    this.Literal(node.source, state2);
    state2.write(";");
  },
  ImportExpression(node, state2) {
    state2.write("import(");
    this[node.source.type](node.source, state2);
    state2.write(")");
  },
  ExportDefaultDeclaration(node, state2) {
    state2.write("export default ");
    this[node.declaration.type](node.declaration, state2);
    if (state2.expressionsPrecedence[node.declaration.type] != null && node.declaration.type[0] !== "F") {
      state2.write(";");
    }
  },
  ExportNamedDeclaration(node, state2) {
    state2.write("export ");
    if (node.declaration) {
      this[node.declaration.type](node.declaration, state2);
    } else {
      state2.write("{");
      const { specifiers } = node, { length: length2 } = specifiers;
      if (length2 > 0) {
        for (let i2 = 0; ; ) {
          const specifier = specifiers[i2];
          const { name } = specifier.local;
          state2.write(name, specifier);
          if (name !== specifier.exported.name) {
            state2.write(" as " + specifier.exported.name);
          }
          if (++i2 < length2) {
            state2.write(", ");
          } else {
            break;
          }
        }
      }
      state2.write("}");
      if (node.source) {
        state2.write(" from ");
        this.Literal(node.source, state2);
      }
      state2.write(";");
    }
  },
  ExportAllDeclaration(node, state2) {
    if (node.exported != null) {
      state2.write("export * as " + node.exported.name + " from ");
    } else {
      state2.write("export * from ");
    }
    this.Literal(node.source, state2);
    state2.write(";");
  },
  MethodDefinition(node, state2) {
    if (node.static) {
      state2.write("static ");
    }
    const kind = node.kind[0];
    if (kind === "g" || kind === "s") {
      state2.write(node.kind + " ");
    }
    if (node.value.async) {
      state2.write("async ");
    }
    if (node.value.generator) {
      state2.write("*");
    }
    if (node.computed) {
      state2.write("[");
      this[node.key.type](node.key, state2);
      state2.write("]");
    } else {
      this[node.key.type](node.key, state2);
    }
    formatSequence(state2, node.value.params);
    state2.write(" ");
    this[node.value.body.type](node.value.body, state2);
  },
  ClassExpression(node, state2) {
    this.ClassDeclaration(node, state2);
  },
  ArrowFunctionExpression(node, state2) {
    state2.write(node.async ? "async " : "", node);
    const { params } = node;
    if (params != null) {
      if (params.length === 1 && params[0].type[0] === "I") {
        state2.write(params[0].name, params[0]);
      } else {
        formatSequence(state2, node.params);
      }
    }
    state2.write(" => ");
    if (node.body.type[0] === "O") {
      state2.write("(");
      this.ObjectExpression(node.body, state2);
      state2.write(")");
    } else {
      this[node.body.type](node.body, state2);
    }
  },
  ThisExpression(node, state2) {
    state2.write("this", node);
  },
  Super(node, state2) {
    state2.write("super", node);
  },
  RestElement: RestElement = function(node, state2) {
    state2.write("...");
    this[node.argument.type](node.argument, state2);
  },
  SpreadElement: RestElement,
  YieldExpression(node, state2) {
    state2.write(node.delegate ? "yield*" : "yield");
    if (node.argument) {
      state2.write(" ");
      this[node.argument.type](node.argument, state2);
    }
  },
  AwaitExpression(node, state2) {
    state2.write("await ", node);
    formatExpression(state2, node.argument, node);
  },
  TemplateLiteral(node, state2) {
    const { quasis, expressions } = node;
    state2.write("`");
    const { length: length2 } = expressions;
    for (let i2 = 0; i2 < length2; i2++) {
      const expression = expressions[i2];
      const quasi2 = quasis[i2];
      state2.write(quasi2.value.raw, quasi2);
      state2.write("${");
      this[expression.type](expression, state2);
      state2.write("}");
    }
    const quasi = quasis[quasis.length - 1];
    state2.write(quasi.value.raw, quasi);
    state2.write("`");
  },
  TemplateElement(node, state2) {
    state2.write(node.value.raw, node);
  },
  TaggedTemplateExpression(node, state2) {
    formatExpression(state2, node.tag, node);
    this[node.quasi.type](node.quasi, state2);
  },
  ArrayExpression: ArrayExpression = function(node, state2) {
    state2.write("[");
    if (node.elements.length > 0) {
      const { elements } = node, { length: length2 } = elements;
      for (let i2 = 0; ; ) {
        const element = elements[i2];
        if (element != null) {
          this[element.type](element, state2);
        }
        if (++i2 < length2) {
          state2.write(", ");
        } else {
          if (element == null) {
            state2.write(", ");
          }
          break;
        }
      }
    }
    state2.write("]");
  },
  ArrayPattern: ArrayExpression,
  ObjectExpression(node, state2) {
    const indent = state2.indent.repeat(state2.indentLevel++);
    const { lineEnd, writeComments } = state2;
    const propertyIndent = indent + state2.indent;
    state2.write("{");
    if (node.properties.length > 0) {
      state2.write(lineEnd);
      if (writeComments && node.comments != null) {
        formatComments(state2, node.comments, propertyIndent, lineEnd);
      }
      const comma = "," + lineEnd;
      const { properties } = node, { length: length2 } = properties;
      for (let i2 = 0; ; ) {
        const property = properties[i2];
        if (writeComments && property.comments != null) {
          formatComments(state2, property.comments, propertyIndent, lineEnd);
        }
        state2.write(propertyIndent);
        this[property.type](property, state2);
        if (++i2 < length2) {
          state2.write(comma);
        } else {
          break;
        }
      }
      state2.write(lineEnd);
      if (writeComments && node.trailingComments != null) {
        formatComments(state2, node.trailingComments, propertyIndent, lineEnd);
      }
      state2.write(indent + "}");
    } else if (writeComments) {
      if (node.comments != null) {
        state2.write(lineEnd);
        formatComments(state2, node.comments, propertyIndent, lineEnd);
        if (node.trailingComments != null) {
          formatComments(state2, node.trailingComments, propertyIndent, lineEnd);
        }
        state2.write(indent + "}");
      } else if (node.trailingComments != null) {
        state2.write(lineEnd);
        formatComments(state2, node.trailingComments, propertyIndent, lineEnd);
        state2.write(indent + "}");
      } else {
        state2.write("}");
      }
    } else {
      state2.write("}");
    }
    state2.indentLevel--;
  },
  Property(node, state2) {
    if (node.method || node.kind[0] !== "i") {
      this.MethodDefinition(node, state2);
    } else {
      if (!node.shorthand) {
        if (node.computed) {
          state2.write("[");
          this[node.key.type](node.key, state2);
          state2.write("]");
        } else {
          this[node.key.type](node.key, state2);
        }
        state2.write(": ");
      }
      this[node.value.type](node.value, state2);
    }
  },
  PropertyDefinition(node, state2) {
    if (node.static) {
      state2.write("static ");
    }
    if (node.computed) {
      state2.write("[");
    }
    this[node.key.type](node.key, state2);
    if (node.computed) {
      state2.write("]");
    }
    if (node.value == null) {
      if (node.key.type[0] !== "F") {
        state2.write(";");
      }
      return;
    }
    state2.write(" = ");
    this[node.value.type](node.value, state2);
    state2.write(";");
  },
  ObjectPattern(node, state2) {
    state2.write("{");
    if (node.properties.length > 0) {
      const { properties } = node, { length: length2 } = properties;
      for (let i2 = 0; ; ) {
        this[properties[i2].type](properties[i2], state2);
        if (++i2 < length2) {
          state2.write(", ");
        } else {
          break;
        }
      }
    }
    state2.write("}");
  },
  SequenceExpression(node, state2) {
    formatSequence(state2, node.expressions);
  },
  UnaryExpression(node, state2) {
    if (node.prefix) {
      const {
        operator,
        argument,
        argument: { type }
      } = node;
      state2.write(operator);
      const needsParentheses = expressionNeedsParenthesis(state2, argument, node);
      if (!needsParentheses && (operator.length > 1 || type[0] === "U" && (type[1] === "n" || type[1] === "p") && argument.prefix && argument.operator[0] === operator && (operator === "+" || operator === "-"))) {
        state2.write(" ");
      }
      if (needsParentheses) {
        state2.write(operator.length > 1 ? " (" : "(");
        this[type](argument, state2);
        state2.write(")");
      } else {
        this[type](argument, state2);
      }
    } else {
      this[node.argument.type](node.argument, state2);
      state2.write(node.operator);
    }
  },
  UpdateExpression(node, state2) {
    if (node.prefix) {
      state2.write(node.operator);
      this[node.argument.type](node.argument, state2);
    } else {
      this[node.argument.type](node.argument, state2);
      state2.write(node.operator);
    }
  },
  AssignmentExpression(node, state2) {
    this[node.left.type](node.left, state2);
    state2.write(" " + node.operator + " ");
    this[node.right.type](node.right, state2);
  },
  AssignmentPattern(node, state2) {
    this[node.left.type](node.left, state2);
    state2.write(" = ");
    this[node.right.type](node.right, state2);
  },
  BinaryExpression: BinaryExpression = function(node, state2) {
    const isIn = node.operator === "in";
    if (isIn) {
      state2.write("(");
    }
    formatExpression(state2, node.left, node, false);
    state2.write(" " + node.operator + " ");
    formatExpression(state2, node.right, node, true);
    if (isIn) {
      state2.write(")");
    }
  },
  LogicalExpression: BinaryExpression,
  ConditionalExpression(node, state2) {
    const { test: test2 } = node;
    const precedence = state2.expressionsPrecedence[test2.type];
    if (precedence === NEEDS_PARENTHESES || precedence <= state2.expressionsPrecedence.ConditionalExpression) {
      state2.write("(");
      this[test2.type](test2, state2);
      state2.write(")");
    } else {
      this[test2.type](test2, state2);
    }
    state2.write(" ? ");
    this[node.consequent.type](node.consequent, state2);
    state2.write(" : ");
    this[node.alternate.type](node.alternate, state2);
  },
  NewExpression(node, state2) {
    state2.write("new ");
    const precedence = state2.expressionsPrecedence[node.callee.type];
    if (precedence === NEEDS_PARENTHESES || precedence < state2.expressionsPrecedence.CallExpression || hasCallExpression(node.callee)) {
      state2.write("(");
      this[node.callee.type](node.callee, state2);
      state2.write(")");
    } else {
      this[node.callee.type](node.callee, state2);
    }
    formatSequence(state2, node["arguments"]);
  },
  CallExpression(node, state2) {
    const precedence = state2.expressionsPrecedence[node.callee.type];
    if (precedence === NEEDS_PARENTHESES || precedence < state2.expressionsPrecedence.CallExpression) {
      state2.write("(");
      this[node.callee.type](node.callee, state2);
      state2.write(")");
    } else {
      this[node.callee.type](node.callee, state2);
    }
    if (node.optional) {
      state2.write("?.");
    }
    formatSequence(state2, node["arguments"]);
  },
  ChainExpression(node, state2) {
    this[node.expression.type](node.expression, state2);
  },
  MemberExpression(node, state2) {
    const precedence = state2.expressionsPrecedence[node.object.type];
    if (precedence === NEEDS_PARENTHESES || precedence < state2.expressionsPrecedence.MemberExpression) {
      state2.write("(");
      this[node.object.type](node.object, state2);
      state2.write(")");
    } else {
      this[node.object.type](node.object, state2);
    }
    if (node.computed) {
      if (node.optional) {
        state2.write("?.");
      }
      state2.write("[");
      this[node.property.type](node.property, state2);
      state2.write("]");
    } else {
      if (node.optional) {
        state2.write("?.");
      } else {
        state2.write(".");
      }
      this[node.property.type](node.property, state2);
    }
  },
  MetaProperty(node, state2) {
    state2.write(node.meta.name + "." + node.property.name, node);
  },
  Identifier(node, state2) {
    state2.write(node.name, node);
  },
  PrivateIdentifier(node, state2) {
    state2.write(`#${node.name}`, node);
  },
  Literal(node, state2) {
    if (node.raw != null) {
      state2.write(node.raw, node);
    } else if (node.regex != null) {
      this.RegExpLiteral(node, state2);
    } else if (node.bigint != null) {
      state2.write(node.bigint + "n", node);
    } else {
      state2.write(stringify(node.value), node);
    }
  },
  RegExpLiteral(node, state2) {
    const { regex: regex2 } = node;
    state2.write(`/${regex2.pattern}/${regex2.flags}`, node);
  }
};
const EMPTY_OBJECT = {};
class State {
  constructor(options2) {
    const setup2 = options2 == null ? EMPTY_OBJECT : options2;
    this.output = "";
    if (setup2.output != null) {
      this.output = setup2.output;
      this.write = this.writeToStream;
    } else {
      this.output = "";
    }
    this.generator = setup2.generator != null ? setup2.generator : GENERATOR;
    this.expressionsPrecedence = setup2.expressionsPrecedence != null ? setup2.expressionsPrecedence : EXPRESSIONS_PRECEDENCE;
    this.indent = setup2.indent != null ? setup2.indent : "  ";
    this.lineEnd = setup2.lineEnd != null ? setup2.lineEnd : "\n";
    this.indentLevel = setup2.startingIndentLevel != null ? setup2.startingIndentLevel : 0;
    this.writeComments = setup2.comments ? setup2.comments : false;
    if (setup2.sourceMap != null) {
      this.write = setup2.output == null ? this.writeAndMap : this.writeToStreamAndMap;
      this.sourceMap = setup2.sourceMap;
      this.line = 1;
      this.column = 0;
      this.lineEndSize = this.lineEnd.split("\n").length - 1;
      this.mapping = {
        original: null,
        // Uses the entire state to avoid generating ephemeral objects
        generated: this,
        name: void 0,
        source: setup2.sourceMap.file || setup2.sourceMap._file
      };
    }
  }
  write(code2) {
    this.output += code2;
  }
  writeToStream(code2) {
    this.output.write(code2);
  }
  writeAndMap(code2, node) {
    this.output += code2;
    this.map(code2, node);
  }
  writeToStreamAndMap(code2, node) {
    this.output.write(code2);
    this.map(code2, node);
  }
  map(code2, node) {
    if (node != null) {
      const { type } = node;
      if (type[0] === "L" && type[2] === "n") {
        this.column = 0;
        this.line++;
        return;
      }
      if (node.loc != null) {
        const { mapping } = this;
        mapping.original = node.loc.start;
        mapping.name = node.name;
        this.sourceMap.addMapping(mapping);
      }
      if (type[0] === "T" && type[8] === "E" || type[0] === "L" && type[1] === "i" && typeof node.value === "string") {
        const { length: length3 } = code2;
        let { column, line } = this;
        for (let i2 = 0; i2 < length3; i2++) {
          if (code2[i2] === "\n") {
            column = 0;
            line++;
          } else {
            column++;
          }
        }
        this.column = column;
        this.line = line;
        return;
      }
    }
    const { length: length2 } = code2;
    const { lineEnd } = this;
    if (length2 > 0) {
      if (this.lineEndSize > 0 && (lineEnd.length === 1 ? code2[length2 - 1] === lineEnd : code2.endsWith(lineEnd))) {
        this.line += this.lineEndSize;
        this.column = 0;
      } else {
        this.column += length2;
      }
    }
  }
  toString() {
    return this.output;
  }
}
function generate(node, options2) {
  const state2 = new State(options2);
  state2.generator[node.type](node, state2);
  return state2.output;
}
var astravel = {};
var defaultTraveler = {};
var hasRequiredDefaultTraveler;
function requireDefaultTraveler() {
  if (hasRequiredDefaultTraveler)
    return defaultTraveler;
  hasRequiredDefaultTraveler = 1;
  (function(exports2) {
    (function(global2, factory) {
      {
        factory(exports2);
      }
    })(commonjsGlobal, function(exports3) {
      exports3.__esModule = true;
      function _classCallCheck2(instance2, Constructor) {
        if (!(instance2 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var ForInStatement2 = void 0, FunctionDeclaration2 = void 0, RestElement2 = void 0, BinaryExpression2 = void 0, ArrayExpression2 = void 0;
      var ignore = Function.prototype;
      var Found = function Found2(node, state2) {
        _classCallCheck2(this, Found2);
        this.node = node;
        this.state = state2;
      };
      exports3.default = {
        // Basic methods
        go: function go(node, state2) {
          this[node.type](node, state2);
        },
        find: function find(predicate, node, state2) {
          var finder = Object.create(this);
          finder.go = function(node2, state3) {
            if (predicate(node2, state3)) {
              throw new Found(node2, state3);
            }
            this[node2.type](node2, state3);
          };
          try {
            finder.go(node, state2);
          } catch (error2) {
            if (error2 instanceof Found) {
              return error2;
            } else {
              throw error2;
            }
          }
        },
        makeChild: function makeChild() {
          var properties = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var traveler = Object.create(this);
          traveler.super = this;
          for (var key in properties) {
            traveler[key] = properties[key];
          }
          return traveler;
        },
        // JavaScript 5
        Program: function Program(node, state2) {
          var statements = node.body, length2 = statements.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(statements[i2], state2);
          }
        },
        BlockStatement: function BlockStatement2(node, state2) {
          var statements = node.body;
          if (statements != null) {
            for (var i2 = 0, length2 = statements.length; i2 < length2; i2++) {
              this.go(statements[i2], state2);
            }
          }
        },
        EmptyStatement: ignore,
        ExpressionStatement: function ExpressionStatement(node, state2) {
          this.go(node.expression, state2);
        },
        IfStatement: function IfStatement(node, state2) {
          this.go(node.test, state2);
          this.go(node.consequent, state2);
          if (node.alternate != null) {
            this.go(node.alternate, state2);
          }
        },
        LabeledStatement: function LabeledStatement(node, state2) {
          this.go(node.label, state2);
          this.go(node.body, state2);
        },
        BreakStatement: function BreakStatement(node, state2) {
          if (node.label) {
            this.go(node.label, state2);
          }
        },
        ContinueStatement: function ContinueStatement(node, state2) {
          if (node.label) {
            this.go(node.label, state2);
          }
        },
        WithStatement: function WithStatement(node, state2) {
          this.go(node.object, state2);
          this.go(node.body, state2);
        },
        SwitchStatement: function SwitchStatement(node, state2) {
          this.go(node.discriminant, state2);
          var cases = node.cases, length2 = cases.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(cases[i2], state2);
          }
        },
        SwitchCase: function SwitchCase(node, state2) {
          if (node.test != null) {
            this.go(node.test, state2);
          }
          var statements = node.consequent, length2 = statements.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(statements[i2], state2);
          }
        },
        ReturnStatement: function ReturnStatement(node, state2) {
          if (node.argument) {
            this.go(node.argument, state2);
          }
        },
        ThrowStatement: function ThrowStatement(node, state2) {
          this.go(node.argument, state2);
        },
        TryStatement: function TryStatement(node, state2) {
          this.go(node.block, state2);
          if (node.handler != null) {
            this.go(node.handler, state2);
          }
          if (node.finalizer != null) {
            this.go(node.finalizer, state2);
          }
        },
        CatchClause: function CatchClause(node, state2) {
          if (node.param != null) {
            this.go(node.param, state2);
          }
          this.go(node.body, state2);
        },
        WhileStatement: function WhileStatement(node, state2) {
          this.go(node.test, state2);
          this.go(node.body, state2);
        },
        DoWhileStatement: function DoWhileStatement(node, state2) {
          this.go(node.body, state2);
          this.go(node.test, state2);
        },
        ForStatement: function ForStatement(node, state2) {
          if (node.init != null) {
            this.go(node.init, state2);
          }
          if (node.test != null) {
            this.go(node.test, state2);
          }
          if (node.update != null) {
            this.go(node.update, state2);
          }
          this.go(node.body, state2);
        },
        ForInStatement: ForInStatement2 = function ForInStatement3(node, state2) {
          this.go(node.left, state2);
          this.go(node.right, state2);
          this.go(node.body, state2);
        },
        DebuggerStatement: ignore,
        FunctionDeclaration: FunctionDeclaration2 = function FunctionDeclaration3(node, state2) {
          if (node.id != null) {
            this.go(node.id, state2);
          }
          var params = node.params;
          if (params != null) {
            for (var i2 = 0, length2 = params.length; i2 < length2; i2++) {
              this.go(params[i2], state2);
            }
          }
          this.go(node.body, state2);
        },
        VariableDeclaration: function VariableDeclaration(node, state2) {
          var declarations = node.declarations, length2 = declarations.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(declarations[i2], state2);
          }
        },
        VariableDeclarator: function VariableDeclarator(node, state2) {
          this.go(node.id, state2);
          if (node.init != null) {
            this.go(node.init, state2);
          }
        },
        ArrowFunctionExpression: function ArrowFunctionExpression(node, state2) {
          var params = node.params;
          if (params != null) {
            for (var i2 = 0, length2 = params.length; i2 < length2; i2++) {
              this.go(params[i2], state2);
            }
          }
          this.go(node.body, state2);
        },
        ThisExpression: ignore,
        ArrayExpression: ArrayExpression2 = function ArrayExpression3(node, state2) {
          var elements = node.elements, length2 = elements.length;
          for (var i2 = 0; i2 < length2; i2++) {
            var element = elements[i2];
            if (element != null) {
              this.go(elements[i2], state2);
            }
          }
        },
        ObjectExpression: function ObjectExpression(node, state2) {
          var properties = node.properties, length2 = properties.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(properties[i2], state2);
          }
        },
        Property: function Property(node, state2) {
          this.go(node.key, state2);
          if (!node.shorthand) {
            this.go(node.value, state2);
          }
        },
        FunctionExpression: FunctionDeclaration2,
        SequenceExpression: function SequenceExpression(node, state2) {
          var expressions = node.expressions, length2 = expressions.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(expressions[i2], state2);
          }
        },
        UnaryExpression: function UnaryExpression(node, state2) {
          this.go(node.argument, state2);
        },
        UpdateExpression: function UpdateExpression(node, state2) {
          this.go(node.argument, state2);
        },
        AssignmentExpression: function AssignmentExpression(node, state2) {
          this.go(node.left, state2);
          this.go(node.right, state2);
        },
        BinaryExpression: BinaryExpression2 = function BinaryExpression3(node, state2) {
          this.go(node.left, state2);
          this.go(node.right, state2);
        },
        LogicalExpression: BinaryExpression2,
        ConditionalExpression: function ConditionalExpression(node, state2) {
          this.go(node.test, state2);
          this.go(node.consequent, state2);
          this.go(node.alternate, state2);
        },
        NewExpression: function NewExpression(node, state2) {
          this.CallExpression(node, state2);
        },
        CallExpression: function CallExpression(node, state2) {
          this.go(node.callee, state2);
          var args = node["arguments"], length2 = args.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(args[i2], state2);
          }
        },
        MemberExpression: function MemberExpression(node, state2) {
          this.go(node.object, state2);
          this.go(node.property, state2);
        },
        Identifier: ignore,
        Literal: ignore,
        // JavaScript 6
        ForOfStatement: ForInStatement2,
        ClassDeclaration: function ClassDeclaration(node, state2) {
          if (node.id) {
            this.go(node.id, state2);
          }
          if (node.superClass) {
            this.go(node.superClass, state2);
          }
          this.go(node.body, state2);
        },
        ClassBody: function ClassBody(node, state2) {
          var body = node.body, length2 = body.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(body[i2], state2);
          }
        },
        ImportDeclaration: function ImportDeclaration(node, state2) {
          var specifiers = node.specifiers, length2 = specifiers.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(specifiers[i2], state2);
          }
          this.go(node.source, state2);
        },
        ImportNamespaceSpecifier: function ImportNamespaceSpecifier(node, state2) {
          this.go(node.local, state2);
        },
        ImportDefaultSpecifier: function ImportDefaultSpecifier(node, state2) {
          this.go(node.local, state2);
        },
        ImportSpecifier: function ImportSpecifier(node, state2) {
          this.go(node.imported, state2);
          this.go(node.local, state2);
        },
        ExportDefaultDeclaration: function ExportDefaultDeclaration(node, state2) {
          this.go(node.declaration, state2);
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(node, state2) {
          if (node.declaration) {
            this.go(node.declaration, state2);
          }
          var specifiers = node.specifiers, length2 = specifiers.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(specifiers[i2], state2);
          }
          if (node.source) {
            this.go(node.source, state2);
          }
        },
        ExportSpecifier: function ExportSpecifier(node, state2) {
          this.go(node.local, state2);
          this.go(node.exported, state2);
        },
        ExportAllDeclaration: function ExportAllDeclaration(node, state2) {
          this.go(node.source, state2);
        },
        MethodDefinition: function MethodDefinition(node, state2) {
          this.go(node.key, state2);
          this.go(node.value, state2);
        },
        ClassExpression: function ClassExpression(node, state2) {
          this.ClassDeclaration(node, state2);
        },
        Super: ignore,
        RestElement: RestElement2 = function RestElement3(node, state2) {
          this.go(node.argument, state2);
        },
        SpreadElement: RestElement2,
        YieldExpression: function YieldExpression(node, state2) {
          if (node.argument) {
            this.go(node.argument, state2);
          }
        },
        TaggedTemplateExpression: function TaggedTemplateExpression(node, state2) {
          this.go(node.tag, state2);
          this.go(node.quasi, state2);
        },
        TemplateLiteral: function TemplateLiteral(node, state2) {
          var quasis = node.quasis, expressions = node.expressions;
          for (var i2 = 0, length2 = expressions.length; i2 < length2; i2++) {
            this.go(expressions[i2], state2);
          }
          for (var _i2 = 0, _length = quasis.length; _i2 < _length; _i2++) {
            this.go(quasis[_i2], state2);
          }
        },
        TemplateElement: ignore,
        ObjectPattern: function ObjectPattern(node, state2) {
          var properties = node.properties, length2 = properties.length;
          for (var i2 = 0; i2 < length2; i2++) {
            this.go(properties[i2], state2);
          }
        },
        ArrayPattern: ArrayExpression2,
        AssignmentPattern: function AssignmentPattern(node, state2) {
          this.go(node.left, state2);
          this.go(node.right, state2);
        },
        MetaProperty: function MetaProperty(node, state2) {
          this.go(node.meta, state2);
          this.go(node.property, state2);
        },
        // JavaScript 7
        AwaitExpression: function AwaitExpression(node, state2) {
          this.go(node.argument, state2);
        }
      };
    });
  })(defaultTraveler);
  return defaultTraveler;
}
var attachComments = {};
var hasRequiredAttachComments;
function requireAttachComments() {
  if (hasRequiredAttachComments)
    return attachComments;
  hasRequiredAttachComments = 1;
  (function(exports2) {
    (function(global2, factory) {
      {
        factory(exports2, requireDefaultTraveler());
      }
    })(commonjsGlobal, function(exports3, _defaultTraveler) {
      exports3.__esModule = true;
      exports3.default = function(node, comments) {
        customTraveler[node.type](node, {
          comments,
          index: 0
        });
        return node;
      };
      var _defaultTraveler2 = _interopRequireDefault(_defaultTraveler);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      function attachComments2(parent2, children, findHeadingComments, state2, traveler) {
        var index2 = state2.index, comments = state2.comments;
        var comment = comments[index2];
        var boundComments = void 0, trailingComments = void 0;
        if (comment != null) {
          if (children == null || children.length === 0) {
            boundComments = parent2.comments != null ? parent2.comments : [];
            while (comment != null && comment.end < parent2.end) {
              boundComments.push(comment);
              comment = comments[++index2];
            }
            state2.index = index2;
            if (boundComments.length !== 0 && parent2.comments == null)
              parent2.comments = boundComments;
          } else {
            if (findHeadingComments) {
              boundComments = parent2.comments != null ? parent2.comments : [];
              var start = children[0].start;
              while (comment != null && comment.type[0] === "B" && comment.end < start) {
                boundComments.push(comment);
                comment = comments[++index2];
              }
              if (boundComments.length !== 0 && parent2.comments == null)
                parent2.comments = boundComments;
            }
            for (var i2 = 0, length2 = children.length; comment != null && i2 < length2; i2++) {
              var child = children[i2];
              boundComments = [];
              while (comment != null && comment.end < child.start) {
                boundComments.push(comment);
                comment = comments[++index2];
              }
              if (comment != null && comment.type[0] === "L") {
                if (comment.loc.start.line === child.loc.end.line) {
                  boundComments.push(comment);
                  comment = comments[++index2];
                }
              }
              if (boundComments.length !== 0)
                child.comments = boundComments;
              state2.index = index2;
              traveler[child.type](child, state2);
              index2 = state2.index;
              comment = comments[index2];
            }
            trailingComments = [];
            while (comment != null && comment.end < parent2.end) {
              trailingComments.push(comment);
              comment = comments[++index2];
            }
            if (trailingComments.length !== 0)
              parent2.trailingComments = trailingComments;
            state2.index = index2;
          }
        }
      }
      var Program = void 0;
      var customTraveler = _defaultTraveler2.default.makeChild(
        {
          Program: Program = function Program2(node, state2) {
            attachComments2(node, node.body, true, state2, this);
          },
          BlockStatement: Program,
          ObjectExpression: function ObjectExpression(node, state2) {
            attachComments2(node, node.properties, true, state2, this);
          },
          ArrayExpression: function ArrayExpression2(node, state2) {
            attachComments2(node, node.elements, true, state2, this);
          },
          SwitchStatement: function SwitchStatement(node, state2) {
            attachComments2(node, node.cases, false, state2, this);
          },
          SwitchCase: function SwitchCase(node, state2) {
            attachComments2(node, node.consequent, false, state2, this);
          }
        }
        // TODO: Consider ArrayExpression ?
      );
    });
  })(attachComments);
  return attachComments;
}
(function(exports2) {
  (function(global2, factory) {
    {
      factory(exports2, requireDefaultTraveler(), requireAttachComments());
    }
  })(commonjsGlobal, function(exports3, _defaultTraveler, _attachComments) {
    exports3.__esModule = true;
    exports3.makeTraveler = exports3.attachComments = exports3.defaultTraveler = void 0;
    var _defaultTraveler2 = _interopRequireDefault(_defaultTraveler);
    var _attachComments2 = _interopRequireDefault(_attachComments);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function makeTraveler(properties) {
      return _defaultTraveler2.default.makeChild(properties);
    }
    exports3.defaultTraveler = _defaultTraveler2.default;
    exports3.attachComments = _attachComments2.default;
    exports3.makeTraveler = makeTraveler;
  });
})(astravel);
class UndoStack {
  constructor(limit) {
    this.stack = [];
    this.index = -1;
    this.limit = limit;
  }
  atTop() {
    return this.index === -1;
  }
  canUndo() {
    if (this.stack.length === 0)
      return false;
    return this.index === -1 || this.index > 0;
  }
  canRedo() {
    if (this.stack.length === 0 || this.index === -1)
      return false;
    return this.index < this.stack.length - 1;
  }
  push(item) {
    if (this.index >= 0) {
      while (this.index < this.stack.length)
        this.stack.pop();
      this.index = -1;
    }
    if (this.limit && this.stack.length > this.limit) {
      this.stack.shift();
    }
    this.stack.push(item);
  }
  undo() {
    if (this.stack.length === 0)
      return void 0;
    if (this.index === -1) {
      this.index = this.stack.length - 1;
    }
    if (this.index > 0)
      this.index--;
    let v = this.stack[this.index];
    return v;
  }
  redo() {
    if (this.stack.length === 0 || this.index === -1)
      return void 0;
    let nextX = this.index + 1;
    if (nextX >= this.stack.length)
      return void 0;
    this.index = nextX;
    return this.stack[this.index];
  }
}
const glslTransforms = () => [
  {
    name: "noise",
    type: "src",
    inputs: [
      {
        type: "float",
        name: "scale",
        default: 10
      },
      {
        type: "float",
        name: "offset",
        default: 0.1
      }
    ],
    glsl: `   return vec4(vec3(_noise(vec3(_st*scale, offset*time))), 1.0);`
  },
  {
    name: "voronoi",
    type: "src",
    inputs: [
      {
        type: "float",
        name: "scale",
        default: 5
      },
      {
        type: "float",
        name: "speed",
        default: 0.3
      },
      {
        type: "float",
        name: "blending",
        default: 0.3
      }
    ],
    glsl: `   vec3 color = vec3(.0);
   // Scale
   _st *= scale;
   // Tile the space
   vec2 i_st = floor(_st);
   vec2 f_st = fract(_st);
   float m_dist = 10.;  // minimun distance
   vec2 m_point;        // minimum point
   for (int j=-1; j<=1; j++ ) {
   for (int i=-1; i<=1; i++ ) {
   vec2 neighbor = vec2(float(i),float(j));
   vec2 p = i_st + neighbor;
   vec2 point = fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
   point = 0.5 + 0.5*sin(time*speed + 6.2831*point);
   vec2 diff = neighbor + point - f_st;
   float dist = length(diff);
   if( dist < m_dist ) {
   m_dist = dist;
   m_point = point;
   }
   }
   }
   // Assign a color using the closest point position
   color += dot(m_point,vec2(.3,.6));
   color *= 1.0 - blending*m_dist;
   return vec4(color, 1.0);`
  },
  {
    name: "osc",
    type: "src",
    inputs: [
      {
        type: "float",
        name: "frequency",
        default: 60
      },
      {
        type: "float",
        name: "sync",
        default: 0.1
      },
      {
        type: "float",
        name: "offset",
        default: 0
      }
    ],
    glsl: `   vec2 st = _st;
   float r = sin((st.x-offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   float g = sin((st.x+time*sync)*frequency)*0.5 + 0.5;
   float b = sin((st.x+offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   return vec4(r, g, b, 1.0);`
  },
  {
    name: "shape",
    type: "src",
    inputs: [
      {
        type: "float",
        name: "sides",
        default: 3
      },
      {
        type: "float",
        name: "radius",
        default: 0.3
      },
      {
        type: "float",
        name: "smoothing",
        default: 0.01
      }
    ],
    glsl: `   vec2 st = _st * 2. - 1.;
   // Angle and radius from the current pixel
   float a = atan(st.x,st.y)+3.1416;
   float r = (2.*3.1416)/sides;
   float d = cos(floor(.5+a/r)*r-a)*length(st);
   return vec4(vec3(1.0-smoothstep(radius,radius + smoothing + 0.0000001,d)), 1.0);`
  },
  {
    name: "gradient",
    type: "src",
    inputs: [
      {
        type: "float",
        name: "speed",
        default: 0
      }
    ],
    glsl: `   return vec4(_st, sin(time*speed), 1.0);`
  },
  {
    name: "src",
    type: "src",
    inputs: [
      {
        type: "sampler2D",
        name: "tex",
        default: NaN
      }
    ],
    glsl: `   //  vec2 uv = gl_FragCoord.xy/vec2(1280., 720.);
   return texture2D(tex, fract(_st));`
  },
  {
    name: "solid",
    type: "src",
    inputs: [
      {
        type: "float",
        name: "r",
        default: 0
      },
      {
        type: "float",
        name: "g",
        default: 0
      },
      {
        type: "float",
        name: "b",
        default: 0
      },
      {
        type: "float",
        name: "a",
        default: 1
      }
    ],
    glsl: `   return vec4(r, g, b, a);`
  },
  {
    name: "rotate",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "angle",
        default: 10
      },
      {
        type: "float",
        name: "speed",
        default: 0
      }
    ],
    glsl: `   vec2 xy = _st - vec2(0.5);
   float ang = angle + speed *time;
   xy = mat2(cos(ang),-sin(ang), sin(ang),cos(ang))*xy;
   xy += 0.5;
   return xy;`
  },
  {
    name: "scale",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 1.5
      },
      {
        type: "float",
        name: "xMult",
        default: 1
      },
      {
        type: "float",
        name: "yMult",
        default: 1
      },
      {
        type: "float",
        name: "offsetX",
        default: 0.5
      },
      {
        type: "float",
        name: "offsetY",
        default: 0.5
      }
    ],
    glsl: `   vec2 xy = _st - vec2(offsetX, offsetY);
   xy*=(1.0/vec2(amount*xMult, amount*yMult));
   xy+=vec2(offsetX, offsetY);
   return xy;
   `
  },
  {
    name: "pixelate",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "pixelX",
        default: 20
      },
      {
        type: "float",
        name: "pixelY",
        default: 20
      }
    ],
    glsl: `   vec2 xy = vec2(pixelX, pixelY);
   return (floor(_st * xy) + 0.5)/xy;`
  },
  {
    name: "posterize",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "bins",
        default: 3
      },
      {
        type: "float",
        name: "gamma",
        default: 0.6
      }
    ],
    glsl: `   vec4 c2 = pow(_c0, vec4(gamma));
   c2 *= vec4(bins);
   c2 = floor(c2);
   c2/= vec4(bins);
   c2 = pow(c2, vec4(1.0/gamma));
   return vec4(c2.xyz, _c0.a);`
  },
  {
    name: "shift",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "r",
        default: 0.5
      },
      {
        type: "float",
        name: "g",
        default: 0
      },
      {
        type: "float",
        name: "b",
        default: 0
      },
      {
        type: "float",
        name: "a",
        default: 0
      }
    ],
    glsl: `   vec4 c2 = vec4(_c0);
   c2.r = fract(c2.r + r);
   c2.g = fract(c2.g + g);
   c2.b = fract(c2.b + b);
   c2.a = fract(c2.a + a);
   return vec4(c2.rgba);`
  },
  {
    name: "repeat",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "repeatX",
        default: 3
      },
      {
        type: "float",
        name: "repeatY",
        default: 3
      },
      {
        type: "float",
        name: "offsetX",
        default: 0
      },
      {
        type: "float",
        name: "offsetY",
        default: 0
      }
    ],
    glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) * offsetX;
   st.y += step(1., mod(st.x,2.0)) * offsetY;
   return fract(st);`
  },
  {
    name: "modulateRepeat",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "repeatX",
        default: 3
      },
      {
        type: "float",
        name: "repeatY",
        default: 3
      },
      {
        type: "float",
        name: "offsetX",
        default: 0.5
      },
      {
        type: "float",
        name: "offsetY",
        default: 0.5
      }
    ],
    glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offsetX;
   st.y += step(1., mod(st.x,2.0)) + _c0.g * offsetY;
   return fract(st);`
  },
  {
    name: "repeatX",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "reps",
        default: 3
      },
      {
        type: "float",
        name: "offset",
        default: 0
      }
    ],
    glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0))* offset;
   return fract(st);`
  },
  {
    name: "modulateRepeatX",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "reps",
        default: 3
      },
      {
        type: "float",
        name: "offset",
        default: 0.5
      }
    ],
    glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0)) + _c0.r * offset;
   return fract(st);`
  },
  {
    name: "repeatY",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "reps",
        default: 3
      },
      {
        type: "float",
        name: "offset",
        default: 0
      }
    ],
    glsl: `   vec2 st = _st * vec2(1.0, reps);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0))* offset;
   return fract(st);`
  },
  {
    name: "modulateRepeatY",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "reps",
        default: 3
      },
      {
        type: "float",
        name: "offset",
        default: 0.5
      }
    ],
    glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offset;
   return fract(st);`
  },
  {
    name: "kaleid",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "nSides",
        default: 4
      }
    ],
    glsl: `   vec2 st = _st;
   st -= 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return r*vec2(cos(a), sin(a));`
  },
  {
    name: "modulateKaleid",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "nSides",
        default: 4
      }
    ],
    glsl: `   vec2 st = _st - 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return (_c0.r+r)*vec2(cos(a), sin(a));`
  },
  {
    name: "scroll",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "scrollX",
        default: 0.5
      },
      {
        type: "float",
        name: "scrollY",
        default: 0.5
      },
      {
        type: "float",
        name: "speedX",
        default: 0
      },
      {
        type: "float",
        name: "speedY",
        default: 0
      }
    ],
    glsl: `
   _st.x += scrollX + time*speedX;
   _st.y += scrollY + time*speedY;
   return fract(_st);`
  },
  {
    name: "scrollX",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "scrollX",
        default: 0.5
      },
      {
        type: "float",
        name: "speed",
        default: 0
      }
    ],
    glsl: `   _st.x += scrollX + time*speed;
   return fract(_st);`
  },
  {
    name: "modulateScrollX",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "scrollX",
        default: 0.5
      },
      {
        type: "float",
        name: "speed",
        default: 0
      }
    ],
    glsl: `   _st.x += _c0.r*scrollX + time*speed;
   return fract(_st);`
  },
  {
    name: "scrollY",
    type: "coord",
    inputs: [
      {
        type: "float",
        name: "scrollY",
        default: 0.5
      },
      {
        type: "float",
        name: "speed",
        default: 0
      }
    ],
    glsl: `   _st.y += scrollY + time*speed;
   return fract(_st);`
  },
  {
    name: "modulateScrollY",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "scrollY",
        default: 0.5
      },
      {
        type: "float",
        name: "speed",
        default: 0
      }
    ],
    glsl: `   _st.y += _c0.r*scrollY + time*speed;
   return fract(_st);`
  },
  {
    name: "add",
    type: "combine",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 1
      }
    ],
    glsl: `   return (_c0+_c1)*amount + _c0*(1.0-amount);`
  },
  {
    name: "sub",
    type: "combine",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 1
      }
    ],
    glsl: `   return (_c0-_c1)*amount + _c0*(1.0-amount);`
  },
  {
    name: "layer",
    type: "combine",
    inputs: [],
    glsl: `   return vec4(mix(_c0.rgb, _c1.rgb, _c1.a), clamp(_c0.a + _c1.a, 0.0, 1.0));`
  },
  {
    name: "blend",
    type: "combine",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 0.5
      }
    ],
    glsl: `   return _c0*(1.0-amount)+_c1*amount;`
  },
  {
    name: "mult",
    type: "combine",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 1
      }
    ],
    glsl: `   return _c0*(1.0-amount)+(_c0*_c1)*amount;`
  },
  {
    name: "diff",
    type: "combine",
    inputs: [],
    glsl: `   return vec4(abs(_c0.rgb-_c1.rgb), max(_c0.a, _c1.a));`
  },
  {
    name: "modulate",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 0.1
      }
    ],
    glsl: `   //  return fract(st+(_c0.xy-0.5)*amount);
   return _st + _c0.xy*amount;`
  },
  {
    name: "modulateScale",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "multiple",
        default: 1
      },
      {
        type: "float",
        name: "offset",
        default: 1
      }
    ],
    glsl: `   vec2 xy = _st - vec2(0.5);
   xy*=(1.0/vec2(offset + multiple*_c0.r, offset + multiple*_c0.g));
   xy+=vec2(0.5);
   return xy;`
  },
  {
    name: "modulatePixelate",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "multiple",
        default: 10
      },
      {
        type: "float",
        name: "offset",
        default: 3
      }
    ],
    glsl: `   vec2 xy = vec2(offset + _c0.x*multiple, offset + _c0.y*multiple);
   return (floor(_st * xy) + 0.5)/xy;`
  },
  {
    name: "modulateRotate",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "multiple",
        default: 1
      },
      {
        type: "float",
        name: "offset",
        default: 0
      }
    ],
    glsl: `   vec2 xy = _st - vec2(0.5);
   float angle = offset + _c0.x * multiple;
   xy = mat2(cos(angle),-sin(angle), sin(angle),cos(angle))*xy;
   xy += 0.5;
   return xy;`
  },
  {
    name: "modulateHue",
    type: "combineCoord",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 1
      }
    ],
    glsl: `   return _st + (vec2(_c0.g - _c0.r, _c0.b - _c0.g) * amount * 1.0/resolution);`
  },
  {
    name: "invert",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 1
      }
    ],
    glsl: `   return vec4((1.0-_c0.rgb)*amount + _c0.rgb*(1.0-amount), _c0.a);`
  },
  {
    name: "contrast",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 1.6
      }
    ],
    glsl: `   vec4 c = (_c0-vec4(0.5))*vec4(amount) + vec4(0.5);
   return vec4(c.rgb, _c0.a);`
  },
  {
    name: "brightness",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 0.4
      }
    ],
    glsl: `   return vec4(_c0.rgb + vec3(amount), _c0.a);`
  },
  {
    name: "mask",
    type: "combine",
    inputs: [],
    glsl: `   float a = _luminance(_c1.rgb);
  return vec4(_c0.rgb*a, a*_c0.a);`
  },
  {
    name: "luma",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "threshold",
        default: 0.5
      },
      {
        type: "float",
        name: "tolerance",
        default: 0.1
      }
    ],
    glsl: `   float a = smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb));
   return vec4(_c0.rgb*a, a);`
  },
  {
    name: "thresh",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "threshold",
        default: 0.5
      },
      {
        type: "float",
        name: "tolerance",
        default: 0.04
      }
    ],
    glsl: `   return vec4(vec3(smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb))), _c0.a);`
  },
  {
    name: "color",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "r",
        default: 1
      },
      {
        type: "float",
        name: "g",
        default: 1
      },
      {
        type: "float",
        name: "b",
        default: 1
      },
      {
        type: "float",
        name: "a",
        default: 1
      }
    ],
    glsl: `   vec4 c = vec4(r, g, b, a);
   vec4 pos = step(0.0, c); // detect whether negative
   // if > 0, return r * _c0
   // if < 0 return (1.0-r) * _c0
   return vec4(mix((1.0-_c0)*abs(c), c*_c0, pos));`
  },
  {
    name: "saturate",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 2
      }
    ],
    glsl: `   const vec3 W = vec3(0.2125, 0.7154, 0.0721);
   vec3 intensity = vec3(dot(_c0.rgb, W));
   return vec4(mix(intensity, _c0.rgb, amount), _c0.a);`
  },
  {
    name: "hue",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "hue",
        default: 0.4
      }
    ],
    glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c.r += hue;
   //  c.r = fract(c.r);
   return vec4(_hsvToRgb(c), _c0.a);`
  },
  {
    name: "colorama",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "amount",
        default: 5e-3
      }
    ],
    glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c += vec3(amount);
   c = _hsvToRgb(c);
   c = fract(c);
   return vec4(c, _c0.a);`
  },
  {
    name: "prev",
    type: "src",
    inputs: [],
    glsl: `   return texture2D(prevBuffer, fract(_st));`
  },
  {
    name: "sum",
    type: "color",
    inputs: [
      {
        type: "vec4",
        name: "scale",
        default: 1
      }
    ],
    glsl: `   vec4 v = _c0 * s;
   return v.r + v.g + v.b + v.a;
   }
   float sum(vec2 _st, vec4 s) { // vec4 is not a typo, because argument type is not overloaded
   vec2 v = _st.xy * s.xy;
   return v.x + v.y;`
  },
  {
    name: "r",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "scale",
        default: 1
      },
      {
        type: "float",
        name: "offset",
        default: 0
      }
    ],
    glsl: `   return vec4(_c0.r * scale + offset);`
  },
  {
    name: "g",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "scale",
        default: 1
      },
      {
        type: "float",
        name: "offset",
        default: 0
      }
    ],
    glsl: `   return vec4(_c0.g * scale + offset);`
  },
  {
    name: "b",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "scale",
        default: 1
      },
      {
        type: "float",
        name: "offset",
        default: 0
      }
    ],
    glsl: `   return vec4(_c0.b * scale + offset);`
  },
  {
    name: "a",
    type: "color",
    inputs: [
      {
        type: "float",
        name: "scale",
        default: 1
      },
      {
        type: "float",
        name: "offset",
        default: 0
      }
    ],
    glsl: `   return vec4(_c0.a * scale + offset);`
  }
];
class Mutator {
  constructor(editor) {
    this.editor = editor;
    this.undoStack = new UndoStack();
    this.initialVector = [];
    this.funcTab = {};
    this.transMap = {};
    this.scanFuncs();
    this.dumpDict();
  }
  dumpList() {
    let gslTab = glslTransforms();
    gslTab.forEach((v) => {
      v.inputs.forEach((a2) => {
        a2.name + ": " + a2.type + " {" + a2.default + "}";
      });
    });
  }
  scanFuncs() {
    let gslTab = glslTransforms();
    console.log(gslTab);
    gslTab.forEach((f) => {
      this.transMap[f.name] = f;
      if (this.funcTab[f.type] === void 0) {
        this.funcTab[f.type] = [];
      }
      this.funcTab[f.type].push(f);
    });
  }
  dumpDict() {
    for (let tn in this.funcTab) {
      this.funcTab[tn].forEach((f) => {
        f.inputs.forEach((a2) => {
          a2.name + ": " + a2.type + " {" + a2.default + "}";
        });
      });
    }
  }
  mutate(options2) {
    let text = this.editor.cm.getValue();
    this.undoStack.push({ text, lastLitX: this.lastLitX });
    let needToRun = true;
    let tryCounter = 5;
    while (needToRun && tryCounter-- >= 0) {
      var comments = [];
      let ast = Parser.parse(
        text,
        {
          locations: true,
          onComment: comments
        }
      );
      this.transform(ast, options2);
      astravel.attachComments(ast, comments);
      let regen = generate(ast, { comments: true });
      this.editor.cm.setValue(regen);
      try {
        repl.eval(regen, (code2, error2) => {
          if (error2) {
            console.log("Eval error: " + regen);
          }
          needToRun = error2;
        });
      } catch (err) {
        console.log("Exception caught: " + err);
        needToRun = err;
      }
    }
  }
  doUndo() {
    if (this.undoStack.atTop()) {
      let text = this.editor.cm.getValue();
      this.undoStack.push({ text, lastLitX: this.lastLitX });
    }
    if (this.undoStack.canUndo()) {
      let { text, lastLitX } = this.undoStack.undo();
      this.setText(text);
      this.lastLitX = lastLitX;
    }
  }
  doRedo() {
    if (this.undoStack.canRedo()) {
      let { text, lastLitX } = this.undoStack.redo();
      this.setText(text);
      this.lastLitX = lastLitX;
    }
  }
  setText(text) {
    this.editor.cm.setValue(text);
    repl.eval(text, (code2, error2) => {
    });
  }
  // The options object contains a flag that controls how the
  // Literal to mutate is determined. If reroll is false, we
  // pick one at random. If reroll is true, we use the same field
  // we did last time.
  transform(ast, options2) {
    let traveler = astravel.makeTraveler({
      go: function(node, state3) {
        if (node.type === "Literal") {
          state3.literalTab.push(node);
        } else if (node.type === "MemberExpression") {
          if (node.property && node.property.type === "Literal") {
            return;
          }
        } else if (node.type === "CallExpression") {
          if (node.callee && node.callee.property && node.callee.property.name && node.callee.property.name !== "out") {
            state3.functionTab.push(node);
          }
        }
        this.super.go.call(this, node, state3);
      }
    });
    let state2 = {};
    state2.literalTab = [];
    state2.functionTab = [];
    traveler.go(ast, state2);
    this.litCount = state2.literalTab.length;
    this.funCount = state2.functionTab.length;
    if (this.litCount !== this.initialVector.length) {
      let nextVect = [];
      for (let i2 = 0; i2 < this.litCount; ++i2) {
        nextVect.push(state2.literalTab[i2].value);
      }
      this.initialVector = nextVect;
    }
    if (options2.changeTransform) {
      this.glitchTrans(state2, options2);
    } else
      this.glitchLiteral(state2, options2);
  }
  glitchLiteral(state2, options2) {
    let litx = 0;
    if (options2.reroll) {
      if (this.lastLitX !== void 0) {
        litx = this.lastLitX;
      }
    } else {
      litx = Math.floor(Math.random() * this.litCount);
      this.lastLitX = litx;
    }
    let modLit = state2.literalTab[litx];
    if (modLit) {
      let glitched = this.glitchRelToInit(modLit.value, this.initialVector[litx]);
      let was = modLit.raw;
      modLit.value = glitched;
      modLit.raw = "" + glitched;
      console.log("Literal: " + litx + " changed from: " + was + " to: " + glitched);
    }
  }
  glitchNumber(num) {
    if (num === 0) {
      num = 1;
    }
    let range = num * 2;
    let rndVal = Math.round(Math.random() * range * 1e3) / 1e3;
    return rndVal;
  }
  glitchRelToInit(num, initVal) {
    if (initVal === void 0) {
      return glitchNumber(num);
    }
    if (initVal === 0) {
      initVal = 0.5;
    }
    let rndVal = Math.round(Math.random() * initVal * 2 * 1e3) / 1e3;
    return rndVal;
  }
  glitchTrans(state2, options2) {
    let funx = Math.floor(Math.random() * this.funCount);
    if (state2.functionTab[funx] === void 0 || state2.functionTab[funx].callee === void 0 || state2.functionTab[funx].callee.property === void 0) {
      console.log("No valid functionTab for index: " + funx);
      return;
    }
    let oldName = state2.functionTab[funx].callee.property.name;
    if (oldName == void 0) {
      console.log("No name for callee");
      return;
    }
    let ftype = this.transMap[oldName].type;
    if (ftype == void 0) {
      console.log("ftype undefined for: " + oldName);
      return;
    }
    let others = this.funcTab[ftype];
    if (others == void 0) {
      console.log("no funcTab entry for: " + ftype);
      return;
    }
    let changeX = Math.floor(Math.random() * others.length);
    let become = others[changeX].name;
    if (oldName === "modulate" && become === "modulateScrollX") {
      console.log("Function: " + funx + " changing from: " + oldName + " can't change to: " + become);
      return;
    }
    state2.functionTab[funx].callee.property.name = become;
    console.log("Function: " + funx + " changed from: " + oldName + " to: " + become);
  }
}
var js = { exports: {} };
var src = {};
var javascript = { exports: {} };
var beautifier$2 = {};
var output = {};
var hasRequiredOutput;
function requireOutput() {
  if (hasRequiredOutput)
    return output;
  hasRequiredOutput = 1;
  function OutputLine(parent2) {
    this.__parent = parent2;
    this.__character_count = 0;
    this.__indent_count = -1;
    this.__alignment_count = 0;
    this.__wrap_point_index = 0;
    this.__wrap_point_character_count = 0;
    this.__wrap_point_indent_count = -1;
    this.__wrap_point_alignment_count = 0;
    this.__items = [];
  }
  OutputLine.prototype.clone_empty = function() {
    var line = new OutputLine(this.__parent);
    line.set_indent(this.__indent_count, this.__alignment_count);
    return line;
  };
  OutputLine.prototype.item = function(index2) {
    if (index2 < 0) {
      return this.__items[this.__items.length + index2];
    } else {
      return this.__items[index2];
    }
  };
  OutputLine.prototype.has_match = function(pattern2) {
    for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
      if (this.__items[lastCheckedOutput].match(pattern2)) {
        return true;
      }
    }
    return false;
  };
  OutputLine.prototype.set_indent = function(indent, alignment) {
    if (this.is_empty()) {
      this.__indent_count = indent || 0;
      this.__alignment_count = alignment || 0;
      this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
    }
  };
  OutputLine.prototype._set_wrap_point = function() {
    if (this.__parent.wrap_line_length) {
      this.__wrap_point_index = this.__items.length;
      this.__wrap_point_character_count = this.__character_count;
      this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
      this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
    }
  };
  OutputLine.prototype._should_wrap = function() {
    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
  };
  OutputLine.prototype._allow_wrap = function() {
    if (this._should_wrap()) {
      this.__parent.add_new_line();
      var next = this.__parent.current_line;
      next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
      next.__items = this.__items.slice(this.__wrap_point_index);
      this.__items = this.__items.slice(0, this.__wrap_point_index);
      next.__character_count += this.__character_count - this.__wrap_point_character_count;
      this.__character_count = this.__wrap_point_character_count;
      if (next.__items[0] === " ") {
        next.__items.splice(0, 1);
        next.__character_count -= 1;
      }
      return true;
    }
    return false;
  };
  OutputLine.prototype.is_empty = function() {
    return this.__items.length === 0;
  };
  OutputLine.prototype.last = function() {
    if (!this.is_empty()) {
      return this.__items[this.__items.length - 1];
    } else {
      return null;
    }
  };
  OutputLine.prototype.push = function(item) {
    this.__items.push(item);
    var last_newline_index = item.lastIndexOf("\n");
    if (last_newline_index !== -1) {
      this.__character_count = item.length - last_newline_index;
    } else {
      this.__character_count += item.length;
    }
  };
  OutputLine.prototype.pop = function() {
    var item = null;
    if (!this.is_empty()) {
      item = this.__items.pop();
      this.__character_count -= item.length;
    }
    return item;
  };
  OutputLine.prototype._remove_indent = function() {
    if (this.__indent_count > 0) {
      this.__indent_count -= 1;
      this.__character_count -= this.__parent.indent_size;
    }
  };
  OutputLine.prototype._remove_wrap_indent = function() {
    if (this.__wrap_point_indent_count > 0) {
      this.__wrap_point_indent_count -= 1;
    }
  };
  OutputLine.prototype.trim = function() {
    while (this.last() === " ") {
      this.__items.pop();
      this.__character_count -= 1;
    }
  };
  OutputLine.prototype.toString = function() {
    var result = "";
    if (this.is_empty()) {
      if (this.__parent.indent_empty_lines) {
        result = this.__parent.get_indent_string(this.__indent_count);
      }
    } else {
      result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
      result += this.__items.join("");
    }
    return result;
  };
  function IndentStringCache(options2, baseIndentString) {
    this.__cache = [""];
    this.__indent_size = options2.indent_size;
    this.__indent_string = options2.indent_char;
    if (!options2.indent_with_tabs) {
      this.__indent_string = new Array(options2.indent_size + 1).join(options2.indent_char);
    }
    baseIndentString = baseIndentString || "";
    if (options2.indent_level > 0) {
      baseIndentString = new Array(options2.indent_level + 1).join(this.__indent_string);
    }
    this.__base_string = baseIndentString;
    this.__base_string_length = baseIndentString.length;
  }
  IndentStringCache.prototype.get_indent_size = function(indent, column) {
    var result = this.__base_string_length;
    column = column || 0;
    if (indent < 0) {
      result = 0;
    }
    result += indent * this.__indent_size;
    result += column;
    return result;
  };
  IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
    var result = this.__base_string;
    column = column || 0;
    if (indent_level < 0) {
      indent_level = 0;
      result = "";
    }
    column += indent_level * this.__indent_size;
    this.__ensure_cache(column);
    result += this.__cache[column];
    return result;
  };
  IndentStringCache.prototype.__ensure_cache = function(column) {
    while (column >= this.__cache.length) {
      this.__add_column();
    }
  };
  IndentStringCache.prototype.__add_column = function() {
    var column = this.__cache.length;
    var indent = 0;
    var result = "";
    if (this.__indent_size && column >= this.__indent_size) {
      indent = Math.floor(column / this.__indent_size);
      column -= indent * this.__indent_size;
      result = new Array(indent + 1).join(this.__indent_string);
    }
    if (column) {
      result += new Array(column + 1).join(" ");
    }
    this.__cache.push(result);
  };
  function Output2(options2, baseIndentString) {
    this.__indent_cache = new IndentStringCache(options2, baseIndentString);
    this.raw = false;
    this._end_with_newline = options2.end_with_newline;
    this.indent_size = options2.indent_size;
    this.wrap_line_length = options2.wrap_line_length;
    this.indent_empty_lines = options2.indent_empty_lines;
    this.__lines = [];
    this.previous_line = null;
    this.current_line = null;
    this.next_line = new OutputLine(this);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
    this.__add_outputline();
  }
  Output2.prototype.__add_outputline = function() {
    this.previous_line = this.current_line;
    this.current_line = this.next_line.clone_empty();
    this.__lines.push(this.current_line);
  };
  Output2.prototype.get_line_number = function() {
    return this.__lines.length;
  };
  Output2.prototype.get_indent_string = function(indent, column) {
    return this.__indent_cache.get_indent_string(indent, column);
  };
  Output2.prototype.get_indent_size = function(indent, column) {
    return this.__indent_cache.get_indent_size(indent, column);
  };
  Output2.prototype.is_empty = function() {
    return !this.previous_line && this.current_line.is_empty();
  };
  Output2.prototype.add_new_line = function(force_newline) {
    if (this.is_empty() || !force_newline && this.just_added_newline()) {
      return false;
    }
    if (!this.raw) {
      this.__add_outputline();
    }
    return true;
  };
  Output2.prototype.get_code = function(eol) {
    this.trim(true);
    var last_item = this.current_line.pop();
    if (last_item) {
      if (last_item[last_item.length - 1] === "\n") {
        last_item = last_item.replace(/\n+$/g, "");
      }
      this.current_line.push(last_item);
    }
    if (this._end_with_newline) {
      this.__add_outputline();
    }
    var sweet_code = this.__lines.join("\n");
    if (eol !== "\n") {
      sweet_code = sweet_code.replace(/[\n]/g, eol);
    }
    return sweet_code;
  };
  Output2.prototype.set_wrap_point = function() {
    this.current_line._set_wrap_point();
  };
  Output2.prototype.set_indent = function(indent, alignment) {
    indent = indent || 0;
    alignment = alignment || 0;
    this.next_line.set_indent(indent, alignment);
    if (this.__lines.length > 1) {
      this.current_line.set_indent(indent, alignment);
      return true;
    }
    this.current_line.set_indent();
    return false;
  };
  Output2.prototype.add_raw_token = function(token2) {
    for (var x2 = 0; x2 < token2.newlines; x2++) {
      this.__add_outputline();
    }
    this.current_line.set_indent(-1);
    this.current_line.push(token2.whitespace_before);
    this.current_line.push(token2.text);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
  };
  Output2.prototype.add_token = function(printable_token) {
    this.__add_space_before_token();
    this.current_line.push(printable_token);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = this.current_line._allow_wrap();
  };
  Output2.prototype.__add_space_before_token = function() {
    if (this.space_before_token && !this.just_added_newline()) {
      if (!this.non_breaking_space) {
        this.set_wrap_point();
      }
      this.current_line.push(" ");
    }
  };
  Output2.prototype.remove_indent = function(index2) {
    var output_length = this.__lines.length;
    while (index2 < output_length) {
      this.__lines[index2]._remove_indent();
      index2++;
    }
    this.current_line._remove_wrap_indent();
  };
  Output2.prototype.trim = function(eat_newlines) {
    eat_newlines = eat_newlines === void 0 ? false : eat_newlines;
    this.current_line.trim();
    while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
      this.__lines.pop();
      this.current_line = this.__lines[this.__lines.length - 1];
      this.current_line.trim();
    }
    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
  };
  Output2.prototype.just_added_newline = function() {
    return this.current_line.is_empty();
  };
  Output2.prototype.just_added_blankline = function() {
    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
  };
  Output2.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
    var index2 = this.__lines.length - 2;
    while (index2 >= 0) {
      var potentialEmptyLine = this.__lines[index2];
      if (potentialEmptyLine.is_empty()) {
        break;
      } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
        this.__lines.splice(index2 + 1, 0, new OutputLine(this));
        this.previous_line = this.__lines[this.__lines.length - 2];
        break;
      }
      index2--;
    }
  };
  output.Output = Output2;
  return output;
}
var token = {};
var hasRequiredToken;
function requireToken() {
  if (hasRequiredToken)
    return token;
  hasRequiredToken = 1;
  function Token3(type, text, newlines, whitespace_before) {
    this.type = type;
    this.text = text;
    this.comments_before = null;
    this.newlines = newlines || 0;
    this.whitespace_before = whitespace_before || "";
    this.parent = null;
    this.next = null;
    this.previous = null;
    this.opened = null;
    this.closed = null;
    this.directives = null;
  }
  token.Token = Token3;
  return token;
}
var acorn = {};
var hasRequiredAcorn;
function requireAcorn() {
  if (hasRequiredAcorn)
    return acorn;
  hasRequiredAcorn = 1;
  (function(exports2) {
    var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";
    var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";
    var nonASCIIidentifierStartChars2 = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
    var nonASCIIidentifierChars2 = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
    var identifierStart = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars2 + "])";
    var identifierChars = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "])*";
    exports2.identifier = new RegExp(identifierStart + identifierChars, "g");
    exports2.identifierStart = new RegExp(identifierStart);
    exports2.identifierMatch = new RegExp("(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "])+");
    exports2.newline = /[\n\r\u2028\u2029]/;
    exports2.lineBreak = new RegExp("\r\n|" + exports2.newline.source);
    exports2.allLineBreaks = new RegExp(exports2.lineBreak.source, "g");
  })(acorn);
  return acorn;
}
var options$3 = {};
var options$2 = {};
var hasRequiredOptions$3;
function requireOptions$3() {
  if (hasRequiredOptions$3)
    return options$2;
  hasRequiredOptions$3 = 1;
  function Options(options2, merge_child_field) {
    this.raw_options = _mergeOpts(options2, merge_child_field);
    this.disabled = this._get_boolean("disabled");
    this.eol = this._get_characters("eol", "auto");
    this.end_with_newline = this._get_boolean("end_with_newline");
    this.indent_size = this._get_number("indent_size", 4);
    this.indent_char = this._get_characters("indent_char", " ");
    this.indent_level = this._get_number("indent_level");
    this.preserve_newlines = this._get_boolean("preserve_newlines", true);
    this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
    if (!this.preserve_newlines) {
      this.max_preserve_newlines = 0;
    }
    this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	");
    if (this.indent_with_tabs) {
      this.indent_char = "	";
      if (this.indent_size === 1) {
        this.indent_size = 4;
      }
    }
    this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
    this.indent_empty_lines = this._get_boolean("indent_empty_lines");
    this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
  }
  Options.prototype._get_array = function(name, default_value) {
    var option_value = this.raw_options[name];
    var result = default_value || [];
    if (typeof option_value === "object") {
      if (option_value !== null && typeof option_value.concat === "function") {
        result = option_value.concat();
      }
    } else if (typeof option_value === "string") {
      result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
    }
    return result;
  };
  Options.prototype._get_boolean = function(name, default_value) {
    var option_value = this.raw_options[name];
    var result = option_value === void 0 ? !!default_value : !!option_value;
    return result;
  };
  Options.prototype._get_characters = function(name, default_value) {
    var option_value = this.raw_options[name];
    var result = default_value || "";
    if (typeof option_value === "string") {
      result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "	");
    }
    return result;
  };
  Options.prototype._get_number = function(name, default_value) {
    var option_value = this.raw_options[name];
    default_value = parseInt(default_value, 10);
    if (isNaN(default_value)) {
      default_value = 0;
    }
    var result = parseInt(option_value, 10);
    if (isNaN(result)) {
      result = default_value;
    }
    return result;
  };
  Options.prototype._get_selection = function(name, selection_list, default_value) {
    var result = this._get_selection_list(name, selection_list, default_value);
    if (result.length !== 1) {
      throw new Error(
        "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'"
      );
    }
    return result[0];
  };
  Options.prototype._get_selection_list = function(name, selection_list, default_value) {
    if (!selection_list || selection_list.length === 0) {
      throw new Error("Selection list cannot be empty.");
    }
    default_value = default_value || [selection_list[0]];
    if (!this._is_valid_selection(default_value, selection_list)) {
      throw new Error("Invalid Default Value!");
    }
    var result = this._get_array(name, default_value);
    if (!this._is_valid_selection(result, selection_list)) {
      throw new Error(
        "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'"
      );
    }
    return result;
  };
  Options.prototype._is_valid_selection = function(result, selection_list) {
    return result.length && selection_list.length && !result.some(function(item) {
      return selection_list.indexOf(item) === -1;
    });
  };
  function _mergeOpts(allOptions, childFieldName) {
    var finalOpts = {};
    allOptions = _normalizeOpts(allOptions);
    var name;
    for (name in allOptions) {
      if (name !== childFieldName) {
        finalOpts[name] = allOptions[name];
      }
    }
    if (childFieldName && allOptions[childFieldName]) {
      for (name in allOptions[childFieldName]) {
        finalOpts[name] = allOptions[childFieldName][name];
      }
    }
    return finalOpts;
  }
  function _normalizeOpts(options2) {
    var convertedOpts = {};
    var key;
    for (key in options2) {
      var newKey = key.replace(/-/g, "_");
      convertedOpts[newKey] = options2[key];
    }
    return convertedOpts;
  }
  options$2.Options = Options;
  options$2.normalizeOpts = _normalizeOpts;
  options$2.mergeOpts = _mergeOpts;
  return options$2;
}
var hasRequiredOptions$2;
function requireOptions$2() {
  if (hasRequiredOptions$2)
    return options$3;
  hasRequiredOptions$2 = 1;
  var BaseOptions = requireOptions$3().Options;
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  function Options(options2) {
    BaseOptions.call(this, options2, "js");
    var raw_brace_style = this.raw_options.brace_style || null;
    if (raw_brace_style === "expand-strict") {
      this.raw_options.brace_style = "expand";
    } else if (raw_brace_style === "collapse-preserve-inline") {
      this.raw_options.brace_style = "collapse,preserve-inline";
    } else if (this.raw_options.braces_on_own_line !== void 0) {
      this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    }
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_preserve_inline = false;
    this.brace_style = "collapse";
    for (var bs = 0; bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] === "preserve-inline") {
        this.brace_preserve_inline = true;
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
    this.unindent_chained_methods = this._get_boolean("unindent_chained_methods");
    this.break_chained_methods = this._get_boolean("break_chained_methods");
    this.space_in_paren = this._get_boolean("space_in_paren");
    this.space_in_empty_paren = this._get_boolean("space_in_empty_paren");
    this.jslint_happy = this._get_boolean("jslint_happy");
    this.space_after_anon_function = this._get_boolean("space_after_anon_function");
    this.space_after_named_function = this._get_boolean("space_after_named_function");
    this.keep_array_indentation = this._get_boolean("keep_array_indentation");
    this.space_before_conditional = this._get_boolean("space_before_conditional", true);
    this.unescape_strings = this._get_boolean("unescape_strings");
    this.e4x = this._get_boolean("e4x");
    this.comma_first = this._get_boolean("comma_first");
    this.operator_position = this._get_selection("operator_position", validPositionValues);
    this.test_output_raw = this._get_boolean("test_output_raw");
    if (this.jslint_happy) {
      this.space_after_anon_function = true;
    }
  }
  Options.prototype = new BaseOptions();
  options$3.Options = Options;
  return options$3;
}
var tokenizer$2 = {};
var inputscanner = {};
var hasRequiredInputscanner;
function requireInputscanner() {
  if (hasRequiredInputscanner)
    return inputscanner;
  hasRequiredInputscanner = 1;
  var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
  function InputScanner(input_string) {
    this.__input = input_string || "";
    this.__input_length = this.__input.length;
    this.__position = 0;
  }
  InputScanner.prototype.restart = function() {
    this.__position = 0;
  };
  InputScanner.prototype.back = function() {
    if (this.__position > 0) {
      this.__position -= 1;
    }
  };
  InputScanner.prototype.hasNext = function() {
    return this.__position < this.__input_length;
  };
  InputScanner.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__input.charAt(this.__position);
      this.__position += 1;
    }
    return val;
  };
  InputScanner.prototype.peek = function(index2) {
    var val = null;
    index2 = index2 || 0;
    index2 += this.__position;
    if (index2 >= 0 && index2 < this.__input_length) {
      val = this.__input.charAt(index2);
    }
    return val;
  };
  InputScanner.prototype.__match = function(pattern2, index2) {
    pattern2.lastIndex = index2;
    var pattern_match = pattern2.exec(this.__input);
    if (pattern_match && !(regexp_has_sticky && pattern2.sticky)) {
      if (pattern_match.index !== index2) {
        pattern_match = null;
      }
    }
    return pattern_match;
  };
  InputScanner.prototype.test = function(pattern2, index2) {
    index2 = index2 || 0;
    index2 += this.__position;
    if (index2 >= 0 && index2 < this.__input_length) {
      return !!this.__match(pattern2, index2);
    } else {
      return false;
    }
  };
  InputScanner.prototype.testChar = function(pattern2, index2) {
    var val = this.peek(index2);
    pattern2.lastIndex = 0;
    return val !== null && pattern2.test(val);
  };
  InputScanner.prototype.match = function(pattern2) {
    var pattern_match = this.__match(pattern2, this.__position);
    if (pattern_match) {
      this.__position += pattern_match[0].length;
    } else {
      pattern_match = null;
    }
    return pattern_match;
  };
  InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
    var val = "";
    var match;
    if (starting_pattern) {
      match = this.match(starting_pattern);
      if (match) {
        val += match[0];
      }
    }
    if (until_pattern && (match || !starting_pattern)) {
      val += this.readUntil(until_pattern, until_after);
    }
    return val;
  };
  InputScanner.prototype.readUntil = function(pattern2, until_after) {
    var val = "";
    var match_index = this.__position;
    pattern2.lastIndex = this.__position;
    var pattern_match = pattern2.exec(this.__input);
    if (pattern_match) {
      match_index = pattern_match.index;
      if (until_after) {
        match_index += pattern_match[0].length;
      }
    } else {
      match_index = this.__input_length;
    }
    val = this.__input.substring(this.__position, match_index);
    this.__position = match_index;
    return val;
  };
  InputScanner.prototype.readUntilAfter = function(pattern2) {
    return this.readUntil(pattern2, true);
  };
  InputScanner.prototype.get_regexp = function(pattern2, match_from) {
    var result = null;
    var flags = "g";
    if (match_from && regexp_has_sticky) {
      flags = "y";
    }
    if (typeof pattern2 === "string" && pattern2 !== "") {
      result = new RegExp(pattern2, flags);
    } else if (pattern2) {
      result = new RegExp(pattern2.source, flags);
    }
    return result;
  };
  InputScanner.prototype.get_literal_regexp = function(literal_string) {
    return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
  };
  InputScanner.prototype.peekUntilAfter = function(pattern2) {
    var start = this.__position;
    var val = this.readUntilAfter(pattern2);
    this.__position = start;
    return val;
  };
  InputScanner.prototype.lookBack = function(testVal) {
    var start = this.__position - 1;
    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
  };
  inputscanner.InputScanner = InputScanner;
  return inputscanner;
}
var tokenizer$1 = {};
var tokenstream = {};
var hasRequiredTokenstream;
function requireTokenstream() {
  if (hasRequiredTokenstream)
    return tokenstream;
  hasRequiredTokenstream = 1;
  function TokenStream(parent_token) {
    this.__tokens = [];
    this.__tokens_length = this.__tokens.length;
    this.__position = 0;
    this.__parent_token = parent_token;
  }
  TokenStream.prototype.restart = function() {
    this.__position = 0;
  };
  TokenStream.prototype.isEmpty = function() {
    return this.__tokens_length === 0;
  };
  TokenStream.prototype.hasNext = function() {
    return this.__position < this.__tokens_length;
  };
  TokenStream.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__tokens[this.__position];
      this.__position += 1;
    }
    return val;
  };
  TokenStream.prototype.peek = function(index2) {
    var val = null;
    index2 = index2 || 0;
    index2 += this.__position;
    if (index2 >= 0 && index2 < this.__tokens_length) {
      val = this.__tokens[index2];
    }
    return val;
  };
  TokenStream.prototype.add = function(token2) {
    if (this.__parent_token) {
      token2.parent = this.__parent_token;
    }
    this.__tokens.push(token2);
    this.__tokens_length += 1;
  };
  tokenstream.TokenStream = TokenStream;
  return tokenstream;
}
var whitespacepattern = {};
var pattern = {};
var hasRequiredPattern;
function requirePattern() {
  if (hasRequiredPattern)
    return pattern;
  hasRequiredPattern = 1;
  function Pattern(input_scanner, parent2) {
    this._input = input_scanner;
    this._starting_pattern = null;
    this._match_pattern = null;
    this._until_pattern = null;
    this._until_after = false;
    if (parent2) {
      this._starting_pattern = this._input.get_regexp(parent2._starting_pattern, true);
      this._match_pattern = this._input.get_regexp(parent2._match_pattern, true);
      this._until_pattern = this._input.get_regexp(parent2._until_pattern);
      this._until_after = parent2._until_after;
    }
  }
  Pattern.prototype.read = function() {
    var result = this._input.read(this._starting_pattern);
    if (!this._starting_pattern || result) {
      result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
    }
    return result;
  };
  Pattern.prototype.read_match = function() {
    return this._input.match(this._match_pattern);
  };
  Pattern.prototype.until_after = function(pattern2) {
    var result = this._create();
    result._until_after = true;
    result._until_pattern = this._input.get_regexp(pattern2);
    result._update();
    return result;
  };
  Pattern.prototype.until = function(pattern2) {
    var result = this._create();
    result._until_after = false;
    result._until_pattern = this._input.get_regexp(pattern2);
    result._update();
    return result;
  };
  Pattern.prototype.starting_with = function(pattern2) {
    var result = this._create();
    result._starting_pattern = this._input.get_regexp(pattern2, true);
    result._update();
    return result;
  };
  Pattern.prototype.matching = function(pattern2) {
    var result = this._create();
    result._match_pattern = this._input.get_regexp(pattern2, true);
    result._update();
    return result;
  };
  Pattern.prototype._create = function() {
    return new Pattern(this._input, this);
  };
  Pattern.prototype._update = function() {
  };
  pattern.Pattern = Pattern;
  return pattern;
}
var hasRequiredWhitespacepattern;
function requireWhitespacepattern() {
  if (hasRequiredWhitespacepattern)
    return whitespacepattern;
  hasRequiredWhitespacepattern = 1;
  var Pattern = requirePattern().Pattern;
  function WhitespacePattern(input_scanner, parent2) {
    Pattern.call(this, input_scanner, parent2);
    if (parent2) {
      this._line_regexp = this._input.get_regexp(parent2._line_regexp);
    } else {
      this.__set_whitespace_patterns("", "");
    }
    this.newline_count = 0;
    this.whitespace_before_token = "";
  }
  WhitespacePattern.prototype = new Pattern();
  WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
    whitespace_chars += "\\t ";
    newline_chars += "\\n\\r";
    this._match_pattern = this._input.get_regexp(
      "[" + whitespace_chars + newline_chars + "]+",
      true
    );
    this._newline_regexp = this._input.get_regexp(
      "\\r\\n|[" + newline_chars + "]"
    );
  };
  WhitespacePattern.prototype.read = function() {
    this.newline_count = 0;
    this.whitespace_before_token = "";
    var resulting_string = this._input.read(this._match_pattern);
    if (resulting_string === " ") {
      this.whitespace_before_token = " ";
    } else if (resulting_string) {
      var matches = this.__split(this._newline_regexp, resulting_string);
      this.newline_count = matches.length - 1;
      this.whitespace_before_token = matches[this.newline_count];
    }
    return resulting_string;
  };
  WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
    var result = this._create();
    result.__set_whitespace_patterns(whitespace_chars, newline_chars);
    result._update();
    return result;
  };
  WhitespacePattern.prototype._create = function() {
    return new WhitespacePattern(this._input, this);
  };
  WhitespacePattern.prototype.__split = function(regexp, input_string) {
    regexp.lastIndex = 0;
    var start_index = 0;
    var result = [];
    var next_match = regexp.exec(input_string);
    while (next_match) {
      result.push(input_string.substring(start_index, next_match.index));
      start_index = next_match.index + next_match[0].length;
      next_match = regexp.exec(input_string);
    }
    if (start_index < input_string.length) {
      result.push(input_string.substring(start_index, input_string.length));
    } else {
      result.push("");
    }
    return result;
  };
  whitespacepattern.WhitespacePattern = WhitespacePattern;
  return whitespacepattern;
}
var hasRequiredTokenizer$2;
function requireTokenizer$2() {
  if (hasRequiredTokenizer$2)
    return tokenizer$1;
  hasRequiredTokenizer$2 = 1;
  var InputScanner = requireInputscanner().InputScanner;
  var Token3 = requireToken().Token;
  var TokenStream = requireTokenstream().TokenStream;
  var WhitespacePattern = requireWhitespacepattern().WhitespacePattern;
  var TOKEN = {
    START: "TK_START",
    RAW: "TK_RAW",
    EOF: "TK_EOF"
  };
  var Tokenizer = function(input_string, options2) {
    this._input = new InputScanner(input_string);
    this._options = options2 || {};
    this.__tokens = null;
    this._patterns = {};
    this._patterns.whitespace = new WhitespacePattern(this._input);
  };
  Tokenizer.prototype.tokenize = function() {
    this._input.restart();
    this.__tokens = new TokenStream();
    this._reset();
    var current2;
    var previous = new Token3(TOKEN.START, "");
    var open_token = null;
    var open_stack = [];
    var comments = new TokenStream();
    while (previous.type !== TOKEN.EOF) {
      current2 = this._get_next_token(previous, open_token);
      while (this._is_comment(current2)) {
        comments.add(current2);
        current2 = this._get_next_token(previous, open_token);
      }
      if (!comments.isEmpty()) {
        current2.comments_before = comments;
        comments = new TokenStream();
      }
      current2.parent = open_token;
      if (this._is_opening(current2)) {
        open_stack.push(open_token);
        open_token = current2;
      } else if (open_token && this._is_closing(current2, open_token)) {
        current2.opened = open_token;
        open_token.closed = current2;
        open_token = open_stack.pop();
        current2.parent = open_token;
      }
      current2.previous = previous;
      previous.next = current2;
      this.__tokens.add(current2);
      previous = current2;
    }
    return this.__tokens;
  };
  Tokenizer.prototype._is_first_token = function() {
    return this.__tokens.isEmpty();
  };
  Tokenizer.prototype._reset = function() {
  };
  Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
    this._readWhitespace();
    var resulting_string = this._input.read(/.+/g);
    if (resulting_string) {
      return this._create_token(TOKEN.RAW, resulting_string);
    } else {
      return this._create_token(TOKEN.EOF, "");
    }
  };
  Tokenizer.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer.prototype._is_opening = function(current_token) {
    return false;
  };
  Tokenizer.prototype._is_closing = function(current_token, open_token) {
    return false;
  };
  Tokenizer.prototype._create_token = function(type, text) {
    var token2 = new Token3(
      type,
      text,
      this._patterns.whitespace.newline_count,
      this._patterns.whitespace.whitespace_before_token
    );
    return token2;
  };
  Tokenizer.prototype._readWhitespace = function() {
    return this._patterns.whitespace.read();
  };
  tokenizer$1.Tokenizer = Tokenizer;
  tokenizer$1.TOKEN = TOKEN;
  return tokenizer$1;
}
var directives = {};
var hasRequiredDirectives;
function requireDirectives() {
  if (hasRequiredDirectives)
    return directives;
  hasRequiredDirectives = 1;
  function Directives(start_block_pattern, end_block_pattern) {
    start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
    end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
    this.__directive_pattern = / (\w+)[:](\w+)/g;
    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
  }
  Directives.prototype.get_directives = function(text) {
    if (!text.match(this.__directives_block_pattern)) {
      return null;
    }
    var directives2 = {};
    this.__directive_pattern.lastIndex = 0;
    var directive_match = this.__directive_pattern.exec(text);
    while (directive_match) {
      directives2[directive_match[1]] = directive_match[2];
      directive_match = this.__directive_pattern.exec(text);
    }
    return directives2;
  };
  Directives.prototype.readIgnored = function(input) {
    return input.readUntilAfter(this.__directives_end_ignore_pattern);
  };
  directives.Directives = Directives;
  return directives;
}
var templatablepattern = {};
var hasRequiredTemplatablepattern;
function requireTemplatablepattern() {
  if (hasRequiredTemplatablepattern)
    return templatablepattern;
  hasRequiredTemplatablepattern = 1;
  var Pattern = requirePattern().Pattern;
  var template_names = {
    django: false,
    erb: false,
    handlebars: false,
    php: false,
    smarty: false
  };
  function TemplatablePattern(input_scanner, parent2) {
    Pattern.call(this, input_scanner, parent2);
    this.__template_pattern = null;
    this._disabled = Object.assign({}, template_names);
    this._excluded = Object.assign({}, template_names);
    if (parent2) {
      this.__template_pattern = this._input.get_regexp(parent2.__template_pattern);
      this._excluded = Object.assign(this._excluded, parent2._excluded);
      this._disabled = Object.assign(this._disabled, parent2._disabled);
    }
    var pattern2 = new Pattern(input_scanner);
    this.__patterns = {
      handlebars_comment: pattern2.starting_with(/{{!--/).until_after(/--}}/),
      handlebars_unescaped: pattern2.starting_with(/{{{/).until_after(/}}}/),
      handlebars: pattern2.starting_with(/{{/).until_after(/}}/),
      php: pattern2.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
      erb: pattern2.starting_with(/<%[^%]/).until_after(/[^%]%>/),
      // django coflicts with handlebars a bit.
      django: pattern2.starting_with(/{%/).until_after(/%}/),
      django_value: pattern2.starting_with(/{{/).until_after(/}}/),
      django_comment: pattern2.starting_with(/{#/).until_after(/#}/),
      smarty: pattern2.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
      smarty_comment: pattern2.starting_with(/{\*/).until_after(/\*}/),
      smarty_literal: pattern2.starting_with(/{literal}/).until_after(/{\/literal}/)
    };
  }
  TemplatablePattern.prototype = new Pattern();
  TemplatablePattern.prototype._create = function() {
    return new TemplatablePattern(this._input, this);
  };
  TemplatablePattern.prototype._update = function() {
    this.__set_templated_pattern();
  };
  TemplatablePattern.prototype.disable = function(language) {
    var result = this._create();
    result._disabled[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read_options = function(options2) {
    var result = this._create();
    for (var language in template_names) {
      result._disabled[language] = options2.templating.indexOf(language) === -1;
    }
    result._update();
    return result;
  };
  TemplatablePattern.prototype.exclude = function(language) {
    var result = this._create();
    result._excluded[language] = true;
    result._update();
    return result;
  };
  TemplatablePattern.prototype.read = function() {
    var result = "";
    if (this._match_pattern) {
      result = this._input.read(this._starting_pattern);
    } else {
      result = this._input.read(this._starting_pattern, this.__template_pattern);
    }
    var next = this._read_template();
    while (next) {
      if (this._match_pattern) {
        next += this._input.read(this._match_pattern);
      } else {
        next += this._input.readUntil(this.__template_pattern);
      }
      result += next;
      next = this._read_template();
    }
    if (this._until_after) {
      result += this._input.readUntilAfter(this._until_pattern);
    }
    return result;
  };
  TemplatablePattern.prototype.__set_templated_pattern = function() {
    var items = [];
    if (!this._disabled.php) {
      items.push(this.__patterns.php._starting_pattern.source);
    }
    if (!this._disabled.handlebars) {
      items.push(this.__patterns.handlebars._starting_pattern.source);
    }
    if (!this._disabled.erb) {
      items.push(this.__patterns.erb._starting_pattern.source);
    }
    if (!this._disabled.django) {
      items.push(this.__patterns.django._starting_pattern.source);
      items.push(this.__patterns.django_value._starting_pattern.source);
      items.push(this.__patterns.django_comment._starting_pattern.source);
    }
    if (!this._disabled.smarty) {
      items.push(this.__patterns.smarty._starting_pattern.source);
    }
    if (this._until_pattern) {
      items.push(this._until_pattern.source);
    }
    this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
  };
  TemplatablePattern.prototype._read_template = function() {
    var resulting_string = "";
    var c = this._input.peek();
    if (c === "<") {
      var peek1 = this._input.peek(1);
      if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
        resulting_string = resulting_string || this.__patterns.php.read();
      }
      if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
        resulting_string = resulting_string || this.__patterns.erb.read();
      }
    } else if (c === "{") {
      if (!this._disabled.handlebars && !this._excluded.handlebars) {
        resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
      }
      if (!this._disabled.django) {
        if (!this._excluded.django && !this._excluded.handlebars) {
          resulting_string = resulting_string || this.__patterns.django_value.read();
        }
        if (!this._excluded.django) {
          resulting_string = resulting_string || this.__patterns.django_comment.read();
          resulting_string = resulting_string || this.__patterns.django.read();
        }
      }
      if (!this._disabled.smarty) {
        if (this._disabled.django && this._disabled.handlebars) {
          resulting_string = resulting_string || this.__patterns.smarty_comment.read();
          resulting_string = resulting_string || this.__patterns.smarty_literal.read();
          resulting_string = resulting_string || this.__patterns.smarty.read();
        }
      }
    }
    return resulting_string;
  };
  templatablepattern.TemplatablePattern = TemplatablePattern;
  return templatablepattern;
}
var hasRequiredTokenizer$1;
function requireTokenizer$1() {
  if (hasRequiredTokenizer$1)
    return tokenizer$2;
  hasRequiredTokenizer$1 = 1;
  var InputScanner = requireInputscanner().InputScanner;
  var BaseTokenizer = requireTokenizer$2().Tokenizer;
  var BASETOKEN = requireTokenizer$2().TOKEN;
  var Directives = requireDirectives().Directives;
  var acorn2 = requireAcorn();
  var Pattern = requirePattern().Pattern;
  var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
  function in_array(what, arr2) {
    return arr2.indexOf(what) !== -1;
  }
  var TOKEN = {
    START_EXPR: "TK_START_EXPR",
    END_EXPR: "TK_END_EXPR",
    START_BLOCK: "TK_START_BLOCK",
    END_BLOCK: "TK_END_BLOCK",
    WORD: "TK_WORD",
    RESERVED: "TK_RESERVED",
    SEMICOLON: "TK_SEMICOLON",
    STRING: "TK_STRING",
    EQUALS: "TK_EQUALS",
    OPERATOR: "TK_OPERATOR",
    COMMA: "TK_COMMA",
    BLOCK_COMMENT: "TK_BLOCK_COMMENT",
    COMMENT: "TK_COMMENT",
    DOT: "TK_DOT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/\/\*/, /\*\//);
  var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;
  var digit = /[0-9]/;
  var dot_pattern = /[^\d\.]/;
  var positionable_operators = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" ");
  var punct = ">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |";
  punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
  punct = "\\?\\.(?!\\d) " + punct;
  punct = punct.replace(/ /g, "|");
  var punct_pattern = new RegExp(punct);
  var line_starters = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");
  var reserved_words = line_starters.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]);
  var reserved_word_pattern = new RegExp("^(?:" + reserved_words.join("|") + ")$");
  var in_html_comment;
  var Tokenizer = function(input_string, options2) {
    BaseTokenizer.call(this, input_string, options2);
    this._patterns.whitespace = this._patterns.whitespace.matching(
      /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
      /\u2028\u2029/.source
    );
    var pattern_reader = new Pattern(this._input);
    var templatable = new TemplatablePattern(this._input).read_options(this._options);
    this.__patterns = {
      template: templatable,
      identifier: templatable.starting_with(acorn2.identifier).matching(acorn2.identifierMatch),
      number: pattern_reader.matching(number_pattern),
      punct: pattern_reader.matching(punct_pattern),
      // comment ends just before nearest linefeed or end of file
      comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
      //  /* ... */ comment ends with nearest */ or end of file
      block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
      html_comment_start: pattern_reader.matching(/<!--/),
      html_comment_end: pattern_reader.matching(/-->/),
      include: pattern_reader.starting_with(/#include/).until_after(acorn2.lineBreak),
      shebang: pattern_reader.starting_with(/#!/).until_after(acorn2.lineBreak),
      xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
      single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
      double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
      template_text: templatable.until(/[`\\$]/),
      template_expression: templatable.until(/[`}\\]/)
    };
  };
  Tokenizer.prototype = new BaseTokenizer();
  Tokenizer.prototype._is_comment = function(current_token) {
    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
  };
  Tokenizer.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
  };
  Tokenizer.prototype._is_closing = function(current_token, open_token) {
    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && (open_token && (current_token.text === "]" && open_token.text === "[" || current_token.text === ")" && open_token.text === "(" || current_token.text === "}" && open_token.text === "{"));
  };
  Tokenizer.prototype._reset = function() {
    in_html_comment = false;
  };
  Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c = this._input.peek();
    if (c === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_non_javascript(c);
    token2 = token2 || this._read_string(c);
    token2 = token2 || this._read_word(previous_token);
    token2 = token2 || this._read_singles(c);
    token2 = token2 || this._read_comment(c);
    token2 = token2 || this._read_regexp(c, previous_token);
    token2 = token2 || this._read_xml(c, previous_token);
    token2 = token2 || this._read_punctuation();
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer.prototype._read_word = function(previous_token) {
    var resulting_string;
    resulting_string = this.__patterns.identifier.read();
    if (resulting_string !== "") {
      resulting_string = resulting_string.replace(acorn2.allLineBreaks, "\n");
      if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === "set" || previous_token.text === "get")) && reserved_word_pattern.test(resulting_string)) {
        if ((resulting_string === "in" || resulting_string === "of") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {
          return this._create_token(TOKEN.OPERATOR, resulting_string);
        }
        return this._create_token(TOKEN.RESERVED, resulting_string);
      }
      return this._create_token(TOKEN.WORD, resulting_string);
    }
    resulting_string = this.__patterns.number.read();
    if (resulting_string !== "") {
      return this._create_token(TOKEN.WORD, resulting_string);
    }
  };
  Tokenizer.prototype._read_singles = function(c) {
    var token2 = null;
    if (c === "(" || c === "[") {
      token2 = this._create_token(TOKEN.START_EXPR, c);
    } else if (c === ")" || c === "]") {
      token2 = this._create_token(TOKEN.END_EXPR, c);
    } else if (c === "{") {
      token2 = this._create_token(TOKEN.START_BLOCK, c);
    } else if (c === "}") {
      token2 = this._create_token(TOKEN.END_BLOCK, c);
    } else if (c === ";") {
      token2 = this._create_token(TOKEN.SEMICOLON, c);
    } else if (c === "." && dot_pattern.test(this._input.peek(1))) {
      token2 = this._create_token(TOKEN.DOT, c);
    } else if (c === ",") {
      token2 = this._create_token(TOKEN.COMMA, c);
    }
    if (token2) {
      this._input.next();
    }
    return token2;
  };
  Tokenizer.prototype._read_punctuation = function() {
    var resulting_string = this.__patterns.punct.read();
    if (resulting_string !== "") {
      if (resulting_string === "=") {
        return this._create_token(TOKEN.EQUALS, resulting_string);
      } else if (resulting_string === "?.") {
        return this._create_token(TOKEN.DOT, resulting_string);
      } else {
        return this._create_token(TOKEN.OPERATOR, resulting_string);
      }
    }
  };
  Tokenizer.prototype._read_non_javascript = function(c) {
    var resulting_string = "";
    if (c === "#") {
      if (this._is_first_token()) {
        resulting_string = this.__patterns.shebang.read();
        if (resulting_string) {
          return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
        }
      }
      resulting_string = this.__patterns.include.read();
      if (resulting_string) {
        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
      }
      c = this._input.next();
      var sharp = "#";
      if (this._input.hasNext() && this._input.testChar(digit)) {
        do {
          c = this._input.next();
          sharp += c;
        } while (this._input.hasNext() && c !== "#" && c !== "=");
        if (c === "#")
          ;
        else if (this._input.peek() === "[" && this._input.peek(1) === "]") {
          sharp += "[]";
          this._input.next();
          this._input.next();
        } else if (this._input.peek() === "{" && this._input.peek(1) === "}") {
          sharp += "{}";
          this._input.next();
          this._input.next();
        }
        return this._create_token(TOKEN.WORD, sharp);
      }
      this._input.back();
    } else if (c === "<" && this._is_first_token()) {
      resulting_string = this.__patterns.html_comment_start.read();
      if (resulting_string) {
        while (this._input.hasNext() && !this._input.testChar(acorn2.newline)) {
          resulting_string += this._input.next();
        }
        in_html_comment = true;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    } else if (in_html_comment && c === "-") {
      resulting_string = this.__patterns.html_comment_end.read();
      if (resulting_string) {
        in_html_comment = false;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    }
    return null;
  };
  Tokenizer.prototype._read_comment = function(c) {
    var token2 = null;
    if (c === "/") {
      var comment = "";
      if (this._input.peek(1) === "*") {
        comment = this.__patterns.block_comment.read();
        var directives2 = directives_core.get_directives(comment);
        if (directives2 && directives2.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        comment = comment.replace(acorn2.allLineBreaks, "\n");
        token2 = this._create_token(TOKEN.BLOCK_COMMENT, comment);
        token2.directives = directives2;
      } else if (this._input.peek(1) === "/") {
        comment = this.__patterns.comment.read();
        token2 = this._create_token(TOKEN.COMMENT, comment);
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_string = function(c) {
    if (c === "`" || c === "'" || c === '"') {
      var resulting_string = this._input.next();
      this.has_char_escapes = false;
      if (c === "`") {
        resulting_string += this._read_string_recursive("`", true, "${");
      } else {
        resulting_string += this._read_string_recursive(c);
      }
      if (this.has_char_escapes && this._options.unescape_strings) {
        resulting_string = unescape_string(resulting_string);
      }
      if (this._input.peek() === c) {
        resulting_string += this._input.next();
      }
      resulting_string = resulting_string.replace(acorn2.allLineBreaks, "\n");
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === ")" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ["if", "while", "for"]) || in_array(previous_token.type, [
      TOKEN.COMMENT,
      TOKEN.START_EXPR,
      TOKEN.START_BLOCK,
      TOKEN.START,
      TOKEN.END_BLOCK,
      TOKEN.OPERATOR,
      TOKEN.EQUALS,
      TOKEN.EOF,
      TOKEN.SEMICOLON,
      TOKEN.COMMA
    ]);
  };
  Tokenizer.prototype._read_regexp = function(c, previous_token) {
    if (c === "/" && this._allow_regexp_or_xml(previous_token)) {
      var resulting_string = this._input.next();
      var esc = false;
      var in_char_class = false;
      while (this._input.hasNext() && ((esc || in_char_class || this._input.peek() !== c) && !this._input.testChar(acorn2.newline))) {
        resulting_string += this._input.peek();
        if (!esc) {
          esc = this._input.peek() === "\\";
          if (this._input.peek() === "[") {
            in_char_class = true;
          } else if (this._input.peek() === "]") {
            in_char_class = false;
          }
        } else {
          esc = false;
        }
        this._input.next();
      }
      if (this._input.peek() === c) {
        resulting_string += this._input.next();
        resulting_string += this._input.read(acorn2.identifier);
      }
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer.prototype._read_xml = function(c, previous_token) {
    if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
      var xmlStr = "";
      var match = this.__patterns.xml.read_match();
      if (match) {
        var rootTag = match[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}");
        var isCurlyRoot = rootTag.indexOf("{") === 0;
        var depth = 0;
        while (match) {
          var isEndTag = !!match[1];
          var tagName = match[2];
          var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
          if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\s+/, "{").replace(/\s+}$/, "}"))) {
            if (isEndTag) {
              --depth;
            } else {
              ++depth;
            }
          }
          xmlStr += match[0];
          if (depth <= 0) {
            break;
          }
          match = this.__patterns.xml.read_match();
        }
        if (!match) {
          xmlStr += this._input.match(/[\s\S]*/g)[0];
        }
        xmlStr = xmlStr.replace(acorn2.allLineBreaks, "\n");
        return this._create_token(TOKEN.STRING, xmlStr);
      }
    }
    return null;
  };
  function unescape_string(s2) {
    var out = "", escaped = 0;
    var input_scan = new InputScanner(s2);
    var matched = null;
    while (input_scan.hasNext()) {
      matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);
      if (matched) {
        out += matched[0];
      }
      if (input_scan.peek() === "\\") {
        input_scan.next();
        if (input_scan.peek() === "x") {
          matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
        } else if (input_scan.peek() === "u") {
          matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
        } else {
          out += "\\";
          if (input_scan.hasNext()) {
            out += input_scan.next();
          }
          continue;
        }
        if (!matched) {
          return s2;
        }
        escaped = parseInt(matched[1], 16);
        if (escaped > 126 && escaped <= 255 && matched[0].indexOf("x") === 0) {
          return s2;
        } else if (escaped >= 0 && escaped < 32) {
          out += "\\" + matched[0];
          continue;
        } else if (escaped === 34 || escaped === 39 || escaped === 92) {
          out += "\\" + String.fromCharCode(escaped);
        } else {
          out += String.fromCharCode(escaped);
        }
      }
    }
    return out;
  }
  Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
    var current_char;
    var pattern2;
    if (delimiter === "'") {
      pattern2 = this.__patterns.single_quote;
    } else if (delimiter === '"') {
      pattern2 = this.__patterns.double_quote;
    } else if (delimiter === "`") {
      pattern2 = this.__patterns.template_text;
    } else if (delimiter === "}") {
      pattern2 = this.__patterns.template_expression;
    }
    var resulting_string = pattern2.read();
    var next = "";
    while (this._input.hasNext()) {
      next = this._input.next();
      if (next === delimiter || !allow_unescaped_newlines && acorn2.newline.test(next)) {
        this._input.back();
        break;
      } else if (next === "\\" && this._input.hasNext()) {
        current_char = this._input.peek();
        if (current_char === "x" || current_char === "u") {
          this.has_char_escapes = true;
        } else if (current_char === "\r" && this._input.peek(1) === "\n") {
          this._input.next();
        }
        next += this._input.next();
      } else if (start_sub) {
        if (start_sub === "${" && next === "$" && this._input.peek() === "{") {
          next += this._input.next();
        }
        if (start_sub === next) {
          if (delimiter === "`") {
            next += this._read_string_recursive("}", allow_unescaped_newlines, "`");
          } else {
            next += this._read_string_recursive("`", allow_unescaped_newlines, "${");
          }
          if (this._input.hasNext()) {
            next += this._input.next();
          }
        }
      }
      next += pattern2.read();
      resulting_string += next;
    }
    return resulting_string;
  };
  tokenizer$2.Tokenizer = Tokenizer;
  tokenizer$2.TOKEN = TOKEN;
  tokenizer$2.positionable_operators = positionable_operators.slice();
  tokenizer$2.line_starters = line_starters.slice();
  return tokenizer$2;
}
var hasRequiredBeautifier$2;
function requireBeautifier$2() {
  if (hasRequiredBeautifier$2)
    return beautifier$2;
  hasRequiredBeautifier$2 = 1;
  var Output2 = requireOutput().Output;
  var Token3 = requireToken().Token;
  var acorn2 = requireAcorn();
  var Options = requireOptions$2().Options;
  var Tokenizer = requireTokenizer$1().Tokenizer;
  var line_starters = requireTokenizer$1().line_starters;
  var positionable_operators = requireTokenizer$1().positionable_operators;
  var TOKEN = requireTokenizer$1().TOKEN;
  function in_array(what, arr2) {
    return arr2.indexOf(what) !== -1;
  }
  function ltrim(s2) {
    return s2.replace(/^\s+/g, "");
  }
  function generateMapFromStrings(list2) {
    var result = {};
    for (var x2 = 0; x2 < list2.length; x2++) {
      result[list2[x2].replace(/-/g, "_")] = list2[x2];
    }
    return result;
  }
  function reserved_word(token2, word) {
    return token2 && token2.type === TOKEN.RESERVED && token2.text === word;
  }
  function reserved_array(token2, words) {
    return token2 && token2.type === TOKEN.RESERVED && in_array(token2.text, words);
  }
  var special_words = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"];
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);
  var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];
  var MODE = {
    BlockStatement: "BlockStatement",
    // 'BLOCK'
    Statement: "Statement",
    // 'STATEMENT'
    ObjectLiteral: "ObjectLiteral",
    // 'OBJECT',
    ArrayLiteral: "ArrayLiteral",
    //'[EXPRESSION]',
    ForInitializer: "ForInitializer",
    //'(FOR-EXPRESSION)',
    Conditional: "Conditional",
    //'(COND-EXPRESSION)',
    Expression: "Expression"
    //'(EXPRESSION)'
  };
  function remove_redundant_indentation(output3, frame) {
    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {
      return;
    }
    output3.remove_indent(frame.start_line_index);
  }
  function split_linebreaks(s2) {
    s2 = s2.replace(acorn2.allLineBreaks, "\n");
    var out = [], idx = s2.indexOf("\n");
    while (idx !== -1) {
      out.push(s2.substring(0, idx));
      s2 = s2.substring(idx + 1);
      idx = s2.indexOf("\n");
    }
    if (s2.length) {
      out.push(s2);
    }
    return out;
  }
  function is_array(mode) {
    return mode === MODE.ArrayLiteral;
  }
  function is_expression(mode) {
    return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
  }
  function all_lines_start_with(lines, c) {
    for (var i2 = 0; i2 < lines.length; i2++) {
      var line = lines[i2].trim();
      if (line.charAt(0) !== c) {
        return false;
      }
    }
    return true;
  }
  function each_line_matches_indent(lines, indent) {
    var i2 = 0, len2 = lines.length, line;
    for (; i2 < len2; i2++) {
      line = lines[i2];
      if (line && line.indexOf(indent) !== 0) {
        return false;
      }
    }
    return true;
  }
  function Beautifier(source_text, options2) {
    options2 = options2 || {};
    this._source_text = source_text || "";
    this._output = null;
    this._tokens = null;
    this._last_last_text = null;
    this._flags = null;
    this._previous_flags = null;
    this._flag_store = null;
    this._options = new Options(options2);
  }
  Beautifier.prototype.create_flags = function(flags_base, mode) {
    var next_indent_level = 0;
    if (flags_base) {
      next_indent_level = flags_base.indentation_level;
      if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {
        next_indent_level = flags_base.line_indent_level;
      }
    }
    var next_flags = {
      mode,
      parent: flags_base,
      last_token: flags_base ? flags_base.last_token : new Token3(TOKEN.START_BLOCK, ""),
      // last token text
      last_word: flags_base ? flags_base.last_word : "",
      // last TOKEN.WORD passed
      declaration_statement: false,
      declaration_assignment: false,
      multiline_frame: false,
      inline_frame: false,
      if_block: false,
      else_block: false,
      class_start_block: false,
      // class A { INSIDE HERE } or class B extends C { INSIDE HERE }
      do_block: false,
      do_while: false,
      import_block: false,
      in_case_statement: false,
      // switch(..){ INSIDE HERE }
      in_case: false,
      // we're on the exact line with "case 0:"
      case_body: false,
      // the indented case-action block
      case_block: false,
      // the indented case-action block is wrapped with {}
      indentation_level: next_indent_level,
      alignment: 0,
      line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
      start_line_index: this._output.get_line_number(),
      ternary_depth: 0
    };
    return next_flags;
  };
  Beautifier.prototype._reset = function(source_text) {
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._last_last_text = "";
    this._output = new Output2(this._options, baseIndentString);
    this._output.raw = this._options.test_output_raw;
    this._flag_store = [];
    this.set_mode(MODE.BlockStatement);
    var tokenizer3 = new Tokenizer(source_text, this._options);
    this._tokens = tokenizer3.tokenize();
    return source_text;
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var sweet_code;
    var source_text = this._reset(this._source_text);
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && acorn2.lineBreak.test(source_text || "")) {
        eol = source_text.match(acorn2.lineBreak)[0];
      }
    }
    var current_token = this._tokens.next();
    while (current_token) {
      this.handle_token(current_token);
      this._last_last_text = this._flags.last_token.text;
      this._flags.last_token = current_token;
      current_token = this._tokens.next();
    }
    sweet_code = this._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
    if (current_token.type === TOKEN.START_EXPR) {
      this.handle_start_expr(current_token);
    } else if (current_token.type === TOKEN.END_EXPR) {
      this.handle_end_expr(current_token);
    } else if (current_token.type === TOKEN.START_BLOCK) {
      this.handle_start_block(current_token);
    } else if (current_token.type === TOKEN.END_BLOCK) {
      this.handle_end_block(current_token);
    } else if (current_token.type === TOKEN.WORD) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.RESERVED) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.SEMICOLON) {
      this.handle_semicolon(current_token);
    } else if (current_token.type === TOKEN.STRING) {
      this.handle_string(current_token);
    } else if (current_token.type === TOKEN.EQUALS) {
      this.handle_equals(current_token);
    } else if (current_token.type === TOKEN.OPERATOR) {
      this.handle_operator(current_token);
    } else if (current_token.type === TOKEN.COMMA) {
      this.handle_comma(current_token);
    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
      this.handle_block_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.COMMENT) {
      this.handle_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.DOT) {
      this.handle_dot(current_token);
    } else if (current_token.type === TOKEN.EOF) {
      this.handle_eof(current_token);
    } else if (current_token.type === TOKEN.UNKNOWN) {
      this.handle_unknown(current_token, preserve_statement_flags);
    } else {
      this.handle_unknown(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
    var newlines = current_token.newlines;
    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);
    if (current_token.comments_before) {
      var comment_token = current_token.comments_before.next();
      while (comment_token) {
        this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
        this.handle_token(comment_token, preserve_statement_flags);
        comment_token = current_token.comments_before.next();
      }
    }
    if (keep_whitespace) {
      for (var i2 = 0; i2 < newlines; i2 += 1) {
        this.print_newline(i2 > 0, preserve_statement_flags);
      }
    } else {
      if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
        newlines = this._options.max_preserve_newlines;
      }
      if (this._options.preserve_newlines) {
        if (newlines > 1) {
          this.print_newline(false, preserve_statement_flags);
          for (var j = 1; j < newlines; j += 1) {
            this.print_newline(true, preserve_statement_flags);
          }
        }
      }
    }
  };
  var newline_restricted_tokens = ["async", "break", "continue", "return", "throw", "yield"];
  Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
    force_linewrap = force_linewrap === void 0 ? false : force_linewrap;
    if (this._output.just_added_newline()) {
      return;
    }
    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;
    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);
    if (operatorLogicApplies) {
      var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);
      shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
    }
    if (shouldPreserveOrForce) {
      this.print_newline(false, true);
    } else if (this._options.wrap_line_length) {
      if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        return;
      }
      this._output.set_wrap_point();
    }
  };
  Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
    if (!preserve_statement_flags) {
      if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) {
        var next_token = this._tokens.peek();
        while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
          this.restore_mode();
        }
      }
    }
    if (this._output.add_new_line(force_newline)) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.print_token_line_indentation = function(current_token) {
    if (this._output.just_added_newline()) {
      if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === "[" || is_array(this._flags.mode))) {
        this._output.current_line.set_indent(-1);
        this._output.current_line.push(current_token.whitespace_before);
        this._output.space_before_token = false;
      } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
        this._flags.line_indent_level = this._flags.indentation_level;
      }
    }
  };
  Beautifier.prototype.print_token = function(current_token) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      return;
    }
    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {
      if (this._output.previous_line.last() === ",") {
        var popped = this._output.previous_line.pop();
        if (this._output.previous_line.is_empty()) {
          this._output.previous_line.push(popped);
          this._output.trim(true);
          this._output.current_line.pop();
          this._output.trim();
        }
        this.print_token_line_indentation(current_token);
        this._output.add_token(",");
        this._output.space_before_token = true;
      }
    }
    this.print_token_line_indentation(current_token);
    this._output.non_breaking_space = true;
    this._output.add_token(current_token.text);
    if (this._output.previous_token_wrapped) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._flags.indentation_level += 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.deindent = function() {
    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {
      this._flags.indentation_level -= 1;
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.set_mode = function(mode) {
    if (this._flags) {
      this._flag_store.push(this._flags);
      this._previous_flags = this._flags;
    } else {
      this._previous_flags = this.create_flags(null, mode);
    }
    this._flags = this.create_flags(this._previous_flags, mode);
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.restore_mode = function() {
    if (this._flag_store.length > 0) {
      this._previous_flags = this._flags;
      this._flags = this._flag_store.pop();
      if (this._previous_flags.mode === MODE.Statement) {
        remove_redundant_indentation(this._output, this._previous_flags);
      }
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.start_of_object_property = function() {
    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
  };
  Beautifier.prototype.start_of_statement = function(current_token) {
    var start = false;
    start = start || reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD;
    start = start || reserved_word(this._flags.last_token, "do");
    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
    start = start || reserved_word(this._flags.last_token, "else") && !(reserved_word(current_token, "if") && !current_token.comments_before);
    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);
    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === "--" || current_token.text === "++") && this._last_last_text !== "function" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;
    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
    if (start) {
      this.set_mode(MODE.Statement);
      this.indent();
      this.handle_whitespace_and_comments(current_token, true);
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(
          current_token,
          reserved_array(current_token, ["do", "for", "if", "while"])
        );
      }
      return true;
    }
    return false;
  };
  Beautifier.prototype.handle_start_expr = function(current_token) {
    if (!this.start_of_statement(current_token)) {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_mode = MODE.Expression;
    if (current_token.text === "[") {
      if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ")") {
        if (reserved_array(this._flags.last_token, line_starters)) {
          this._output.space_before_token = true;
        }
        this.print_token(current_token);
        this.set_mode(next_mode);
        this.indent();
        if (this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        return;
      }
      next_mode = MODE.ArrayLiteral;
      if (is_array(this._flags.mode)) {
        if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) {
          if (!this._options.keep_array_indentation) {
            this.print_newline();
          }
        }
      }
      if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
        this._output.space_before_token = true;
      }
    } else {
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        if (this._flags.last_token.text === "for") {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.ForInitializer;
        } else if (in_array(this._flags.last_token.text, ["if", "while", "switch"])) {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.Conditional;
        } else if (in_array(this._flags.last_word, ["await", "async"])) {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "import" && current_token.whitespace_before === "") {
          this._output.space_before_token = false;
        } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === "catch") {
          this._output.space_before_token = true;
        }
      } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (this._flags.last_token.type === TOKEN.WORD) {
        this._output.space_before_token = false;
        var peek_back_two = this._tokens.peek(-3);
        if (this._options.space_after_named_function && peek_back_two) {
          var peek_back_three = this._tokens.peek(-4);
          if (reserved_array(peek_back_two, ["async", "function"]) || peek_back_two.text === "*" && reserved_array(peek_back_three, ["async", "function"])) {
            this._output.space_before_token = true;
          } else if (this._flags.mode === MODE.ObjectLiteral) {
            if (peek_back_two.text === "{" || peek_back_two.text === "," || peek_back_two.text === "*" && (peek_back_three.text === "{" || peek_back_three.text === ",")) {
              this._output.space_before_token = true;
            }
          } else if (this._flags.parent && this._flags.parent.class_start_block) {
            this._output.space_before_token = true;
          }
        }
      } else {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
        this._output.space_before_token = this._options.space_after_anon_function;
      }
    }
    if (this._flags.last_token.text === ";" || this._flags.last_token.type === TOKEN.START_BLOCK) {
      this.print_newline();
    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === TOKEN.COMMA) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
    }
    this.print_token(current_token);
    this.set_mode(next_mode);
    if (this._options.space_in_paren) {
      this._output.space_before_token = true;
    }
    this.indent();
  };
  Beautifier.prototype.handle_end_expr = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.multiline_frame) {
      this.allow_wrap_or_preserved_newline(
        current_token,
        current_token.text === "]" && is_array(this._flags.mode) && !this._options.keep_array_indentation
      );
    }
    if (this._options.space_in_paren) {
      if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
        this._output.trim();
        this._output.space_before_token = false;
      } else {
        this._output.space_before_token = true;
      }
    }
    this.deindent();
    this.print_token(current_token);
    this.restore_mode();
    remove_redundant_indentation(this._output, this._previous_flags);
    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
      this._previous_flags.mode = MODE.Expression;
      this._flags.do_block = false;
      this._flags.do_while = false;
    }
  };
  Beautifier.prototype.handle_start_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    var next_token = this._tokens.peek();
    var second_token = this._tokens.peek(1);
    if (this._flags.last_word === "switch" && this._flags.last_token.type === TOKEN.END_EXPR) {
      this.set_mode(MODE.BlockStatement);
      this._flags.in_case_statement = true;
    } else if (this._flags.case_body) {
      this.set_mode(MODE.BlockStatement);
    } else if (second_token && (in_array(second_token.text, [":", ","]) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED]) || in_array(next_token.text, ["get", "set", "..."]) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))) {
      if (in_array(this._last_last_text, ["class", "interface"]) && !in_array(second_token.text, [":", ","])) {
        this.set_mode(MODE.BlockStatement);
      } else {
        this.set_mode(MODE.ObjectLiteral);
      }
    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === "=>") {
      this.set_mode(MODE.BlockStatement);
    } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) || reserved_array(this._flags.last_token, ["return", "throw", "import", "default"])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
    if (this._flags.last_token) {
      if (reserved_array(this._flags.last_token.previous, ["class", "extends"])) {
        this._flags.class_start_block = true;
      }
    }
    var empty_braces = !next_token.comments_before && next_token.text === "}";
    var empty_anonymous_function = empty_braces && this._flags.last_word === "function" && this._flags.last_token.type === TOKEN.END_EXPR;
    if (this._options.brace_preserve_inline) {
      var index2 = 0;
      var check_token = null;
      this._flags.inline_frame = true;
      do {
        index2 += 1;
        check_token = this._tokens.peek(index2 - 1);
        if (check_token.newlines) {
          this._flags.inline_frame = false;
          break;
        }
      } while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
    }
    if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
      if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== "else")) {
        this._output.space_before_token = true;
      } else {
        this.print_newline(false, true);
      }
    } else {
      if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
        if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {
          this.allow_wrap_or_preserved_newline(current_token);
          this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
          this._flags.multiline_frame = false;
        }
      }
      if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
        if (this._flags.last_token.type === TOKEN.START_BLOCK && !this._flags.inline_frame) {
          this.print_newline();
        } else {
          this._output.space_before_token = true;
        }
      }
    }
    this.print_token(current_token);
    this.indent();
    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
      this.print_newline();
    }
  };
  Beautifier.prototype.handle_end_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;
    if (this._flags.inline_frame && !empty_braces) {
      this._output.space_before_token = true;
    } else if (this._options.brace_style === "expand") {
      if (!empty_braces) {
        this.print_newline();
      }
    } else {
      if (!empty_braces) {
        if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
          this._options.keep_array_indentation = false;
          this.print_newline();
          this._options.keep_array_indentation = true;
        } else {
          this.print_newline();
        }
      }
    }
    this.restore_mode();
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_word = function(current_token) {
    if (current_token.type === TOKEN.RESERVED) {
      if (in_array(current_token.text, ["set", "get"]) && this._flags.mode !== MODE.ObjectLiteral) {
        current_token.type = TOKEN.WORD;
      } else if (current_token.text === "import" && in_array(this._tokens.peek().text, ["(", "."])) {
        current_token.type = TOKEN.WORD;
      } else if (in_array(current_token.text, ["as", "from"]) && !this._flags.import_block) {
        current_token.type = TOKEN.WORD;
      } else if (this._flags.mode === MODE.ObjectLiteral) {
        var next_token = this._tokens.peek();
        if (next_token.text === ":") {
          current_token.type = TOKEN.WORD;
        }
      }
    }
    if (this.start_of_statement(current_token)) {
      if (reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD) {
        this._flags.declaration_statement = true;
      }
    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ["var", "let", "const", "set", "get"]))) {
      this.handle_whitespace_and_comments(current_token);
      this.print_newline();
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.do_block && !this._flags.do_while) {
      if (reserved_word(current_token, "while")) {
        this._output.space_before_token = true;
        this.print_token(current_token);
        this._output.space_before_token = true;
        this._flags.do_while = true;
        return;
      } else {
        this.print_newline();
        this._flags.do_block = false;
      }
    }
    if (this._flags.if_block) {
      if (!this._flags.else_block && reserved_word(current_token, "else")) {
        this._flags.else_block = true;
      } else {
        while (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        this._flags.if_block = false;
        this._flags.else_block = false;
      }
    }
    if (this._flags.in_case_statement && reserved_array(current_token, ["case", "default"])) {
      this.print_newline();
      if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
        this.deindent();
      }
      this._flags.case_body = false;
      this.print_token(current_token);
      this._flags.in_case = true;
      return;
    }
    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    }
    if (reserved_word(current_token, "function")) {
      if (in_array(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === TOKEN.OPERATOR)) {
        if (!this._output.just_added_blankline() && !current_token.comments_before) {
          this.print_newline();
          this.print_newline(true);
        }
      }
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
        if (reserved_array(this._flags.last_token, ["get", "set", "new", "export"]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {
          this._output.space_before_token = true;
        } else if (reserved_word(this._flags.last_token, "default") && this._last_last_text === "export") {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "declare") {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === "=") {
        this._output.space_before_token = true;
      } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode)))
        ;
      else {
        this.print_newline();
      }
      this.print_token(current_token);
      this._flags.last_word = current_token.text;
      return;
    }
    var prefix2 = "NONE";
    if (this._flags.last_token.type === TOKEN.END_BLOCK) {
      if (this._previous_flags.inline_frame) {
        prefix2 = "SPACE";
      } else if (!reserved_array(current_token, ["else", "catch", "finally", "from"])) {
        prefix2 = "NEWLINE";
      } else {
        if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) {
          prefix2 = "NEWLINE";
        } else {
          prefix2 = "SPACE";
          this._output.space_before_token = true;
        }
      }
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
      prefix2 = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
      prefix2 = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.STRING) {
      prefix2 = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
      prefix2 = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
      if (this._flags.inline_frame) {
        prefix2 = "SPACE";
      } else {
        prefix2 = "NEWLINE";
      }
    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
      this._output.space_before_token = true;
      prefix2 = "NEWLINE";
    }
    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
      if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export") {
        prefix2 = "SPACE";
      } else {
        prefix2 = "NEWLINE";
      }
    }
    if (reserved_array(current_token, ["else", "catch", "finally"])) {
      if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.trim(true);
        var line = this._output.current_line;
        if (line.last() !== "}") {
          this.print_newline();
        }
        this._output.space_before_token = true;
      }
    } else if (prefix2 === "NEWLINE") {
      if (reserved_array(this._flags.last_token, special_words)) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === "declare" && reserved_array(current_token, ["var", "let", "const"])) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
        if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ["var", "let", "const"])) && this._flags.last_token.text !== ":") {
          if (reserved_word(current_token, "if") && reserved_word(current_token.previous, "else")) {
            this._output.space_before_token = true;
          } else {
            this.print_newline();
          }
        }
      } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
        this.print_newline();
      }
    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}") {
      this.print_newline();
    } else if (prefix2 === "SPACE") {
      this._output.space_before_token = true;
    }
    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
      this._output.space_before_token = true;
    }
    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    if (current_token.type === TOKEN.RESERVED) {
      if (current_token.text === "do") {
        this._flags.do_block = true;
      } else if (current_token.text === "if") {
        this._flags.if_block = true;
      } else if (current_token.text === "import") {
        this._flags.import_block = true;
      } else if (this._flags.import_block && reserved_word(current_token, "from")) {
        this._flags.import_block = false;
      }
    }
  };
  Beautifier.prototype.handle_semicolon = function(current_token) {
    if (this.start_of_statement(current_token)) {
      this._output.space_before_token = false;
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_token = this._tokens.peek();
    while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
      this.restore_mode();
    }
    if (this._flags.import_block) {
      this._flags.import_block = false;
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_string = function(current_token) {
    if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === "" && (current_token.previous.text === ")" || this._flags.last_token.type === TOKEN.WORD))
      ;
    else if (this.start_of_statement(current_token)) {
      this._output.space_before_token = true;
    } else {
      this.handle_whitespace_and_comments(current_token);
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === "]" || current_token.previous.text === ")") && current_token.newlines === 0) {
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_equals = function(current_token) {
    if (this.start_of_statement(current_token))
      ;
    else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.declaration_statement) {
      this._flags.declaration_assignment = true;
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
  };
  Beautifier.prototype.handle_comma = function(current_token) {
    this.handle_whitespace_and_comments(current_token, true);
    this.print_token(current_token);
    this._output.space_before_token = true;
    if (this._flags.declaration_statement) {
      if (is_expression(this._flags.parent.mode)) {
        this._flags.declaration_assignment = false;
      }
      if (this._flags.declaration_assignment) {
        this._flags.declaration_assignment = false;
        this.print_newline(false, true);
      } else if (this._options.comma_first) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {
      if (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      if (!this._flags.inline_frame) {
        this.print_newline();
      }
    } else if (this._options.comma_first) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  };
  Beautifier.prototype.handle_operator = function(current_token) {
    var isGeneratorAsterisk = current_token.text === "*" && (reserved_array(this._flags.last_token, ["function", "yield"]) || in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]));
    var isUnary = in_array(current_token.text, ["-", "+"]) && (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === ",");
    if (this.start_of_statement(current_token))
      ;
    else {
      var preserve_statement_flags = !isGeneratorAsterisk;
      this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
    }
    if (current_token.text === "*" && this._flags.last_token.type === TOKEN.DOT) {
      this.print_token(current_token);
      return;
    }
    if (current_token.text === "::") {
      this.print_token(current_token);
      return;
    }
    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
    if (current_token.text === ":" && this._flags.in_case) {
      this.print_token(current_token);
      this._flags.in_case = false;
      this._flags.case_body = true;
      if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
        this.indent();
        this.print_newline();
        this._flags.case_block = false;
      } else {
        this._flags.case_block = true;
        this._output.space_before_token = true;
      }
      return;
    }
    var space_before = true;
    var space_after = true;
    var in_ternary = false;
    if (current_token.text === ":") {
      if (this._flags.ternary_depth === 0) {
        space_before = false;
      } else {
        this._flags.ternary_depth -= 1;
        in_ternary = true;
      }
    } else if (current_token.text === "?") {
      this._flags.ternary_depth += 1;
    }
    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
      var isColon = current_token.text === ":";
      var isTernaryColon = isColon && in_ternary;
      var isOtherColon = isColon && !in_ternary;
      switch (this._options.operator_position) {
        case OPERATOR_POSITION.before_newline:
          this._output.space_before_token = !isOtherColon;
          this.print_token(current_token);
          if (!isColon || isTernaryColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.after_newline:
          this._output.space_before_token = true;
          if (!isColon || isTernaryColon) {
            if (this._tokens.peek().newlines) {
              this.print_newline(false, true);
            } else {
              this.allow_wrap_or_preserved_newline(current_token);
            }
          } else {
            this._output.space_before_token = false;
          }
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.preserve_newline:
          if (!isOtherColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          space_before = !(this._output.just_added_newline() || isOtherColon);
          this._output.space_before_token = space_before;
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
      }
    }
    if (isGeneratorAsterisk) {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = false;
      var next_token = this._tokens.peek();
      space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
    } else if (current_token.text === "...") {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
      space_after = false;
    } else if (in_array(current_token.text, ["--", "++", "!", "~"]) || isUnary) {
      if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      space_before = false;
      space_after = false;
      if (current_token.newlines && (current_token.text === "--" || current_token.text === "++" || current_token.text === "~")) {
        var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
        if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
          this.restore_mode();
        }
        this.print_newline(new_line_needed, true);
      }
      if (this._flags.last_token.text === ";" && is_expression(this._flags.mode)) {
        space_before = true;
      }
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        space_before = true;
      } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
        space_before = !(this._flags.last_token.text === "]" && (current_token.text === "--" || current_token.text === "++"));
      } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
        space_before = in_array(current_token.text, ["--", "-", "++", "+"]) && in_array(this._flags.last_token.text, ["--", "-", "++", "+"]);
        if (in_array(current_token.text, ["+", "-"]) && in_array(this._flags.last_token.text, ["--", "++"])) {
          space_after = true;
        }
      }
      if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";")) {
        this.print_newline();
      }
    }
    this._output.space_before_token = this._output.space_before_token || space_before;
    this.print_token(current_token);
    this._output.space_before_token = space_after;
  };
  Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      if (current_token.directives && current_token.directives.preserve === "end") {
        this._output.raw = this._options.test_output_raw;
      }
      return;
    }
    if (current_token.directives) {
      this.print_newline(false, preserve_statement_flags);
      this.print_token(current_token);
      if (current_token.directives.preserve === "start") {
        this._output.raw = true;
      }
      this.print_newline(false, true);
      return;
    }
    if (!acorn2.newline.test(current_token.text) && !current_token.newlines) {
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      return;
    } else {
      this.print_block_commment(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
    var lines = split_linebreaks(current_token.text);
    var j;
    var javadoc = false;
    var starless = false;
    var lastIndent = current_token.whitespace_before;
    var lastIndentLength = lastIndent.length;
    this.print_newline(false, preserve_statement_flags);
    this.print_token_line_indentation(current_token);
    this._output.add_token(lines[0]);
    this.print_newline(false, preserve_statement_flags);
    if (lines.length > 1) {
      lines = lines.slice(1);
      javadoc = all_lines_start_with(lines, "*");
      starless = each_line_matches_indent(lines, lastIndent);
      if (javadoc) {
        this._flags.alignment = 1;
      }
      for (j = 0; j < lines.length; j++) {
        if (javadoc) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(ltrim(lines[j]));
        } else if (starless && lines[j]) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(lines[j].substring(lastIndentLength));
        } else {
          this._output.current_line.set_indent(-1);
          this._output.add_token(lines[j]);
        }
        this.print_newline(false, preserve_statement_flags);
      }
      this._flags.alignment = 0;
    }
  };
  Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
    if (current_token.newlines) {
      this.print_newline(false, preserve_statement_flags);
    } else {
      this._output.trim(true);
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this.print_newline(false, preserve_statement_flags);
  };
  Beautifier.prototype.handle_dot = function(current_token) {
    if (this.start_of_statement(current_token))
      ;
    else {
      this.handle_whitespace_and_comments(current_token, true);
    }
    if (this._flags.last_token.text.match("^[0-9]+$")) {
      this._output.space_before_token = true;
    }
    if (reserved_array(this._flags.last_token, special_words)) {
      this._output.space_before_token = false;
    } else {
      this.allow_wrap_or_preserved_newline(
        current_token,
        this._flags.last_token.text === ")" && this._options.break_chained_methods
      );
    }
    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
      this.deindent();
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
    this.print_token(current_token);
    if (current_token.text[current_token.text.length - 1] === "\n") {
      this.print_newline(false, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_eof = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
  };
  beautifier$2.Beautifier = Beautifier;
  return beautifier$2;
}
var hasRequiredJavascript;
function requireJavascript() {
  if (hasRequiredJavascript)
    return javascript.exports;
  hasRequiredJavascript = 1;
  var Beautifier = requireBeautifier$2().Beautifier, Options = requireOptions$2().Options;
  function js_beautify(js_source_text, options2) {
    var beautifier2 = new Beautifier(js_source_text, options2);
    return beautifier2.beautify();
  }
  javascript.exports = js_beautify;
  javascript.exports.defaultOptions = function() {
    return new Options();
  };
  return javascript.exports;
}
var css = { exports: {} };
var beautifier$1 = {};
var options$1 = {};
var hasRequiredOptions$1;
function requireOptions$1() {
  if (hasRequiredOptions$1)
    return options$1;
  hasRequiredOptions$1 = 1;
  var BaseOptions = requireOptions$3().Options;
  function Options(options2) {
    BaseOptions.call(this, options2, "css");
    this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
    this.newline_between_rules = this._get_boolean("newline_between_rules", true);
    var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
    this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_style = "collapse";
    for (var bs = 0; bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] !== "expand") {
        this.brace_style = "collapse";
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
  }
  Options.prototype = new BaseOptions();
  options$1.Options = Options;
  return options$1;
}
var hasRequiredBeautifier$1;
function requireBeautifier$1() {
  if (hasRequiredBeautifier$1)
    return beautifier$1;
  hasRequiredBeautifier$1 = 1;
  var Options = requireOptions$1().Options;
  var Output2 = requireOutput().Output;
  var InputScanner = requireInputscanner().InputScanner;
  var Directives = requireDirectives().Directives;
  var directives_core = new Directives(/\/\*/, /\*\//);
  var lineBreak2 = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var whitespaceChar = /\s/;
  var whitespacePattern = /(?:\s|\n)+/g;
  var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
  var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
  function Beautifier(source_text, options2) {
    this._source_text = source_text || "";
    this._options = new Options(options2);
    this._ch = null;
    this._input = null;
    this.NESTED_AT_RULE = {
      "@page": true,
      "@font-face": true,
      "@keyframes": true,
      // also in CONDITIONAL_GROUP_RULE below
      "@media": true,
      "@supports": true,
      "@document": true
    };
    this.CONDITIONAL_GROUP_RULE = {
      "@media": true,
      "@supports": true,
      "@document": true
    };
    this.NON_SEMICOLON_NEWLINE_PROPERTY = [
      "grid-template-areas",
      "grid-template"
    ];
  }
  Beautifier.prototype.eatString = function(endChars) {
    var result = "";
    this._ch = this._input.next();
    while (this._ch) {
      result += this._ch;
      if (this._ch === "\\") {
        result += this._input.next();
      } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
        break;
      }
      this._ch = this._input.next();
    }
    return result;
  };
  Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
    var result = whitespaceChar.test(this._input.peek());
    var newline_count = 0;
    while (whitespaceChar.test(this._input.peek())) {
      this._ch = this._input.next();
      if (allowAtLeastOneNewLine && this._ch === "\n") {
        if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
          newline_count++;
          this._output.add_new_line(true);
        }
      }
    }
    return result;
  };
  Beautifier.prototype.foundNestedPseudoClass = function() {
    var openParen = 0;
    var i2 = 1;
    var ch = this._input.peek(i2);
    while (ch) {
      if (ch === "{") {
        return true;
      } else if (ch === "(") {
        openParen += 1;
      } else if (ch === ")") {
        if (openParen === 0) {
          return false;
        }
        openParen -= 1;
      } else if (ch === ";" || ch === "}") {
        return false;
      }
      i2++;
      ch = this._input.peek(i2);
    }
    return false;
  };
  Beautifier.prototype.print_string = function(output_string) {
    this._output.set_indent(this._indentLevel);
    this._output.non_breaking_space = true;
    this._output.add_token(output_string);
  };
  Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
    if (isAfterSpace) {
      this._output.space_before_token = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._indentLevel++;
  };
  Beautifier.prototype.outdent = function() {
    if (this._indentLevel > 0) {
      this._indentLevel--;
    }
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak2.test(source_text || "")) {
        eol = source_text.match(lineBreak2)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._output = new Output2(this._options, baseIndentString);
    this._input = new InputScanner(source_text);
    this._indentLevel = 0;
    this._nestedLevel = 0;
    this._ch = null;
    var parenLevel = 0;
    var insideRule = false;
    var insidePropertyValue = false;
    var enteringConditionalGroup = false;
    var insideAtExtend = false;
    var insideAtImport = false;
    var insideScssMap = false;
    var topCharacter = this._ch;
    var insideNonSemiColonValues = false;
    var whitespace;
    var isAfterSpace;
    var previous_ch;
    while (true) {
      whitespace = this._input.read(whitespacePattern);
      isAfterSpace = whitespace !== "";
      previous_ch = topCharacter;
      this._ch = this._input.next();
      if (this._ch === "\\" && this._input.hasNext()) {
        this._ch += this._input.next();
      }
      topCharacter = this._ch;
      if (!this._ch) {
        break;
      } else if (this._ch === "/" && this._input.peek() === "*") {
        this._output.add_new_line();
        this._input.back();
        var comment = this._input.read(block_comment_pattern);
        var directives2 = directives_core.get_directives(comment);
        if (directives2 && directives2.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        this.print_string(comment);
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "/" && this._input.peek() === "/") {
        this._output.space_before_token = true;
        this._input.back();
        this.print_string(this._input.read(comment_pattern));
        this.eatWhitespace(true);
      } else if (this._ch === "@" || this._ch === "$") {
        this.preserveSingleSpace(isAfterSpace);
        if (this._input.peek() === "{") {
          this.print_string(this._ch + this.eatString("}"));
        } else {
          this.print_string(this._ch);
          var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
          if (variableOrRule.match(/[ :]$/)) {
            variableOrRule = this.eatString(": ").replace(/\s$/, "");
            this.print_string(variableOrRule);
            this._output.space_before_token = true;
          }
          variableOrRule = variableOrRule.replace(/\s$/, "");
          if (variableOrRule === "extend") {
            insideAtExtend = true;
          } else if (variableOrRule === "import") {
            insideAtImport = true;
          }
          if (variableOrRule in this.NESTED_AT_RULE) {
            this._nestedLevel += 1;
            if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
              enteringConditionalGroup = true;
            }
          } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
            insidePropertyValue = true;
            this.indent();
          }
        }
      } else if (this._ch === "#" && this._input.peek() === "{") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch + this.eatString("}"));
      } else if (this._ch === "{") {
        if (insidePropertyValue) {
          insidePropertyValue = false;
          this.outdent();
        }
        if (enteringConditionalGroup) {
          enteringConditionalGroup = false;
          insideRule = this._indentLevel >= this._nestedLevel;
        } else {
          insideRule = this._indentLevel >= this._nestedLevel - 1;
        }
        if (this._options.newline_between_rules && insideRule) {
          if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
            this._output.ensure_empty_line_above("/", ",");
          }
        }
        this._output.space_before_token = true;
        if (this._options.brace_style === "expand") {
          this._output.add_new_line();
          this.print_string(this._ch);
          this.indent();
          this._output.set_indent(this._indentLevel);
        } else {
          if (previous_ch === "(") {
            this._output.space_before_token = false;
          } else if (previous_ch !== ",") {
            this.indent();
          }
          this.print_string(this._ch);
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "}") {
        this.outdent();
        this._output.add_new_line();
        if (previous_ch === "{") {
          this._output.trim(true);
        }
        insideAtImport = false;
        insideAtExtend = false;
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        this.print_string(this._ch);
        insideRule = false;
        if (this._nestedLevel) {
          this._nestedLevel--;
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
        if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
          if (this._input.peek() !== "}") {
            this._output.add_new_line(true);
          }
        }
        if (this._input.peek() === ")") {
          this._output.trim(true);
          if (this._options.brace_style === "expand") {
            this._output.add_new_line(true);
          }
        }
      } else if (this._ch === ":") {
        for (var i2 = 0; i2 < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i2++) {
          if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i2])) {
            insideNonSemiColonValues = true;
            break;
          }
        }
        if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideAtExtend && parenLevel === 0) {
          this.print_string(":");
          if (!insidePropertyValue) {
            insidePropertyValue = true;
            this._output.space_before_token = true;
            this.eatWhitespace(true);
            this.indent();
          }
        } else {
          if (this._input.lookBack(" ")) {
            this._output.space_before_token = true;
          }
          if (this._input.peek() === ":") {
            this._ch = this._input.next();
            this.print_string("::");
          } else {
            this.print_string(":");
          }
        }
      } else if (this._ch === '"' || this._ch === "'") {
        var preserveQuoteSpace = previous_ch === '"' || previous_ch === "'";
        this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
        this.print_string(this._ch + this.eatString(this._ch));
        this.eatWhitespace(true);
      } else if (this._ch === ";") {
        insideNonSemiColonValues = false;
        if (parenLevel === 0) {
          if (insidePropertyValue) {
            this.outdent();
            insidePropertyValue = false;
          }
          insideAtExtend = false;
          insideAtImport = false;
          this.print_string(this._ch);
          this.eatWhitespace(true);
          if (this._input.peek() !== "/") {
            this._output.add_new_line();
          }
        } else {
          this.print_string(this._ch);
          this.eatWhitespace(true);
          this._output.space_before_token = true;
        }
      } else if (this._ch === "(") {
        if (this._input.lookBack("url")) {
          this.print_string(this._ch);
          this.eatWhitespace();
          parenLevel++;
          this.indent();
          this._ch = this._input.next();
          if (this._ch === ")" || this._ch === '"' || this._ch === "'") {
            this._input.back();
          } else if (this._ch) {
            this.print_string(this._ch + this.eatString(")"));
            if (parenLevel) {
              parenLevel--;
              this.outdent();
            }
          }
        } else {
          var space_needed = false;
          if (this._input.lookBack("with")) {
            space_needed = true;
          }
          this.preserveSingleSpace(isAfterSpace || space_needed);
          this.print_string(this._ch);
          if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
            this._output.add_new_line();
            insideScssMap = true;
          } else {
            this.eatWhitespace();
            parenLevel++;
            this.indent();
          }
        }
      } else if (this._ch === ")") {
        if (parenLevel) {
          parenLevel--;
          this.outdent();
        }
        if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
          insideScssMap = false;
          this.outdent();
          this._output.add_new_line();
        }
        this.print_string(this._ch);
      } else if (this._ch === ",") {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideAtImport && !insideAtExtend) {
          this._output.add_new_line();
        } else {
          this._output.space_before_token = true;
        }
      } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
        if (this._options.space_around_combinator) {
          this._output.space_before_token = true;
          this.print_string(this._ch);
          this._output.space_before_token = true;
        } else {
          this.print_string(this._ch);
          this.eatWhitespace();
          if (this._ch && whitespaceChar.test(this._ch)) {
            this._ch = "";
          }
        }
      } else if (this._ch === "]") {
        this.print_string(this._ch);
      } else if (this._ch === "[") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
      } else if (this._ch === "=") {
        this.eatWhitespace();
        this.print_string("=");
        if (whitespaceChar.test(this._ch)) {
          this._ch = "";
        }
      } else if (this._ch === "!" && !this._input.lookBack("\\")) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
      } else {
        var preserveAfterSpace = previous_ch === '"' || previous_ch === "'";
        this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
        this.print_string(this._ch);
        if (!this._output.just_added_newline() && this._input.peek() === "\n" && insideNonSemiColonValues) {
          this._output.add_new_line();
        }
      }
    }
    var sweetCode = this._output.get_code(eol);
    return sweetCode;
  };
  beautifier$1.Beautifier = Beautifier;
  return beautifier$1;
}
var hasRequiredCss;
function requireCss() {
  if (hasRequiredCss)
    return css.exports;
  hasRequiredCss = 1;
  var Beautifier = requireBeautifier$1().Beautifier, Options = requireOptions$1().Options;
  function css_beautify(source_text, options2) {
    var beautifier2 = new Beautifier(source_text, options2);
    return beautifier2.beautify();
  }
  css.exports = css_beautify;
  css.exports.defaultOptions = function() {
    return new Options();
  };
  return css.exports;
}
var html = { exports: {} };
var beautifier = {};
var options = {};
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions)
    return options;
  hasRequiredOptions = 1;
  var BaseOptions = requireOptions$3().Options;
  function Options(options2) {
    BaseOptions.call(this, options2, "html");
    if (this.templating.length === 1 && this.templating[0] === "auto") {
      this.templating = ["django", "erb", "handlebars", "php"];
    }
    this.indent_inner_html = this._get_boolean("indent_inner_html");
    this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
    this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
    this.indent_handlebars = this._get_boolean("indent_handlebars", true);
    this.wrap_attributes = this._get_selection(
      "wrap_attributes",
      ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]
    );
    this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
    this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]);
    this.inline = this._get_array("inline", [
      "a",
      "abbr",
      "area",
      "audio",
      "b",
      "bdi",
      "bdo",
      "br",
      "button",
      "canvas",
      "cite",
      "code",
      "data",
      "datalist",
      "del",
      "dfn",
      "em",
      "embed",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "map",
      "mark",
      "math",
      "meter",
      "noscript",
      "object",
      "output",
      "progress",
      "q",
      "ruby",
      "s",
      "samp",
      /* 'script', */
      "select",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "svg",
      "template",
      "textarea",
      "time",
      "u",
      "var",
      "video",
      "wbr",
      "text",
      // obsolete inline tags
      "acronym",
      "big",
      "strike",
      "tt"
    ]);
    this.void_elements = this._get_array("void_elements", [
      // HTLM void elements - aka self-closing tags - aka singletons
      // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
      // NOTE: Optional tags are too complex for a simple list
      // they are hard coded in _do_optional_end_element
      // Doctype and xml elements
      "!doctype",
      "?xml",
      // obsolete tags
      // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
      // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
      "basefont",
      "isindex"
    ]);
    this.unformatted = this._get_array("unformatted", []);
    this.content_unformatted = this._get_array("content_unformatted", [
      "pre",
      "textarea"
    ]);
    this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
    this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
  }
  Options.prototype = new BaseOptions();
  options.Options = Options;
  return options;
}
var tokenizer = {};
var hasRequiredTokenizer;
function requireTokenizer() {
  if (hasRequiredTokenizer)
    return tokenizer;
  hasRequiredTokenizer = 1;
  var BaseTokenizer = requireTokenizer$2().Tokenizer;
  var BASETOKEN = requireTokenizer$2().TOKEN;
  var Directives = requireDirectives().Directives;
  var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
  var Pattern = requirePattern().Pattern;
  var TOKEN = {
    TAG_OPEN: "TK_TAG_OPEN",
    TAG_CLOSE: "TK_TAG_CLOSE",
    ATTRIBUTE: "TK_ATTRIBUTE",
    EQUALS: "TK_EQUALS",
    VALUE: "TK_VALUE",
    COMMENT: "TK_COMMENT",
    TEXT: "TK_TEXT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/<\!--/, /-->/);
  var Tokenizer = function(input_string, options2) {
    BaseTokenizer.call(this, input_string, options2);
    this._current_tag_name = "";
    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
    var pattern_reader = new Pattern(this._input);
    this.__patterns = {
      word: templatable_reader.until(/[\n\r\t <]/),
      single_quote: templatable_reader.until_after(/'/),
      double_quote: templatable_reader.until_after(/"/),
      attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
      element_name: templatable_reader.until(/[\n\r\t >\/]/),
      handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
      handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
      handlebars_open: pattern_reader.until(/[\n\r\t }]/),
      handlebars_raw_close: pattern_reader.until(/}}/),
      comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
      cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
      // https://en.wikipedia.org/wiki/Conditional_comment
      conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
      processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
    };
    if (this._options.indent_handlebars) {
      this.__patterns.word = this.__patterns.word.exclude("handlebars");
    }
    this._unformatted_content_delimiter = null;
    if (this._options.unformatted_content_delimiter) {
      var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
      this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
    }
  };
  Tokenizer.prototype = new BaseTokenizer();
  Tokenizer.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.TAG_OPEN;
  };
  Tokenizer.prototype._is_closing = function(current_token, open_token) {
    return current_token.type === TOKEN.TAG_CLOSE && (open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{"));
  };
  Tokenizer.prototype._reset = function() {
    this._current_tag_name = "";
  };
  Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
    var token2 = null;
    this._readWhitespace();
    var c = this._input.peek();
    if (c === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token2 = token2 || this._read_open_handlebars(c, open_token);
    token2 = token2 || this._read_attribute(c, previous_token, open_token);
    token2 = token2 || this._read_close(c, open_token);
    token2 = token2 || this._read_raw_content(c, previous_token, open_token);
    token2 = token2 || this._read_content_word(c);
    token2 = token2 || this._read_comment_or_cdata(c);
    token2 = token2 || this._read_processing(c);
    token2 = token2 || this._read_open(c, open_token);
    token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token2;
  };
  Tokenizer.prototype._read_comment_or_cdata = function(c) {
    var token2 = null;
    var resulting_string = null;
    var directives2 = null;
    if (c === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!") {
        resulting_string = this.__patterns.comment.read();
        if (resulting_string) {
          directives2 = directives_core.get_directives(resulting_string);
          if (directives2 && directives2.ignore === "start") {
            resulting_string += directives_core.readIgnored(this._input);
          }
        } else {
          resulting_string = this.__patterns.cdata.read();
        }
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives2;
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_processing = function(c) {
    var token2 = null;
    var resulting_string = null;
    var directives2 = null;
    if (c === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!" || peek1 === "?") {
        resulting_string = this.__patterns.conditional_comment.read();
        resulting_string = resulting_string || this.__patterns.processing.read();
      }
      if (resulting_string) {
        token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        token2.directives = directives2;
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_open = function(c, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token) {
      if (c === "<") {
        resulting_string = this._input.next();
        if (this._input.peek() === "/") {
          resulting_string += this._input.next();
        }
        resulting_string += this.__patterns.element_name.read();
        token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (!open_token) {
      if (this._options.indent_handlebars && c === "{" && this._input.peek(1) === "{") {
        if (this._input.peek(2) === "!") {
          resulting_string = this.__patterns.handlebars_comment.read();
          resulting_string = resulting_string || this.__patterns.handlebars.read();
          token2 = this._create_token(TOKEN.COMMENT, resulting_string);
        } else {
          resulting_string = this.__patterns.handlebars_open.read();
          token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
        }
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_close = function(c, open_token) {
    var resulting_string = null;
    var token2 = null;
    if (open_token) {
      if (open_token.text[0] === "<" && (c === ">" || c === "/" && this._input.peek(1) === ">")) {
        resulting_string = this._input.next();
        if (c === "/") {
          resulting_string += this._input.next();
        }
        token2 = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
      } else if (open_token.text[0] === "{" && c === "}" && this._input.peek(1) === "}") {
        this._input.next();
        this._input.next();
        token2 = this._create_token(TOKEN.TAG_CLOSE, "}}");
      }
    }
    return token2;
  };
  Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
    var token2 = null;
    var resulting_string = "";
    if (open_token && open_token.text[0] === "<") {
      if (c === "=") {
        token2 = this._create_token(TOKEN.EQUALS, this._input.next());
      } else if (c === '"' || c === "'") {
        var content = this._input.next();
        if (c === '"') {
          content += this.__patterns.double_quote.read();
        } else {
          content += this.__patterns.single_quote.read();
        }
        token2 = this._create_token(TOKEN.VALUE, content);
      } else {
        resulting_string = this.__patterns.attribute.read();
        if (resulting_string) {
          if (previous_token.type === TOKEN.EQUALS) {
            token2 = this._create_token(TOKEN.VALUE, resulting_string);
          } else {
            token2 = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
          }
        }
      }
    }
    return token2;
  };
  Tokenizer.prototype._is_content_unformatted = function(tag_name) {
    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
  };
  Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) {
    var resulting_string = "";
    if (open_token && open_token.text[0] === "{") {
      resulting_string = this.__patterns.handlebars_raw_close.read();
    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
      var tag_name = previous_token.opened.text.substr(1).toLowerCase();
      if (tag_name === "script" || tag_name === "style") {
        var token2 = this._read_comment_or_cdata(c);
        if (token2) {
          token2.type = TOKEN.TEXT;
          return token2;
        }
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      } else if (this._is_content_unformatted(tag_name)) {
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      }
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
    return null;
  };
  Tokenizer.prototype._read_content_word = function(c) {
    var resulting_string = "";
    if (this._options.unformatted_content_delimiter) {
      if (c === this._options.unformatted_content_delimiter[0]) {
        resulting_string = this.__patterns.unformatted_content_delimiter.read();
      }
    }
    if (!resulting_string) {
      resulting_string = this.__patterns.word.read();
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
  };
  tokenizer.Tokenizer = Tokenizer;
  tokenizer.TOKEN = TOKEN;
  return tokenizer;
}
var hasRequiredBeautifier;
function requireBeautifier() {
  if (hasRequiredBeautifier)
    return beautifier;
  hasRequiredBeautifier = 1;
  var Options = requireOptions().Options;
  var Output2 = requireOutput().Output;
  var Tokenizer = requireTokenizer().Tokenizer;
  var TOKEN = requireTokenizer().TOKEN;
  var lineBreak2 = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var Printer = function(options2, base_indent_string) {
    this.indent_level = 0;
    this.alignment_size = 0;
    this.max_preserve_newlines = options2.max_preserve_newlines;
    this.preserve_newlines = options2.preserve_newlines;
    this._output = new Output2(options2, base_indent_string);
  };
  Printer.prototype.current_line_has_match = function(pattern2) {
    return this._output.current_line.has_match(pattern2);
  };
  Printer.prototype.set_space_before_token = function(value, non_breaking) {
    this._output.space_before_token = value;
    this._output.non_breaking_space = non_breaking;
  };
  Printer.prototype.set_wrap_point = function() {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.set_wrap_point();
  };
  Printer.prototype.add_raw_token = function(token2) {
    this._output.add_raw_token(token2);
  };
  Printer.prototype.print_preserved_newlines = function(raw_token) {
    var newlines = 0;
    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
      newlines = raw_token.newlines ? 1 : 0;
    }
    if (this.preserve_newlines) {
      newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
    }
    for (var n = 0; n < newlines; n++) {
      this.print_newline(n > 0);
    }
    return newlines !== 0;
  };
  Printer.prototype.traverse_whitespace = function(raw_token) {
    if (raw_token.whitespace_before || raw_token.newlines) {
      if (!this.print_preserved_newlines(raw_token)) {
        this._output.space_before_token = true;
      }
      return true;
    }
    return false;
  };
  Printer.prototype.previous_token_wrapped = function() {
    return this._output.previous_token_wrapped;
  };
  Printer.prototype.print_newline = function(force) {
    this._output.add_new_line(force);
  };
  Printer.prototype.print_token = function(token2) {
    if (token2.text) {
      this._output.set_indent(this.indent_level, this.alignment_size);
      this._output.add_token(token2.text);
    }
  };
  Printer.prototype.indent = function() {
    this.indent_level++;
  };
  Printer.prototype.get_full_indent = function(level) {
    level = this.indent_level + (level || 0);
    if (level < 1) {
      return "";
    }
    return this._output.get_indent_string(level);
  };
  var get_type_attribute = function(start_token) {
    var result = null;
    var raw_token = start_token.next;
    while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
      if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
        if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
          result = raw_token.next.next.text;
        }
        break;
      }
      raw_token = raw_token.next;
    }
    return result;
  };
  var get_custom_beautifier_name = function(tag_check, raw_token) {
    var typeAttribute = null;
    var result = null;
    if (!raw_token.closed) {
      return null;
    }
    if (tag_check === "script") {
      typeAttribute = "text/javascript";
    } else if (tag_check === "style") {
      typeAttribute = "text/css";
    }
    typeAttribute = get_type_attribute(raw_token) || typeAttribute;
    if (typeAttribute.search("text/css") > -1) {
      result = "css";
    } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
      result = "javascript";
    } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
      result = "html";
    } else if (typeAttribute.search(/test\/null/) > -1) {
      result = "null";
    }
    return result;
  };
  function in_array(what, arr2) {
    return arr2.indexOf(what) !== -1;
  }
  function TagFrame(parent2, parser_token, indent_level) {
    this.parent = parent2 || null;
    this.tag = parser_token ? parser_token.tag_name : "";
    this.indent_level = indent_level || 0;
    this.parser_token = parser_token || null;
  }
  function TagStack(printer) {
    this._printer = printer;
    this._current_frame = null;
  }
  TagStack.prototype.get_parser_token = function() {
    return this._current_frame ? this._current_frame.parser_token : null;
  };
  TagStack.prototype.record_tag = function(parser_token) {
    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
    this._current_frame = new_frame;
  };
  TagStack.prototype._try_pop_frame = function(frame) {
    var parser_token = null;
    if (frame) {
      parser_token = frame.parser_token;
      this._printer.indent_level = frame.indent_level;
      this._current_frame = frame.parent;
    }
    return parser_token;
  };
  TagStack.prototype._get_frame = function(tag_list, stop_list) {
    var frame = this._current_frame;
    while (frame) {
      if (tag_list.indexOf(frame.tag) !== -1) {
        break;
      } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
        frame = null;
        break;
      }
      frame = frame.parent;
    }
    return frame;
  };
  TagStack.prototype.try_pop = function(tag, stop_list) {
    var frame = this._get_frame([tag], stop_list);
    return this._try_pop_frame(frame);
  };
  TagStack.prototype.indent_to_tag = function(tag_list) {
    var frame = this._get_frame(tag_list);
    if (frame) {
      this._printer.indent_level = frame.indent_level;
    }
  };
  function Beautifier(source_text, options2, js_beautify, css_beautify) {
    this._source_text = source_text || "";
    options2 = options2 || {};
    this._js_beautify = js_beautify;
    this._css_beautify = css_beautify;
    this._tag_stack = null;
    var optionHtml = new Options(options2, "html");
    this._options = optionHtml;
    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
  }
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak2.test(source_text)) {
        eol = source_text.match(lineBreak2)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    var last_token = {
      text: "",
      type: ""
    };
    var last_tag_token = new TagOpenParserToken();
    var printer = new Printer(this._options, baseIndentString);
    var tokens = new Tokenizer(source_text, this._options).tokenize();
    this._tag_stack = new TagStack(printer);
    var parser_token = null;
    var raw_token = tokens.next();
    while (raw_token.type !== TOKEN.EOF) {
      if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
        parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);
        last_tag_token = parser_token;
      } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
        parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);
      } else if (raw_token.type === TOKEN.TAG_CLOSE) {
        parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
      } else if (raw_token.type === TOKEN.TEXT) {
        parser_token = this._handle_text(printer, raw_token, last_tag_token);
      } else {
        printer.add_raw_token(raw_token);
      }
      last_token = parser_token;
      raw_token = tokens.next();
    }
    var sweet_code = printer._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.alignment_size = 0;
    last_tag_token.tag_complete = true;
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      if (last_tag_token.tag_start_char === "<") {
        printer.set_space_before_token(raw_token.text[0] === "/", true);
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
          printer.print_newline(false);
        }
      }
      printer.print_token(raw_token);
    }
    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.indent();
      last_tag_token.indent_content = false;
    }
    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.set_wrap_point();
    }
    return parser_token;
  };
  Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {
    var wrapped = last_tag_token.has_wrapped_attrs;
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
      if (printer.print_preserved_newlines(raw_token)) {
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
      } else {
        printer.print_token(raw_token);
      }
    } else {
      if (raw_token.type === TOKEN.ATTRIBUTE) {
        printer.set_space_before_token(true);
        last_tag_token.attr_count += 1;
      } else if (raw_token.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      }
      if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
        if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
          printer.traverse_whitespace(raw_token);
          wrapped = wrapped || raw_token.newlines !== 0;
        }
        if (this._is_wrap_attributes_force) {
          var force_attr_wrap = last_tag_token.attr_count > 1;
          if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {
            var is_only_attribute = true;
            var peek_index = 0;
            var peek_token;
            do {
              peek_token = tokens.peek(peek_index);
              if (peek_token.type === TOKEN.ATTRIBUTE) {
                is_only_attribute = false;
                break;
              }
              peek_index += 1;
            } while (peek_index < 4 && peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
            force_attr_wrap = !is_only_attribute;
          }
          if (force_attr_wrap) {
            printer.print_newline(false);
            wrapped = true;
          }
        }
      }
      printer.print_token(raw_token);
      wrapped = wrapped || printer.previous_token_wrapped();
      last_tag_token.has_wrapped_attrs = wrapped;
    }
    return parser_token;
  };
  Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: "TK_CONTENT"
    };
    if (last_tag_token.custom_beautifier_name) {
      this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      printer.traverse_whitespace(raw_token);
      printer.print_token(raw_token);
    }
    return parser_token;
  };
  Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
    var local = this;
    if (raw_token.text !== "") {
      var text = raw_token.text, _beautifier, script_indent_level = 1, pre = "", post = "";
      if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
        _beautifier = this._js_beautify;
      } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
        _beautifier = this._css_beautify;
      } else if (last_tag_token.custom_beautifier_name === "html") {
        _beautifier = function(html_source, options2) {
          var beautifier2 = new Beautifier(html_source, options2, local._js_beautify, local._css_beautify);
          return beautifier2.beautify();
        };
      }
      if (this._options.indent_scripts === "keep") {
        script_indent_level = 0;
      } else if (this._options.indent_scripts === "separate") {
        script_indent_level = -printer.indent_level;
      }
      var indentation = printer.get_full_indent(script_indent_level);
      text = text.replace(/\n[ \t]*$/, "");
      if (last_tag_token.custom_beautifier_name !== "html" && text[0] === "<" && text.match(/^(<!--|<!\[CDATA\[)/)) {
        var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);
        if (!matched) {
          printer.add_raw_token(raw_token);
          return;
        }
        pre = indentation + matched[1] + "\n";
        text = matched[4];
        if (matched[5]) {
          post = indentation + matched[5];
        }
        text = text.replace(/\n[ \t]*$/, "");
        if (matched[2] || matched[3].indexOf("\n") !== -1) {
          matched = matched[3].match(/[ \t]+$/);
          if (matched) {
            raw_token.whitespace_before = matched[0];
          }
        }
      }
      if (text) {
        if (_beautifier) {
          var Child_options = function() {
            this.eol = "\n";
          };
          Child_options.prototype = this._options.raw_options;
          var child_options = new Child_options();
          text = _beautifier(indentation + text, child_options);
        } else {
          var white = raw_token.whitespace_before;
          if (white) {
            text = text.replace(new RegExp("\n(" + white + ")?", "g"), "\n");
          }
          text = indentation + text.replace(/\n/g, "\n" + indentation);
        }
      }
      if (pre) {
        if (!text) {
          text = pre + post;
        } else {
          text = pre + text + "\n" + post;
        }
      }
      printer.print_newline(false);
      if (text) {
        raw_token.text = text;
        raw_token.whitespace_before = "";
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
        printer.print_newline(true);
      }
    }
  };
  Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {
    var parser_token = this._get_tag_open_token(raw_token);
    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && raw_token.text.indexOf("</") === 0) {
      printer.add_raw_token(raw_token);
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
    } else {
      printer.traverse_whitespace(raw_token);
      this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
      if (!parser_token.is_inline_element) {
        printer.set_wrap_point();
      }
      printer.print_token(raw_token);
    }
    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
      parser_token.alignment_size = raw_token.text.length + 1;
    }
    if (!parser_token.tag_complete && !parser_token.is_unformatted) {
      printer.alignment_size = parser_token.alignment_size;
    }
    return parser_token;
  };
  var TagOpenParserToken = function(parent2, raw_token) {
    this.parent = parent2 || null;
    this.text = "";
    this.type = "TK_TAG_OPEN";
    this.tag_name = "";
    this.is_inline_element = false;
    this.is_unformatted = false;
    this.is_content_unformatted = false;
    this.is_empty_element = false;
    this.is_start_tag = false;
    this.is_end_tag = false;
    this.indent_content = false;
    this.multiline_content = false;
    this.custom_beautifier_name = null;
    this.start_tag_token = null;
    this.attr_count = 0;
    this.has_wrapped_attrs = false;
    this.alignment_size = 0;
    this.tag_complete = false;
    this.tag_start_char = "";
    this.tag_check = "";
    if (!raw_token) {
      this.tag_complete = true;
    } else {
      var tag_check_match;
      this.tag_start_char = raw_token.text[0];
      this.text = raw_token.text;
      if (this.tag_start_char === "<") {
        tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
      } else {
        tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
        if ((raw_token.text.startsWith("{{#>") || raw_token.text.startsWith("{{~#>")) && this.tag_check[0] === ">") {
          if (this.tag_check === ">" && raw_token.next !== null) {
            this.tag_check = raw_token.next.text.split(" ")[0];
          } else {
            this.tag_check = raw_token.text.split(">")[1];
          }
        }
      }
      this.tag_check = this.tag_check.toLowerCase();
      if (raw_token.type === TOKEN.COMMENT) {
        this.tag_complete = true;
      }
      this.is_start_tag = this.tag_check.charAt(0) !== "/";
      this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
      this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
      var handlebar_starts = 2;
      if (this.tag_start_char === "{" && this.text.length >= 3) {
        if (this.text.charAt(2) === "~") {
          handlebar_starts = 3;
        }
      }
      this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (this.text.length < 3 || /[^#\^]/.test(this.text.charAt(handlebar_starts)));
    }
  };
  Beautifier.prototype._get_tag_open_token = function(raw_token) {
    var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);
    parser_token.alignment_size = this._options.wrap_attributes_indent_size;
    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || parser_token.tag_name.includes("-") || parser_token.tag_start_char === "{";
    return parser_token;
  };
  Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
    if (!parser_token.is_empty_element) {
      if (parser_token.is_end_tag) {
        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
      } else {
        if (this._do_optional_end_element(parser_token)) {
          if (!parser_token.is_inline_element) {
            printer.print_newline(false);
          }
        }
        this._tag_stack.record_tag(parser_token);
        if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
          parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
        }
      }
    }
    if (in_array(parser_token.tag_check, this._options.extra_liners)) {
      printer.print_newline(false);
      if (!printer._output.just_added_blankline()) {
        printer.print_newline(true);
      }
    }
    if (parser_token.is_empty_element) {
      if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
        this._tag_stack.indent_to_tag(["if", "unless", "each"]);
        parser_token.indent_content = true;
        var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
        if (!foundIfOnCurrentLine) {
          printer.print_newline(false);
        }
      }
      if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf("\n") === -1)
        ;
      else {
        if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
          printer.print_newline(false);
        }
        this._calcluate_parent_multiline(printer, parser_token);
      }
    } else if (parser_token.is_end_tag) {
      var do_end_expand = false;
      do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
      do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
      if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
        do_end_expand = false;
      }
      if (do_end_expand) {
        printer.print_newline(false);
      }
    } else {
      parser_token.indent_content = !parser_token.custom_beautifier_name;
      if (parser_token.tag_start_char === "<") {
        if (parser_token.tag_name === "html") {
          parser_token.indent_content = this._options.indent_inner_html;
        } else if (parser_token.tag_name === "head") {
          parser_token.indent_content = this._options.indent_head_inner_html;
        } else if (parser_token.tag_name === "body") {
          parser_token.indent_content = this._options.indent_body_inner_html;
        }
      }
      if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  };
  Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
      parser_token.parent.multiline_content = true;
    }
  };
  var p_closers = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"];
  var p_parent_excludes = ["a", "audio", "del", "ins", "map", "noscript", "video"];
  Beautifier.prototype._do_optional_end_element = function(parser_token) {
    var result = null;
    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
      return;
    }
    if (parser_token.tag_name === "body") {
      result = result || this._tag_stack.try_pop("head");
    } else if (parser_token.tag_name === "li") {
      result = result || this._tag_stack.try_pop("li", ["ol", "ul"]);
    } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
      result = result || this._tag_stack.try_pop("dt", ["dl"]);
      result = result || this._tag_stack.try_pop("dd", ["dl"]);
    } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
      var p_parent = parser_token.parent.parent;
      if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
        result = result || this._tag_stack.try_pop("p");
      }
    } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
      result = result || this._tag_stack.try_pop("rt", ["ruby", "rtc"]);
      result = result || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
    } else if (parser_token.tag_name === "optgroup") {
      result = result || this._tag_stack.try_pop("optgroup", ["select"]);
    } else if (parser_token.tag_name === "option") {
      result = result || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]);
    } else if (parser_token.tag_name === "colgroup") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
    } else if (parser_token.tag_name === "thead") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
    } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("thead", ["table"]);
      result = result || this._tag_stack.try_pop("tbody", ["table"]);
    } else if (parser_token.tag_name === "tr") {
      result = result || this._tag_stack.try_pop("caption", ["table"]);
      result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      result = result || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]);
    } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
      result = result || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]);
      result = result || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
    }
    parser_token.parent = this._tag_stack.get_parser_token();
    return result;
  };
  beautifier.Beautifier = Beautifier;
  return beautifier;
}
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml)
    return html.exports;
  hasRequiredHtml = 1;
  var Beautifier = requireBeautifier().Beautifier, Options = requireOptions().Options;
  function style_html(html_source, options2, js_beautify, css_beautify) {
    var beautifier2 = new Beautifier(html_source, options2, js_beautify, css_beautify);
    return beautifier2.beautify();
  }
  html.exports = style_html;
  html.exports.defaultOptions = function() {
    return new Options();
  };
  return html.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  var js_beautify = requireJavascript();
  var css_beautify = requireCss();
  var html_beautify = requireHtml();
  function style_html(html_source, options2, js2, css2) {
    js2 = js2 || js_beautify;
    css2 = css2 || css_beautify;
    return html_beautify(html_source, options2, js2, css2);
  }
  style_html.defaultOptions = html_beautify.defaultOptions;
  src.js = js_beautify;
  src.css = css_beautify;
  src.html = style_html;
  return src;
}
(function(module2) {
  function get_beautify(js_beautify, css_beautify, html_beautify) {
    var beautify = function(src2, config2) {
      return js_beautify.js_beautify(src2, config2);
    };
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;
    return beautify;
  }
  {
    (function(mod) {
      var beautifier2 = requireSrc();
      beautifier2.js_beautify = beautifier2.js;
      beautifier2.css_beautify = beautifier2.css;
      beautifier2.html_beautify = beautifier2.html;
      mod.exports = get_beautify(beautifier2, beautifier2, beautifier2);
    })(module2);
  }
})(js);
var jsExports = js.exports;
let Editor$1 = class Editor2 extends EventEmitter$1 {
  constructor(parent2) {
    super();
    console.log("*** Editor class created");
    this.mutator = new Mutator(this);
    const extraKeys = {};
    Object.entries(keymaps).forEach(([key, e]) => extraKeys[key] = () => {
      if (e == "editor:evalBlock") {
        this.emit(e, this.getCurrentBlock().text);
      } else if (e == "editor:evalLine") {
        this.emit(e, this.getLine());
      } else if (e == "editor:toggleComment") {
        this.cm.toggleComment();
        this.emit(e, this);
      } else if (e === "editor:formatCode") {
        this.formatCode();
      } else {
        this.emit(e, this);
      }
    });
    const opts = {
      theme: "tomorrow-night-eighties",
      value: "hello",
      mode: { name: "javascript", globalVars: true },
      lineWrapping: true,
      styleSelectedText: true,
      extraKeys
    };
    this.cm = CodeMirror.fromTextArea(parent2, opts);
    window.cm = this.cm;
    this.cm.refresh();
  }
  clear() {
    this.cm.setValue('\n \n // Type some code on a new line (such as "osc().out()"), and press CTRL+shift+enter');
  }
  setValue(val) {
    this.cm.setValue(val);
  }
  getValue() {
    return this.cm.getValue();
  }
  formatCode() {
    const formatted = jsExports.js_beautify(this.cm.getValue(), { indent_size: 2, "break_chained_methods": true, "indent_with_tabs": true });
    this.cm.setValue(formatted);
  }
  // hide() {
  //   console.log('hiding')
  //   var l = document.getElementsByClassName('CodeMirror')[0]
  //   var m = document.getElementById('modal-header')
  //   l.style.opacity = 0
  //   m.style.opacity = 0
  //   this.isShowing = false
  // }
  // show() {
  //   var l = document.getElementsByClassName('CodeMirror')[0]
  //   var m = document.getElementById('modal-header')
  //   l.style.opacity= 1
  //   m.style.opacity = 1
  //   l.style.pointerEvents = 'all'
  //   this.isShowing = true
  // }
  toggle() {
    if (this.isShowing) {
      this.hide();
    } else {
      this.show();
    }
  }
  getLine() {
    var c = this.cm.getCursor();
    var s2 = this.cm.getLine(c.line);
    this.flashCode({ line: c.line, ch: 0 }, { line: c.line + 1, ch: 0 });
    return s2;
  }
  flashCode(start, end) {
    if (!start)
      start = { line: this.cm.firstLine(), ch: 0 };
    if (!end)
      end = { line: this.cm.lastLine() + 1, ch: 0 };
    var marker = this.cm.markText(start, end, { className: "styled-background" });
    setTimeout(() => marker.clear(), 300);
  }
  getCurrentBlock() {
    var editor = this.cm;
    var pos = editor.getCursor();
    var startline = pos.line;
    var endline = pos.line;
    while (startline > 0 && editor.getLine(startline) !== "") {
      startline--;
    }
    while (endline < editor.lineCount() && editor.getLine(endline) !== "") {
      endline++;
    }
    var pos1 = {
      line: startline,
      ch: 0
    };
    var pos2 = {
      line: endline,
      ch: 0
    };
    var str = editor.getRange(pos1, pos2);
    this.flashCode(pos1, pos2);
    return {
      start: pos1,
      end: pos2,
      text: str
    };
  }
};
class Editor extends Component {
  constructor(id2, state2, emit2) {
    super(id2);
    this.local = state2.components[id2] = {};
    state2.editor = this;
    this.emit = emit2;
  }
  load(element) {
    log$1.init(this.logElement);
    this.editor = new Editor$1(this.textEl);
    this.editor.on("*", (e, args) => {
      this.emit(e, args);
    });
    this.innerText = document.getElementsByClassName("CodeMirror")[0];
  }
  hide() {
    this.innerText.style.opacity = 0;
  }
  show() {
    this.innerText.style.opacity = 1;
    this.innerText.style.pointerEvents = "all";
  }
  update(state2) {
    if (state2.showInfo === true || state2.showUI === false) {
      this.hide();
    } else {
      this.show();
    }
    return false;
  }
  createElement({ width = window.innerWidth, height = window.innerHeight } = {}) {
    this.textEl = html$2` <textarea></textarea>`;
    this.logElement = html$2`<div class="console cm-s-tomorrow-night-eighties"></div>`;
    return html$2`<div id="editor-container" style="display:flex;flex-direction:column;">
       <div style="position:relative;flex:auto;padding:15px">${this.textEl}</div>
       ${this.logElement}
       </div>`;
  }
}
function mainView(state2, emit2) {
  return html$2`
  <body>
    <div id="hydra-ui">
      ${state2.cache(Hydra, "hydra-canvas").render(state2, emit2)}
      <!---<canvas id="audio-canvas">
      </canvas>--->
    </div>
  ${mainView$1(state2, emit2)}
  ${state2.cache(Editor, "editor").render(state2, emit2)}
  </body>
 `;
}
const app = choo$1();
app.use(devtools());
app.use(store$1);
app.use(store);
app.route("/", mainView);
app.mount("body");
const fontawesome = "";
const codemirror = "";
const tomorrowNightEighties = "";
const showHint = "";
const style = "";
const modal = "";
