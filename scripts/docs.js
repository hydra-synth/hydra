#!/usr/bin/node
// Script to build documentation from source.

const fs = require('fs')
const glslTransforms = require('hydra-synth/src/composable-glsl-functions.js')
const Mustache = require('mustache')

const masterTemplateFile = 'docs/funcs.md.template';

const functionTemplate = `
### {{ name }}

\`{{ prototype }}\`

{{# inputs }}* \`{{ name }}\` :: {{& type }}{{# default }} (default \`{{ default }}\`){{/ default }}
{{/inputs}}
{{# description }}

{{& description }}
{{/ description }}
{{# example }}

#### Example

\`\`\`javascript
{{& example }}
\`\`\`{{/ example }}`

var categories = {
  'color': [],
  'geometry': [],
  'operators': [],
  'modulators': [],
  'sources': [],
}

const categoryMap = {
  'color': 'color',
  'combine': 'operators',
  'combineCoord': 'modulators',
  'coord': 'geometry',
  'src': 'sources',
}

function stripInitialWhitespace(paragraph) {
  if (paragraph === undefined)
    return undefined;

  if (paragraph[0] == '\n')
    paragraph = paragraph.slice(1)

  let firstCharacterIndex = paragraph.match(/[^ \n]/).index;
  let lines = [];
  for (line of paragraph.split('\n')) {
    lines.push(line.slice(firstCharacterIndex));
  }
  return lines.join('\n');
}

function renderFunctionPrototype(name, info) {
  let parameters = info['inputs'].map((input) => input.name).join(', ');
  if (info['type'] == 'src')
    return `${name}( ${parameters} )`;
  else
    return `.${name}( ${parameters} )`;
}

function processFunctionInputs(inputs) {
  return inputs.map((entry) => {
    if (entry['default'] != undefined)
      entry['default'] = entry['default'].toString();
    return entry;
  });
}

function renderFunction(name, info) {
  let view = {
    'name': name,
    'description': stripInitialWhitespace(info['description']),
    'example':  stripInitialWhitespace(info['example']),
    'prototype': renderFunctionPrototype(name, info),
    'inputs': processFunctionInputs(info['inputs']),
  }

  let markdown = Mustache.render(functionTemplate, view);
  return markdown;
}

function renderFunctions(functions) {
  return functions.sort().map((name) => renderFunction(name, glslTransforms[name])).join('\n');
}

function renderTableOfContents(functions) {
  return functions.sort().map((name) => `  - [${name}](#${name.toLowerCase()})`).join('\n');
}

function main(outPath) {
  for (name in glslTransforms) {
    method = glslTransforms[name];
    if (name[0] == '_' || method.type == 'util')
      console.log(`Ignoring private function ${name}`);
    else if (! method['inputs'])
      console.log(`Ignoring function with no inputs ${name}`)
    else {
      let cat = categoryMap[method['type']];

      categories[cat].push(name);
    }
  }

  fs.readFile(masterTemplateFile, 'utf-8', (err, masterTemplateData) => {
    if (err) throw err;

    let view = {};

    for (cat in categories) {
      view[`category-toc-${cat}`] = renderTableOfContents(categories[cat])
      view[`functions-${cat}`] = renderFunctions(categories[cat])
    }

    let output = '<!-- This function is generated by scripts/docs.js. Do not edit it directly!\n' +
                 '     It\'s generated from funcs.md.template and from content in hydra-synth.git. -->\n' +
      Mustache.render(masterTemplateData, view);

    fs.writeFile(outPath, output, (err) => {
      if (err) throw err;
    });
  });
};

const [,, outPath] = process.argv

if (! outPath) {
  console.log(`Usage: ${process.argv[1]} docs/funcs.md`);
  process.exit(1);
}

main(outPath);
